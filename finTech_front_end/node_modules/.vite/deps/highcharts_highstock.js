import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/highcharts/highstock.js
var require_highstock = __commonJS({
  "node_modules/highcharts/highstock.js"(exports, module) {
    !/**
    * Highcharts JS v12.1.2 (2024-12-21)
    * @module highcharts/highcharts
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? (t._Highcharts = e(), module.exports = t._Highcharts) : "function" == typeof define && define.amd ? define("highcharts/highcharts", [], e) : "object" == typeof exports ? (t._Highcharts = e(), exports.highcharts = t._Highcharts) : (t.Highcharts && t.Highcharts.error(16, true), t.Highcharts = e());
    }("undefined" == typeof window ? exports : window, () => (() => {
      "use strict";
      let t, e, i, s, o, r;
      var a, n, h, l, d, c, p, u, g, f, m, x, y, b, v, k, M, w, S, A, T, C, P, O = {};
      O.d = (t10, e10) => {
        for (var i10 in e10) O.o(e10, i10) && !O.o(t10, i10) && Object.defineProperty(t10, i10, { enumerable: true, get: e10[i10] });
      }, O.o = (t10, e10) => Object.prototype.hasOwnProperty.call(t10, e10);
      var E = {};
      O.d(E, { default: () => uH }), function(t10) {
        var _a, _b, _c;
        t10.SVG_NS = "http://www.w3.org/2000/svg", t10.product = "Highcharts", t10.version = "12.1.2", t10.win = "undefined" != typeof window ? window : {}, t10.doc = t10.win.document, t10.svg = t10.doc && t10.doc.createElementNS && !!t10.doc.createElementNS(t10.SVG_NS, "svg").createSVGRect, t10.pageLang = (_c = (_b = (_a = t10.doc) == null ? void 0 : _a.documentElement) == null ? void 0 : _b.closest("[lang]")) == null ? void 0 : _c.lang, t10.userAgent = t10.win.navigator && t10.win.navigator.userAgent || "", t10.isChrome = t10.win.chrome, t10.isFirefox = -1 !== t10.userAgent.indexOf("Firefox"), t10.isMS = /(edge|msie|trident)/i.test(t10.userAgent) && !t10.win.opera, t10.isSafari = !t10.isChrome && -1 !== t10.userAgent.indexOf("Safari"), t10.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(t10.userAgent), t10.isWebKit = -1 !== t10.userAgent.indexOf("AppleWebKit"), t10.deg2rad = 2 * Math.PI / 360, t10.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], t10.noop = function() {
        }, t10.supportsPassiveEvents = function() {
          let e10 = false;
          if (!t10.isMS) {
            let i10 = Object.defineProperty({}, "passive", { get: function() {
              e10 = true;
            } });
            t10.win.addEventListener && t10.win.removeEventListener && (t10.win.addEventListener("testPassive", t10.noop, i10), t10.win.removeEventListener("testPassive", t10.noop, i10));
          }
          return e10;
        }(), t10.charts = [], t10.composed = [], t10.dateFormats = {}, t10.seriesTypes = {}, t10.symbolSizes = {}, t10.chartCount = 0;
      }(a || (a = {}));
      let L = a, { charts: D, doc: B, win: I } = L;
      function z(t10, e10, i10, s10) {
        let o10 = e10 ? "Highcharts error" : "Highcharts warning";
        32 === t10 && (t10 = `${o10}: Deprecated member`);
        let r10 = F(t10), a10 = r10 ? `${o10} #${t10}: www.highcharts.com/errors/${t10}/` : t10.toString();
        if (void 0 !== s10) {
          let t11 = "";
          r10 && (a10 += "?"), J(s10, function(e11, i11) {
            t11 += `
 - ${i11}: ${e11}`, r10 && (a10 += encodeURI(i11) + "=" + encodeURI(e11));
          }), a10 += t11;
        }
        tt(L, "displayError", { chart: i10, code: t10, message: a10, params: s10 }, function() {
          if (e10) throw Error(a10);
          I.console && -1 === z.messages.indexOf(a10) && console.warn(a10);
        }), z.messages.push(a10);
      }
      function R(t10, e10) {
        return parseInt(t10, e10 || 10);
      }
      function N(t10) {
        return "string" == typeof t10;
      }
      function W(t10) {
        let e10 = Object.prototype.toString.call(t10);
        return "[object Array]" === e10 || "[object Array Iterator]" === e10;
      }
      function G(t10, e10) {
        return !!t10 && "object" == typeof t10 && (!e10 || !W(t10));
      }
      function X(t10) {
        return G(t10) && "number" == typeof t10.nodeType;
      }
      function H(t10) {
        let e10 = t10 && t10.constructor;
        return !!(G(t10, true) && !X(t10) && e10 && e10.name && "Object" !== e10.name);
      }
      function F(t10) {
        return "number" == typeof t10 && !isNaN(t10) && t10 < 1 / 0 && t10 > -1 / 0;
      }
      function Y(t10) {
        return null != t10;
      }
      function j(t10, e10, i10) {
        let s10;
        let o10 = N(e10) && !Y(i10), r10 = (e11, i11) => {
          Y(e11) ? t10.setAttribute(i11, e11) : o10 ? (s10 = t10.getAttribute(i11)) || "class" !== i11 || (s10 = t10.getAttribute(i11 + "Name")) : t10.removeAttribute(i11);
        };
        return N(e10) ? r10(i10, e10) : J(e10, r10), s10;
      }
      function U(t10) {
        return W(t10) ? t10 : [t10];
      }
      function V(t10, e10) {
        let i10;
        for (i10 in t10 || (t10 = {}), e10) t10[i10] = e10[i10];
        return t10;
      }
      function _() {
        let t10 = arguments, e10 = t10.length;
        for (let i10 = 0; i10 < e10; i10++) {
          let e11 = t10[i10];
          if (null != e11) return e11;
        }
      }
      function $(t10, e10) {
        V(t10.style, e10);
      }
      function Z(t10) {
        return Math.pow(10, Math.floor(Math.log(t10) / Math.LN10));
      }
      function q(t10, e10) {
        return t10 > 1e14 ? t10 : parseFloat(t10.toPrecision(e10 || 14));
      }
      (z || (z = {})).messages = [], Math.easeInOutSine = function(t10) {
        return -0.5 * (Math.cos(Math.PI * t10) - 1);
      };
      let K = Array.prototype.find ? function(t10, e10) {
        return t10.find(e10);
      } : function(t10, e10) {
        let i10;
        let s10 = t10.length;
        for (i10 = 0; i10 < s10; i10++) if (e10(t10[i10], i10)) return t10[i10];
      };
      function J(t10, e10, i10) {
        for (let s10 in t10) Object.hasOwnProperty.call(t10, s10) && e10.call(i10 || t10[s10], t10[s10], s10, t10);
      }
      function Q(t10, e10, i10) {
        function s10(e11, i11) {
          let s11 = t10.removeEventListener;
          s11 && s11.call(t10, e11, i11, false);
        }
        function o10(i11) {
          let o11, r11;
          t10.nodeName && (e10 ? (o11 = {})[e10] = true : o11 = i11, J(o11, function(t11, e11) {
            if (i11[e11]) for (r11 = i11[e11].length; r11--; ) s10(e11, i11[e11][r11].fn);
          }));
        }
        let r10 = "function" == typeof t10 && t10.prototype || t10;
        if (Object.hasOwnProperty.call(r10, "hcEvents")) {
          let t11 = r10.hcEvents;
          if (e10) {
            let r11 = t11[e10] || [];
            i10 ? (t11[e10] = r11.filter(function(t12) {
              return i10 !== t12.fn;
            }), s10(e10, i10)) : (o10(t11), t11[e10] = []);
          } else o10(t11), delete r10.hcEvents;
        }
      }
      function tt(t10, e10, i10, s10) {
        if (i10 = i10 || {}, B.createEvent && (t10.dispatchEvent || t10.fireEvent && t10 !== L)) {
          let s11 = B.createEvent("Events");
          s11.initEvent(e10, true, true), i10 = V(s11, i10), t10.dispatchEvent ? t10.dispatchEvent(i10) : t10.fireEvent(e10, i10);
        } else if (t10.hcEvents) {
          i10.target || V(i10, { preventDefault: function() {
            i10.defaultPrevented = true;
          }, target: t10, type: e10 });
          let s11 = [], o10 = t10, r10 = false;
          for (; o10.hcEvents; ) Object.hasOwnProperty.call(o10, "hcEvents") && o10.hcEvents[e10] && (s11.length && (r10 = true), s11.unshift.apply(s11, o10.hcEvents[e10])), o10 = Object.getPrototypeOf(o10);
          r10 && s11.sort((t11, e11) => t11.order - e11.order), s11.forEach((e11) => {
            false === e11.fn.call(t10, i10) && i10.preventDefault();
          });
        }
        s10 && !i10.defaultPrevented && s10.call(t10, i10);
      }
      let te = function() {
        let e10 = Math.random().toString(36).substring(2, 9) + "-", i10 = 0;
        return function() {
          return "highcharts-" + (t ? "" : e10) + i10++;
        };
      }();
      I.jQuery && (I.jQuery.fn.highcharts = function() {
        let t10 = [].slice.call(arguments);
        if (this[0]) return t10[0] ? (new L[N(t10[0]) ? t10.shift() : "Chart"](this[0], t10[0], t10[1]), this) : D[j(this[0], "data-highcharts-chart")];
      });
      let ti = { addEvent: function(t10, e10, i10, s10 = {}) {
        let o10 = "function" == typeof t10 && t10.prototype || t10;
        Object.hasOwnProperty.call(o10, "hcEvents") || (o10.hcEvents = {});
        let r10 = o10.hcEvents;
        L.Point && t10 instanceof L.Point && t10.series && t10.series.chart && (t10.series.chart.runTrackerClick = true);
        let a10 = t10.addEventListener;
        a10 && a10.call(t10, e10, i10, !!L.supportsPassiveEvents && { passive: void 0 === s10.passive ? -1 !== e10.indexOf("touch") : s10.passive, capture: false }), r10[e10] || (r10[e10] = []);
        let n10 = { fn: i10, order: "number" == typeof s10.order ? s10.order : 1 / 0 };
        return r10[e10].push(n10), r10[e10].sort((t11, e11) => t11.order - e11.order), function() {
          Q(t10, e10, i10);
        };
      }, arrayMax: function(t10) {
        let e10 = t10.length, i10 = t10[0];
        for (; e10--; ) t10[e10] > i10 && (i10 = t10[e10]);
        return i10;
      }, arrayMin: function(t10) {
        let e10 = t10.length, i10 = t10[0];
        for (; e10--; ) t10[e10] < i10 && (i10 = t10[e10]);
        return i10;
      }, attr: j, clamp: function(t10, e10, i10) {
        return t10 > e10 ? t10 < i10 ? t10 : i10 : e10;
      }, clearTimeout: function(t10) {
        Y(t10) && clearTimeout(t10);
      }, correctFloat: q, createElement: function(t10, e10, i10, s10, o10) {
        let r10 = B.createElement(t10);
        return e10 && V(r10, e10), o10 && $(r10, { padding: "0", border: "none", margin: "0" }), i10 && $(r10, i10), s10 && s10.appendChild(r10), r10;
      }, crisp: function(t10, e10 = 0, i10) {
        let s10 = e10 % 2 / 2, o10 = i10 ? -1 : 1;
        return (Math.round(t10 * o10 - s10) + s10) * o10;
      }, css: $, defined: Y, destroyObjectProperties: function(t10, e10, i10) {
        J(t10, function(s10, o10) {
          s10 !== e10 && (s10 == null ? void 0 : s10.destroy) && s10.destroy(), ((s10 == null ? void 0 : s10.destroy) || !i10) && delete t10[o10];
        });
      }, diffObjects: function(t10, e10, i10, s10) {
        let o10 = {};
        return !function t11(e11, o11, r10, a10) {
          let n10 = i10 ? o11 : e11;
          J(e11, function(i11, h10) {
            if (!a10 && s10 && s10.indexOf(h10) > -1 && o11[h10]) {
              i11 = U(i11), r10[h10] = [];
              for (let e12 = 0; e12 < Math.max(i11.length, o11[h10].length); e12++) o11[h10][e12] && (void 0 === i11[e12] ? r10[h10][e12] = o11[h10][e12] : (r10[h10][e12] = {}, t11(i11[e12], o11[h10][e12], r10[h10][e12], a10 + 1)));
            } else G(i11, true) && !i11.nodeType ? (r10[h10] = W(i11) ? [] : {}, t11(i11, o11[h10] || {}, r10[h10], a10 + 1), 0 !== Object.keys(r10[h10]).length || "colorAxis" === h10 && 0 === a10 || delete r10[h10]) : (e11[h10] !== o11[h10] || h10 in e11 && !(h10 in o11)) && "__proto__" !== h10 && "constructor" !== h10 && (r10[h10] = n10[h10]);
          });
        }(t10, e10, o10, 0), o10;
      }, discardElement: function(t10) {
        t10 && t10.parentElement && t10.parentElement.removeChild(t10);
      }, erase: function(t10, e10) {
        let i10 = t10.length;
        for (; i10--; ) if (t10[i10] === e10) {
          t10.splice(i10, 1);
          break;
        }
      }, error: z, extend: V, extendClass: function(t10, e10) {
        let i10 = function() {
        };
        return i10.prototype = new t10(), V(i10.prototype, e10), i10;
      }, find: K, fireEvent: tt, getAlignFactor: (t10 = "") => ({ center: 0.5, right: 1, middle: 0.5, bottom: 1 })[t10] || 0, getClosestDistance: function(t10, e10) {
        let i10, s10, o10, r10;
        let a10 = !e10;
        return t10.forEach((t11) => {
          if (t11.length > 1) for (r10 = s10 = t11.length - 1; r10 > 0; r10--) (o10 = t11[r10] - t11[r10 - 1]) < 0 && !a10 ? (e10 == null ? void 0 : e10(), e10 = void 0) : o10 && (void 0 === i10 || o10 < i10) && (i10 = o10);
        }), i10;
      }, getMagnitude: Z, getNestedProperty: function(t10, e10) {
        let i10 = t10.split(".");
        for (; i10.length && Y(e10); ) {
          let t11 = i10.shift();
          if (void 0 === t11 || "__proto__" === t11) return;
          if ("this" === t11) {
            let t12;
            return G(e10) && (t12 = e10["@this"]), t12 ?? e10;
          }
          let s10 = e10[t11.replace(/[\\'"]/g, "")];
          if (!Y(s10) || "function" == typeof s10 || "number" == typeof s10.nodeType || s10 === I) return;
          e10 = s10;
        }
        return e10;
      }, getStyle: function t10(e10, i10, s10) {
        let o10;
        if ("width" === i10) {
          let i11 = Math.min(e10.offsetWidth, e10.scrollWidth), s11 = e10.getBoundingClientRect && e10.getBoundingClientRect().width;
          return s11 < i11 && s11 >= i11 - 1 && (i11 = Math.floor(s11)), Math.max(0, i11 - (t10(e10, "padding-left", true) || 0) - (t10(e10, "padding-right", true) || 0));
        }
        if ("height" === i10) return Math.max(0, Math.min(e10.offsetHeight, e10.scrollHeight) - (t10(e10, "padding-top", true) || 0) - (t10(e10, "padding-bottom", true) || 0));
        let r10 = I.getComputedStyle(e10, void 0);
        return r10 && (o10 = r10.getPropertyValue(i10), _(s10, "opacity" !== i10) && (o10 = R(o10))), o10;
      }, insertItem: function(t10, e10) {
        let i10;
        let s10 = t10.options.index, o10 = e10.length;
        for (i10 = t10.options.isInternal ? o10 : 0; i10 < o10 + 1; i10++) if (!e10[i10] || F(s10) && s10 < _(e10[i10].options.index, e10[i10]._i) || e10[i10].options.isInternal) {
          e10.splice(i10, 0, t10);
          break;
        }
        return i10;
      }, isArray: W, isClass: H, isDOMElement: X, isFunction: function(t10) {
        return "function" == typeof t10;
      }, isNumber: F, isObject: G, isString: N, merge: function(t10, ...e10) {
        let i10, s10 = [t10, ...e10], o10 = {}, r10 = function(t11, e11) {
          return "object" != typeof t11 && (t11 = {}), J(e11, function(i11, s11) {
            "__proto__" !== s11 && "constructor" !== s11 && (!G(i11, true) || H(i11) || X(i11) ? t11[s11] = e11[s11] : t11[s11] = r10(t11[s11] || {}, i11));
          }), t11;
        };
        true === t10 && (o10 = s10[1], s10 = Array.prototype.slice.call(s10, 2));
        let a10 = s10.length;
        for (i10 = 0; i10 < a10; i10++) o10 = r10(o10, s10[i10]);
        return o10;
      }, normalizeTickInterval: function(t10, e10, i10, s10, o10) {
        let r10, a10 = t10;
        i10 = _(i10, Z(t10));
        let n10 = t10 / i10;
        for (!e10 && (e10 = o10 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === s10 && (1 === i10 ? e10 = e10.filter(function(t11) {
          return t11 % 1 == 0;
        }) : i10 <= 0.1 && (e10 = [1 / i10]))), r10 = 0; r10 < e10.length && (a10 = e10[r10], (!o10 || !(a10 * i10 >= t10)) && (o10 || !(n10 <= (e10[r10] + (e10[r10 + 1] || e10[r10])) / 2))); r10++) ;
        return q(a10 * i10, -Math.round(Math.log(1e-3) / Math.LN10));
      }, objectEach: J, offset: function(t10) {
        let e10 = B.documentElement, i10 = t10.parentElement || t10.parentNode ? t10.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
        return { top: i10.top + (I.pageYOffset || e10.scrollTop) - (e10.clientTop || 0), left: i10.left + (I.pageXOffset || e10.scrollLeft) - (e10.clientLeft || 0), width: i10.width, height: i10.height };
      }, pad: function(t10, e10, i10) {
        return Array((e10 || 2) + 1 - String(t10).replace("-", "").length).join(i10 || "0") + t10;
      }, pick: _, pInt: R, pushUnique: function(t10, e10) {
        return 0 > t10.indexOf(e10) && !!t10.push(e10);
      }, relativeLength: function(t10, e10, i10) {
        return /%$/.test(t10) ? e10 * parseFloat(t10) / 100 + (i10 || 0) : parseFloat(t10);
      }, removeEvent: Q, replaceNested: function(t10, ...e10) {
        let i10, s10;
        do
          for (s10 of (i10 = t10, e10)) t10 = t10.replace(s10[0], s10[1]);
        while (t10 !== i10);
        return t10;
      }, splat: U, stableSort: function(t10, e10) {
        let i10, s10;
        let o10 = t10.length;
        for (s10 = 0; s10 < o10; s10++) t10[s10].safeI = s10;
        for (t10.sort(function(t11, s11) {
          return 0 === (i10 = e10(t11, s11)) ? t11.safeI - s11.safeI : i10;
        }), s10 = 0; s10 < o10; s10++) delete t10[s10].safeI;
      }, syncTimeout: function(t10, e10, i10) {
        return e10 > 0 ? setTimeout(t10, e10, i10) : (t10.call(0, i10), -1);
      }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, ucfirst: function(t10) {
        return N(t10) ? t10.substring(0, 1).toUpperCase() + t10.substring(1) : String(t10);
      }, uniqueKey: te, useSerialIds: function(e10) {
        return t = _(e10, t);
      }, wrap: function(t10, e10, i10) {
        let s10 = t10[e10];
        t10[e10] = function() {
          let t11 = arguments, e11 = this;
          return i10.apply(this, [function() {
            return s10.apply(e11, arguments.length ? arguments : t11);
          }].concat([].slice.call(arguments)));
        };
      } }, { pageLang: ts, win: to } = L, { defined: tr, error: ta, extend: tn, isNumber: th, isObject: tl, isString: td, merge: tc, objectEach: tp, pad: tu, splat: tg, timeUnits: tf, ucfirst: tm } = ti, tx = L.isSafari && to.Intl && !to.Intl.DateTimeFormat.prototype.formatRange, ty = (t10) => void 0 === t10.main, tb = (t10) => ["D", "L", "M", "X", "J", "V", "S"].indexOf(t10), tv = class {
        constructor(t10) {
          this.options = { timezone: "UTC" }, this.variableTimezone = false, this.Date = to.Date, this.update(t10);
        }
        update(t10 = {}) {
          this.dTLCache = {}, this.options = t10 = tc(true, this.options, t10);
          let { timezoneOffset: e10, useUTC: i10 } = t10;
          this.Date = t10.Date || to.Date || Date;
          let s10 = t10.timezone;
          tr(i10) && (s10 = i10 ? "UTC" : void 0), e10 && e10 % 60 == 0 && (s10 = "Etc/GMT" + (e10 > 0 ? "+" : "") + e10 / 60), this.variableTimezone = "UTC" !== s10 && (s10 == null ? void 0 : s10.indexOf("Etc/GMT")) !== 0, this.timezone = s10, ["months", "shortMonths", "weekdays", "shortWeekdays"].forEach((t11) => {
            let e11 = /months/i.test(t11), i11 = /short/.test(t11), s11 = { timeZone: "UTC" };
            s11[e11 ? "month" : "weekday"] = i11 ? "short" : "long", this[t11] = (e11 ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [3, 4, 5, 6, 7, 8, 9]).map((t12) => this.dateFormat(s11, (e11 ? 31 : 1) * 24 * 36e5 * t12));
          });
        }
        toParts(t10) {
          let [e10, i10, s10, o10, r10, a10, n10] = this.dateTimeFormat({ weekday: "narrow", day: "numeric", month: "numeric", year: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }, t10, "es").split(/(?:, |\/|:)/g);
          return [o10, +s10 - 1, i10, r10, a10, n10, Math.floor(Number(t10) || 0) % 1e3, tb(e10)].map(Number);
        }
        dateTimeFormat(t10, e10, i10 = this.options.locale || ts) {
          let s10 = JSON.stringify(t10) + i10;
          td(t10) && (t10 = this.str2dtf(t10));
          let o10 = this.dTLCache[s10];
          if (!o10) {
            t10.timeZone ?? (t10.timeZone = this.timezone);
            try {
              o10 = new Intl.DateTimeFormat(i10, t10);
            } catch (e11) {
              /Invalid time zone/i.test(e11.message) ? (ta(34), t10.timeZone = "UTC", o10 = new Intl.DateTimeFormat(i10, t10)) : ta(e11.message, false);
            }
          }
          return this.dTLCache[s10] = o10, (o10 == null ? void 0 : o10.format(e10)) || "";
        }
        str2dtf(t10, e10 = {}) {
          let i10 = { L: { fractionalSecondDigits: 3 }, S: { second: "2-digit" }, M: { minute: "numeric" }, H: { hour: "2-digit" }, k: { hour: "numeric" }, E: { weekday: "narrow" }, a: { weekday: "short" }, A: { weekday: "long" }, d: { day: "2-digit" }, e: { day: "numeric" }, b: { month: "short" }, B: { month: "long" }, m: { month: "2-digit" }, o: { month: "numeric" }, y: { year: "2-digit" }, Y: { year: "numeric" } };
          return Object.keys(i10).forEach((s10) => {
            -1 !== t10.indexOf(s10) && tn(e10, i10[s10]);
          }), e10;
        }
        makeTime(t10, e10, i10 = 1, s10 = 0, o10, r10, a10) {
          let n10 = this.Date.UTC(t10, e10, i10, s10, o10 || 0, r10 || 0, a10 || 0);
          if ("UTC" !== this.timezone) {
            let t11 = this.getTimezoneOffset(n10);
            if (n10 += t11, -1 !== [2, 3, 8, 9, 10, 11].indexOf(e10) && (s10 < 5 || s10 > 20)) {
              let e11 = this.getTimezoneOffset(n10);
              t11 !== e11 ? n10 += e11 - t11 : t11 - 36e5 !== this.getTimezoneOffset(n10 - 36e5) || tx || (n10 -= 36e5);
            }
          }
          return n10;
        }
        parse(t10) {
          if (!td(t10)) return t10 ?? void 0;
          let e10 = (t10 = t10.replace(/\//g, "-").replace(/(GMT|UTC)/, "")).indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(t10), i10 = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(t10);
          e10 || i10 || (t10 += "Z");
          let s10 = Date.parse(t10);
          if (th(s10)) return s10 + (!e10 || i10 ? this.getTimezoneOffset(s10) : 0);
        }
        getTimezoneOffset(t10) {
          if ("UTC" !== this.timezone) {
            let [e10, i10, s10, o10, r10 = 0] = this.dateTimeFormat({ timeZoneName: "shortOffset" }, t10, "en").split(/(GMT|:)/).map(Number), a10 = -(36e5 * (s10 + r10 / 60));
            if (th(a10)) return a10;
          }
          return 0;
        }
        dateFormat(t10, e10, i10) {
          var _a;
          let s10 = (_a = L.defaultOptions) == null ? void 0 : _a.lang;
          if (!tr(e10) || isNaN(e10)) return (s10 == null ? void 0 : s10.invalidDate) || "";
          if (td(t10 = t10 ?? "%Y-%m-%d %H:%M:%S")) {
            let i11;
            let s11 = /%\[([a-zA-Z]+)\]/g;
            for (; i11 = s11.exec(t10); ) t10 = t10.replace(i11[0], this.dateTimeFormat(i11[1], e10));
          }
          if (td(t10) && -1 !== t10.indexOf("%")) {
            let i11 = this, [o10, r10, a10, n10, h10, l10, d10, c10] = this.toParts(e10), p10 = (s10 == null ? void 0 : s10.weekdays) || this.weekdays, u2 = (s10 == null ? void 0 : s10.shortWeekdays) || this.shortWeekdays, g2 = (s10 == null ? void 0 : s10.months) || this.months, f2 = (s10 == null ? void 0 : s10.shortMonths) || this.shortMonths;
            tp(tn({ a: u2 ? u2[c10] : p10[c10].substr(0, 3), A: p10[c10], d: tu(a10), e: tu(a10, 2, " "), w: c10, b: f2[r10], B: g2[r10], m: tu(r10 + 1), o: r10 + 1, y: o10.toString().substr(2, 2), Y: o10, H: tu(n10), k: n10, I: tu(n10 % 12 || 12), l: n10 % 12 || 12, M: tu(h10), p: n10 < 12 ? "AM" : "PM", P: n10 < 12 ? "am" : "pm", S: tu(l10), L: tu(d10, 3) }, L.dateFormats), function(s11, o11) {
              if (td(t10)) for (; -1 !== t10.indexOf("%" + o11); ) t10 = t10.replace("%" + o11, "function" == typeof s11 ? s11.call(i11, e10) : s11);
            });
          } else if (tl(t10)) {
            let i11 = (this.getTimezoneOffset(e10) || 0) / 36e5, s11 = this.timezone || "Etc/GMT" + (i11 >= 0 ? "+" : "") + i11, { prefix: o10 = "", suffix: r10 = "" } = t10;
            t10 = o10 + this.dateTimeFormat(tn({ timeZone: s11 }, t10), e10) + r10;
          }
          return i10 ? tm(t10) : t10;
        }
        resolveDTLFormat(t10) {
          return tl(t10, true) ? tl(t10, true) && ty(t10) ? { main: t10 } : t10 : { main: (t10 = tg(t10))[0], from: t10[1], to: t10[2] };
        }
        getTimeTicks(t10, e10, i10, s10) {
          let o10 = this, r10 = [], a10 = {}, { count: n10 = 1, unitRange: h10 } = t10, [l10, d10, c10, p10, u2, g2] = o10.toParts(e10), f2 = (e10 || 0) % 1e3, m2;
          if (s10 ?? (s10 = 1), tr(e10)) {
            if (f2 = h10 >= tf.second ? 0 : n10 * Math.floor(f2 / n10), h10 >= tf.second && (g2 = h10 >= tf.minute ? 0 : n10 * Math.floor(g2 / n10)), h10 >= tf.minute && (u2 = h10 >= tf.hour ? 0 : n10 * Math.floor(u2 / n10)), h10 >= tf.hour && (p10 = h10 >= tf.day ? 0 : n10 * Math.floor(p10 / n10)), h10 >= tf.day && (c10 = h10 >= tf.month ? 1 : Math.max(1, n10 * Math.floor(c10 / n10))), h10 >= tf.month && (d10 = h10 >= tf.year ? 0 : n10 * Math.floor(d10 / n10)), h10 >= tf.year && (l10 -= l10 % n10), h10 === tf.week) {
              n10 && (e10 = o10.makeTime(l10, d10, c10, p10, u2, g2, f2));
              let t12 = tb(this.dateTimeFormat({ timeZone: this.timezone, weekday: "narrow" }, e10, "es"));
              c10 += -t12 + s10 + (t12 < s10 ? -7 : 0);
            }
            e10 = o10.makeTime(l10, d10, c10, p10, u2, g2, f2), o10.variableTimezone && tr(i10) && (m2 = i10 - e10 > 4 * tf.month || o10.getTimezoneOffset(e10) !== o10.getTimezoneOffset(i10));
            let t11 = e10, x2 = 1;
            for (; t11 < i10; ) r10.push(t11), h10 === tf.year ? t11 = o10.makeTime(l10 + x2 * n10, 0) : h10 === tf.month ? t11 = o10.makeTime(l10, d10 + x2 * n10) : m2 && (h10 === tf.day || h10 === tf.week) ? t11 = o10.makeTime(l10, d10, c10 + x2 * n10 * (h10 === tf.day ? 1 : 7)) : m2 && h10 === tf.hour && n10 > 1 ? t11 = o10.makeTime(l10, d10, c10, p10 + x2 * n10) : t11 += h10 * n10, x2++;
            r10.push(t11), h10 <= tf.hour && r10.length < 1e4 && r10.forEach((t12) => {
              t12 % 18e5 == 0 && "000000000" === o10.dateFormat("%H%M%S%L", t12) && (a10[t12] = "day");
            });
          }
          return r10.info = tn(t10, { higherRanks: a10, totalRange: h10 * n10 }), r10;
        }
        getDateFormat(t10, e10, i10, s10) {
          let o10 = this.dateFormat("%m-%d %H:%M:%S.%L", e10), r10 = "01-01 00:00:00.000", a10 = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 }, n10 = "millisecond", h10 = n10;
          for (n10 in tf) {
            if (t10 === tf.week && +this.dateFormat("%w", e10) === i10 && o10.substr(6) === r10.substr(6)) {
              n10 = "week";
              break;
            }
            if (tf[n10] > t10) {
              n10 = h10;
              break;
            }
            if (a10[n10] && o10.substr(a10[n10]) !== r10.substr(a10[n10])) break;
            "week" !== n10 && (h10 = n10);
          }
          return this.resolveDTLFormat(s10[n10]).main;
        }
      }, { isTouchDevice: tk } = L, { fireEvent: tM, merge: tw } = ti, tS = { colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"], symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { locale: void 0, loading: "Loading...", months: void 0, shortMonths: void 0, weekdays: void 0, numericSymbols: ["k", "M", "G", "T", "P", "E"], resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1" }, global: { buttonTheme: { fill: "#f7f7f7", padding: 8, r: 2, stroke: "#cccccc", "stroke-width": 1, style: { color: "#333333", cursor: "pointer", fontSize: "0.8em", fontWeight: "normal" }, states: { hover: { fill: "#e6e6e6" }, select: { fill: "#e6e9ff", style: { color: "#000000", fontWeight: "bold" } }, disabled: { style: { color: "#cccccc" } } } } }, time: { Date: void 0, timezone: "UTC", timezoneOffset: 0, useUTC: void 0 }, chart: { alignThresholds: false, panning: { enabled: false, type: "x" }, styledMode: false, borderRadius: 0, colorCount: 10, allowMutatingData: true, ignoreHiddenSeries: true, spacing: [10, 10, 15, 10], resetZoomButton: { theme: {}, position: {} }, reflow: true, type: "line", zooming: { singleTouch: false, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } }, width: null, height: null, borderColor: "#334eff", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" }, title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", margin: 15, minScale: 0.67 }, subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "" }, caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" }, plotOptions: {}, legend: { enabled: true, align: "center", alignColumns: true, className: "highcharts-no-tooltip", events: {}, layout: "horizontal", itemMarginBottom: 2, itemMarginTop: 2, labelFormatter: function() {
        return this.name;
      }, borderColor: "#999999", borderRadius: 0, navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" }, itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#666666", textDecoration: "line-through" }, shadow: false, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: true, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontSize: "0.8em", fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } }, tooltip: { enabled: true, animation: { duration: 300, easing: (t10) => Math.sqrt(1 - Math.pow(t10 - 1, 2)) }, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%[AebHMSL]", second: "%[AebHMS]", minute: "%[AebHM]", hour: "%[AebHM]", day: "%[AebY]", week: "Week from %[AebY]", month: "%[BY]", year: "%Y" }, footerFormat: "", headerShape: "callout", hideDelay: 500, padding: 8, shape: "callout", shared: false, snap: tk ? 25 : 10, headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>', pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>', backgroundColor: "#ffffff", borderWidth: void 0, shadow: true, stickOnContact: false, style: { color: "#333333", cursor: "default", fontSize: "0.8em" }, useHTML: false }, credits: { enabled: true, href: "https://www.highcharts.com?credits", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" }, text: "Highcharts.com" } }, tA = new tv(tS.time), tT = { defaultOptions: tS, defaultTime: tA, getOptions: function() {
        return tS;
      }, setOptions: function(t10) {
        return tM(L, "setOptions", { options: t10 }), tw(true, tS, t10), t10.time && tA.update(tS.time), t10.lang && "locale" in t10.lang && tA.update({ locale: t10.lang.locale }), tS;
      } }, { isNumber: tC, merge: tP, pInt: tO, defined: tE } = ti;
      class tL {
        static parse(t10) {
          return t10 ? new tL(t10) : tL.None;
        }
        constructor(t10) {
          let e10, i10, s10, o10;
          this.rgba = [NaN, NaN, NaN, NaN], this.input = t10;
          let r10 = L.Color;
          if (r10 && r10 !== tL) return new r10(t10);
          if ("object" == typeof t10 && void 0 !== t10.stops) this.stops = t10.stops.map((t11) => new tL(t11[1]));
          else if ("string" == typeof t10) for (this.input = t10 = tL.names[t10.toLowerCase()] || t10, s10 = tL.parsers.length; s10-- && !i10; ) (e10 = (o10 = tL.parsers[s10]).regex.exec(t10)) && (i10 = o10.parse(e10));
          i10 && (this.rgba = i10);
        }
        get(t10) {
          let e10 = this.input, i10 = this.rgba;
          if ("object" == typeof e10 && void 0 !== this.stops) {
            let i11 = tP(e10);
            return i11.stops = [].slice.call(i11.stops), this.stops.forEach((e11, s10) => {
              i11.stops[s10] = [i11.stops[s10][0], e11.get(t10)];
            }), i11;
          }
          return i10 && tC(i10[0]) ? "rgb" !== t10 && (t10 || 1 !== i10[3]) ? "a" === t10 ? `${i10[3]}` : "rgba(" + i10.join(",") + ")" : "rgb(" + i10[0] + "," + i10[1] + "," + i10[2] + ")" : e10;
        }
        brighten(t10) {
          let e10 = this.rgba;
          if (this.stops) this.stops.forEach(function(e11) {
            e11.brighten(t10);
          });
          else if (tC(t10) && 0 !== t10) for (let i10 = 0; i10 < 3; i10++) e10[i10] += tO(255 * t10), e10[i10] < 0 && (e10[i10] = 0), e10[i10] > 255 && (e10[i10] = 255);
          return this;
        }
        setOpacity(t10) {
          return this.rgba[3] = t10, this;
        }
        tweenTo(t10, e10) {
          let i10 = this.rgba, s10 = t10.rgba;
          if (!tC(i10[0]) || !tC(s10[0])) return t10.input || "none";
          let o10 = 1 !== s10[3] || 1 !== i10[3], r10 = (t11, s11) => t11 + (i10[s11] - t11) * (1 - e10), a10 = s10.slice(0, 3).map(r10).map(Math.round);
          return o10 && a10.push(r10(s10[3], 3)), (o10 ? "rgba(" : "rgb(") + a10.join(",") + ")";
        }
      }
      tL.names = { white: "#ffffff", black: "#000000" }, tL.parsers = [{ regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/, parse: function(t10) {
        return [tO(t10[1]), tO(t10[2]), tO(t10[3]), parseFloat(t10[4], 10)];
      } }, { regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/, parse: function(t10) {
        return [tO(t10[1]), tO(t10[2]), tO(t10[3]), 1];
      } }, { regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i, parse: function(t10) {
        return [tO(t10[1] + t10[1], 16), tO(t10[2] + t10[2], 16), tO(t10[3] + t10[3], 16), tE(t10[4]) ? tO(t10[4] + t10[4], 16) / 255 : 1];
      } }, { regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i, parse: function(t10) {
        return [tO(t10[1], 16), tO(t10[2], 16), tO(t10[3], 16), tE(t10[4]) ? tO(t10[4], 16) / 255 : 1];
      } }], tL.None = new tL("");
      let { parse: tD } = tL, { win: tB } = L, { isNumber: tI, objectEach: tz } = ti;
      class tR {
        constructor(t10, e10, i10) {
          this.pos = NaN, this.options = e10, this.elem = t10, this.prop = i10;
        }
        dSetter() {
          let t10 = this.paths, e10 = t10 && t10[0], i10 = t10 && t10[1], s10 = this.now || 0, o10 = [];
          if (1 !== s10 && e10 && i10) {
            if (e10.length === i10.length && s10 < 1) for (let t11 = 0; t11 < i10.length; t11++) {
              let r10 = e10[t11], a10 = i10[t11], n10 = [];
              for (let t12 = 0; t12 < a10.length; t12++) {
                let e11 = r10[t12], i11 = a10[t12];
                tI(e11) && tI(i11) && !("A" === a10[0] && (4 === t12 || 5 === t12)) ? n10[t12] = e11 + s10 * (i11 - e11) : n10[t12] = i11;
              }
              o10.push(n10);
            }
            else o10 = i10;
          } else o10 = this.toD || [];
          this.elem.attr("d", o10, void 0, true);
        }
        update() {
          let t10 = this.elem, e10 = this.prop, i10 = this.now, s10 = this.options.step;
          this[e10 + "Setter"] ? this[e10 + "Setter"]() : t10.attr ? t10.element && t10.attr(e10, i10, null, true) : t10.style[e10] = i10 + this.unit, s10 && s10.call(t10, i10, this);
        }
        run(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = function(t11) {
            return !r10.stopped && s10.step(t11);
          }, a10 = tB.requestAnimationFrame || function(t11) {
            setTimeout(t11, 13);
          }, n10 = function() {
            for (let t11 = 0; t11 < tR.timers.length; t11++) tR.timers[t11]() || tR.timers.splice(t11--, 1);
            tR.timers.length && a10(n10);
          };
          t10 !== e10 || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = t10, this.end = e10, this.unit = i10, this.now = this.start, this.pos = 0, r10.elem = this.elem, r10.prop = this.prop, r10() && 1 === tR.timers.push(r10) && a10(n10)) : (delete o10.curAnim[this.prop], o10.complete && 0 === Object.keys(o10.curAnim).length && o10.complete.call(this.elem));
        }
        step(t10) {
          let e10, i10;
          let s10 = +/* @__PURE__ */ new Date(), o10 = this.options, r10 = this.elem, a10 = o10.complete, n10 = o10.duration, h10 = o10.curAnim;
          return r10.attr && !r10.element ? e10 = false : t10 || s10 >= n10 + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), h10[this.prop] = true, i10 = true, tz(h10, function(t11) {
            true !== t11 && (i10 = false);
          }), i10 && a10 && a10.call(r10), e10 = false) : (this.pos = o10.easing((s10 - this.startTime) / n10), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e10 = true), e10;
        }
        initPath(t10, e10, i10) {
          let s10 = t10.startX, o10 = t10.endX, r10 = i10.slice(), a10 = t10.isArea, n10 = a10 ? 2 : 1, h10 = e10 && i10.length > e10.length && i10.hasStackedCliffs, l10, d10, c10, p10, u2 = e10 && e10.slice();
          if (!u2 || h10) return [r10, r10];
          function g2(t11, e11) {
            for (; t11.length < d10; ) {
              let i11 = t11[0], s11 = e11[d10 - t11.length];
              if (s11 && "M" === i11[0] && ("C" === s11[0] ? t11[0] = ["C", i11[1], i11[2], i11[1], i11[2], i11[1], i11[2]] : t11[0] = ["L", i11[1], i11[2]]), t11.unshift(i11), a10) {
                let e12 = t11.pop();
                t11.push(t11[t11.length - 1], e12);
              }
            }
          }
          function f2(t11) {
            for (; t11.length < d10; ) {
              let e11 = t11[Math.floor(t11.length / n10) - 1].slice();
              if ("C" === e11[0] && (e11[1] = e11[5], e11[2] = e11[6]), a10) {
                let i11 = t11[Math.floor(t11.length / n10)].slice();
                t11.splice(t11.length / 2, 0, e11, i11);
              } else t11.push(e11);
            }
          }
          if (s10 && o10 && o10.length) {
            for (c10 = 0; c10 < s10.length; c10++) {
              if (s10[c10] === o10[0]) {
                l10 = c10;
                break;
              }
              if (s10[0] === o10[o10.length - s10.length + c10]) {
                l10 = c10, p10 = true;
                break;
              }
              if (s10[s10.length - 1] === o10[o10.length - s10.length + c10]) {
                l10 = s10.length - c10;
                break;
              }
            }
            void 0 === l10 && (u2 = []);
          }
          return u2.length && tI(l10) && (d10 = r10.length + l10 * n10, p10 ? (g2(u2, r10), f2(r10)) : (g2(r10, u2), f2(u2))), [u2, r10];
        }
        fillSetter() {
          tR.prototype.strokeSetter.apply(this, arguments);
        }
        strokeSetter() {
          this.elem.attr(this.prop, tD(this.start).tweenTo(tD(this.end), this.pos), void 0, true);
        }
      }
      tR.timers = [];
      let { defined: tN, getStyle: tW, isArray: tG, isNumber: tX, isObject: tH, merge: tF, objectEach: tY, pick: tj } = ti;
      function tU(t10) {
        return tH(t10) ? tF({ duration: 500, defer: 0 }, t10) : { duration: t10 ? 500 : 0, defer: 0 };
      }
      function tV(t10, e10) {
        let i10 = tR.timers.length;
        for (; i10--; ) tR.timers[i10].elem !== t10 || e10 && e10 !== tR.timers[i10].prop || (tR.timers[i10].stopped = true);
      }
      let t_ = { animate: function(t10, e10, i10) {
        let s10, o10 = "", r10, a10, n10;
        tH(i10) || (n10 = arguments, i10 = { duration: n10[2], easing: n10[3], complete: n10[4] }), tX(i10.duration) || (i10.duration = 400), i10.easing = "function" == typeof i10.easing ? i10.easing : Math[i10.easing] || Math.easeInOutSine, i10.curAnim = tF(e10), tY(e10, function(n11, h10) {
          tV(t10, h10), a10 = new tR(t10, i10, h10), r10 = void 0, "d" === h10 && tG(e10.d) ? (a10.paths = a10.initPath(t10, t10.pathArray, e10.d), a10.toD = e10.d, s10 = 0, r10 = 1) : t10.attr ? s10 = t10.attr(h10) : (s10 = parseFloat(tW(t10, h10)) || 0, "opacity" !== h10 && (o10 = "px")), r10 || (r10 = n11), "string" == typeof r10 && r10.match("px") && (r10 = r10.replace(/px/g, "")), a10.run(s10, r10, o10);
        });
      }, animObject: tU, getDeferredAnimation: function(t10, e10, i10) {
        let s10 = tU(e10), o10 = i10 ? [i10] : t10.series, r10 = 0, a10 = 0;
        return o10.forEach((t11) => {
          let i11 = tU(t11.options.animation);
          r10 = tH(e10) && tN(e10.defer) ? s10.defer : Math.max(r10, i11.duration + i11.defer), a10 = Math.min(s10.duration, i11.duration);
        }), t10.renderer.forExport && (r10 = 0), { defer: Math.max(0, r10 - a10), duration: Math.min(r10, a10) };
      }, setAnimation: function(t10, e10) {
        e10.renderer.globalAnimation = tj(t10, e10.options.chart.animation, true);
      }, stop: tV }, { SVG_NS: t$, win: tZ } = L, { attr: tq, createElement: tK, css: tJ, error: tQ, isFunction: t0, isString: t1, objectEach: t2, splat: t3 } = ti, { trustedTypes: t5 } = tZ, t6 = t5 && t0(t5.createPolicy) && t5.createPolicy("highcharts", { createHTML: (t10) => t10 }), t9 = t6 ? t6.createHTML("") : "";
      class t4 {
        static filterUserAttributes(t10) {
          return t2(t10, (e10, i10) => {
            let s10 = true;
            -1 === t4.allowedAttributes.indexOf(i10) && (s10 = false), -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(i10) && (s10 = t1(e10) && t4.allowedReferences.some((t11) => 0 === e10.indexOf(t11))), s10 || (tQ(33, false, void 0, { "Invalid attribute in config": `${i10}` }), delete t10[i10]), t1(e10) && t10[i10] && (t10[i10] = e10.replace(/</g, "&lt;"));
          }), t10;
        }
        static parseStyle(t10) {
          return t10.split(";").reduce((t11, e10) => {
            let i10 = e10.split(":").map((t12) => t12.trim()), s10 = i10.shift();
            return s10 && i10.length && (t11[s10.replace(/-([a-z])/g, (t12) => t12[1].toUpperCase())] = i10.join(":")), t11;
          }, {});
        }
        static setElementHTML(t10, e10) {
          t10.innerHTML = t4.emptyHTML, e10 && new t4(e10).addToDOM(t10);
        }
        constructor(t10) {
          this.nodes = "string" == typeof t10 ? this.parseMarkup(t10) : t10;
        }
        addToDOM(t10) {
          return function t11(e10, i10) {
            let s10;
            return t3(e10).forEach(function(e11) {
              let o10;
              let r10 = e11.tagName, a10 = e11.textContent ? L.doc.createTextNode(e11.textContent) : void 0, n10 = t4.bypassHTMLFiltering;
              if (r10) {
                if ("#text" === r10) o10 = a10;
                else if (-1 !== t4.allowedTags.indexOf(r10) || n10) {
                  let s11 = "svg" === r10 ? t$ : i10.namespaceURI || t$, h10 = L.doc.createElementNS(s11, r10), l10 = e11.attributes || {};
                  t2(e11, function(t12, e12) {
                    "tagName" !== e12 && "attributes" !== e12 && "children" !== e12 && "style" !== e12 && "textContent" !== e12 && (l10[e12] = t12);
                  }), tq(h10, n10 ? l10 : t4.filterUserAttributes(l10)), e11.style && tJ(h10, e11.style), a10 && h10.appendChild(a10), t11(e11.children || [], h10), o10 = h10;
                } else tQ(33, false, void 0, { "Invalid tagName in config": r10 });
              }
              o10 && i10.appendChild(o10), s10 = o10;
            }), s10;
          }(this.nodes, t10);
        }
        parseMarkup(t10) {
          let e10;
          let i10 = [];
          t10 = t10.trim().replace(/ style=(["'])/g, " data-style=$1");
          try {
            e10 = new DOMParser().parseFromString(t6 ? t6.createHTML(t10) : t10, "text/html");
          } catch (t11) {
          }
          if (!e10) {
            let i11 = tK("div");
            i11.innerHTML = t10, e10 = { body: i11 };
          }
          let s10 = (t11, e11) => {
            let i11 = t11.nodeName.toLowerCase(), o10 = { tagName: i11 };
            "#text" === i11 && (o10.textContent = t11.textContent || "");
            let r10 = t11.attributes;
            if (r10) {
              let t12 = {};
              [].forEach.call(r10, (e12) => {
                "data-style" === e12.name ? o10.style = t4.parseStyle(e12.value) : t12[e12.name] = e12.value;
              }), o10.attributes = t12;
            }
            if (t11.childNodes.length) {
              let e12 = [];
              [].forEach.call(t11.childNodes, (t12) => {
                s10(t12, e12);
              }), e12.length && (o10.children = e12);
            }
            e11.push(o10);
          };
          return [].forEach.call(e10.body.childNodes, (t11) => s10(t11, i10)), i10;
        }
      }
      t4.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "in2", "markerHeight", "markerWidth", "offset", "opacity", "operator", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "radius", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], t4.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], t4.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feComposite", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMorphology", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], t4.emptyHTML = t9, t4.bypassHTMLFiltering = false;
      let { defaultOptions: t8, defaultTime: t7 } = tT, { pageLang: et } = L, { extend: ee, getNestedProperty: ei, isArray: es, isNumber: eo, isObject: er, isString: ea, pick: en, ucfirst: eh } = ti, el = { add: (t10, e10) => t10 + e10, divide: (t10, e10) => 0 !== e10 ? t10 / e10 : "", eq: (t10, e10) => t10 == e10, each: function(t10) {
        let e10 = arguments[arguments.length - 1];
        return !!es(t10) && t10.map((i10, s10) => ep(e10.body, ee(er(i10) ? i10 : { "@this": i10 }, { "@index": s10, "@first": 0 === s10, "@last": s10 === t10.length - 1 }))).join("");
      }, ge: (t10, e10) => t10 >= e10, gt: (t10, e10) => t10 > e10, if: (t10) => !!t10, le: (t10, e10) => t10 <= e10, lt: (t10, e10) => t10 < e10, multiply: (t10, e10) => t10 * e10, ne: (t10, e10) => t10 != e10, subtract: (t10, e10) => t10 - e10, ucfirst: eh, unless: (t10) => !t10 }, ed = {}, ec = (t10) => /^["'].+["']$/.test(t10);
      function ep(t10 = "", e10, i10) {
        let s10 = /\{([\p{L}\d:\.,;\-\/<>\[\]%_@+"'’= #\(\)]+)\}/gu, o10 = /\(([\p{L}\d:\.,;\-\/<>\[\]%_@+"'= ]+)\)/gu, r10 = [], a10 = /f$/, n10 = /\.(\d)/, h10 = (i10 == null ? void 0 : i10.options.lang) || t8.lang, l10 = i10 && i10.time || t7, d10 = i10 && i10.numberFormatter || eu, c10 = (t11 = "") => {
          let i11;
          return "true" === t11 || "false" !== t11 && ((i11 = Number(t11)).toString() === t11 ? i11 : ec(t11) ? t11.slice(1, -1) : ei(t11, e10));
        }, p10, u2, g2 = 0, f2;
        for (; null !== (p10 = s10.exec(t10)); ) {
          let i11 = p10, s11 = o10.exec(p10[1]);
          s11 && (p10 = s11, f2 = true), u2 && u2.isBlock || (u2 = { ctx: e10, expression: p10[1], find: p10[0], isBlock: "#" === p10[1].charAt(0), start: p10.index, startInner: p10.index + p10[0].length, length: p10[0].length });
          let a11 = (u2.isBlock ? i11 : p10)[1].split(" ")[0].replace("#", "");
          el[a11] && (u2.isBlock && a11 === u2.fn && g2++, u2.fn || (u2.fn = a11));
          let n11 = "else" === p10[1];
          if (u2.isBlock && u2.fn && (p10[1] === `/${u2.fn}` || n11)) {
            if (g2) !n11 && g2--;
            else {
              let e11 = u2.startInner, i12 = t10.substr(e11, p10.index - e11);
              void 0 === u2.body ? (u2.body = i12, u2.startInner = p10.index + p10[0].length) : u2.elseBody = i12, u2.find += i12 + p10[0], n11 || (r10.push(u2), u2 = void 0);
            }
          } else u2.isBlock || r10.push(u2);
          if (s11 && !(u2 == null ? void 0 : u2.isBlock)) break;
        }
        return r10.forEach((s11) => {
          let r11, p11;
          let { body: u3, elseBody: g3, expression: f3, fn: m2 } = s11;
          if (m2) {
            let t11 = [s11], o11 = [], a11 = f3.length, n11 = 0, h11;
            for (p11 = 0; p11 <= a11; p11++) {
              let t12 = f3.charAt(p11);
              h11 || '"' !== t12 && "'" !== t12 ? h11 === t12 && (h11 = "") : h11 = t12, h11 || " " !== t12 && p11 !== a11 || (o11.push(f3.substr(n11, p11 - n11)), n11 = p11 + 1);
            }
            for (p11 = el[m2].length; p11--; ) t11.unshift(c10(o11[p11 + 1]));
            r11 = el[m2].apply(e10, t11), s11.isBlock && "boolean" == typeof r11 && (r11 = ep(r11 ? u3 : g3, e10, i10));
          } else {
            let t11 = ec(f3) ? [f3] : f3.split(":");
            if (r11 = c10(t11.shift() || ""), t11.length && "number" == typeof r11) {
              let e11 = t11.join(":");
              if (a10.test(e11)) {
                let t12 = parseInt((e11.match(n10) || ["", "-1"])[1], 10);
                null !== r11 && (r11 = d10(r11, t12, h10.decimalPoint, e11.indexOf(",") > -1 ? h10.thousandsSep : ""));
              } else r11 = l10.dateFormat(e11, r11);
            }
            o10.lastIndex = 0, o10.test(s11.find) && ea(r11) && (r11 = `"${r11}"`);
          }
          t10 = t10.replace(s11.find, en(r11, ""));
        }), f2 ? ep(t10, e10, i10) : t10;
      }
      function eu(t10, e10, i10, s10) {
        var _a;
        e10 = +e10;
        let o10, r10, [a10, n10] = (t10 = +t10 || 0).toString().split("e").map(Number), h10 = ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.lang) || t8.lang, l10 = (t10.toString().split(".")[1] || "").split("e")[0].length, d10 = e10, c10 = {};
        i10 ?? (i10 = h10.decimalPoint), s10 ?? (s10 = h10.thousandsSep), -1 === e10 ? e10 = Math.min(l10, 20) : eo(e10) ? e10 && n10 < 0 && ((r10 = e10 + n10) >= 0 ? (a10 = +a10.toExponential(r10).split("e")[0], e10 = r10) : (a10 = Math.floor(a10), t10 = e10 < 20 ? +(a10 * Math.pow(10, n10)).toFixed(e10) : 0, n10 = 0)) : e10 = 2, n10 && (e10 ?? (e10 = 2), t10 = a10), eo(e10) && e10 >= 0 && (c10.minimumFractionDigits = e10, c10.maximumFractionDigits = e10), "" === s10 && (c10.useGrouping = false);
        let p10 = s10 || i10, u2 = p10 ? "en" : (this == null ? void 0 : this.locale) || h10.locale || et, g2 = JSON.stringify(c10) + u2;
        return o10 = (ed[g2] ?? (ed[g2] = new Intl.NumberFormat(u2, c10))).format(t10), p10 && (o10 = o10.replace(/([,\.])/g, "_$1").replace(/_\,/g, s10 ?? ",").replace("_.", i10 ?? ".")), (e10 || 0 != +o10) && (!(n10 < 0) || d10) || (o10 = "0"), n10 && 0 != +o10 && (o10 += "e" + (n10 < 0 ? "" : "+") + n10), o10;
      }
      let eg = { dateFormat: function(t10, e10, i10) {
        return t7.dateFormat(t10, e10, i10);
      }, format: ep, helpers: el, numberFormat: eu };
      !function(t10) {
        let e10;
        t10.rendererTypes = {}, t10.getRendererType = function(i10 = e10) {
          return t10.rendererTypes[i10] || t10.rendererTypes[e10];
        }, t10.registerRendererType = function(i10, s10, o10) {
          t10.rendererTypes[i10] = s10, (!e10 || o10) && (e10 = i10, L.Renderer = s10);
        };
      }(n || (n = {}));
      let ef = n, { clamp: em, pick: ex, pushUnique: ey, stableSort: eb } = ti;
      (h || (h = {})).distribute = function t10(e10, i10, s10) {
        let o10 = e10, r10 = o10.reducedLen || i10, a10 = (t11, e11) => t11.target - e11.target, n10 = [], h10 = e10.length, l10 = [], d10 = n10.push, c10, p10, u2, g2 = true, f2, m2, x2 = 0, y2;
        for (c10 = h10; c10--; ) x2 += e10[c10].size;
        if (x2 > r10) {
          for (eb(e10, (t11, e11) => (e11.rank || 0) - (t11.rank || 0)), u2 = (y2 = e10[0].rank === e10[e10.length - 1].rank) ? h10 / 2 : -1, p10 = y2 ? u2 : h10 - 1; u2 && x2 > r10; ) f2 = e10[c10 = Math.floor(p10)], ey(l10, c10) && (x2 -= f2.size), p10 += u2, y2 && p10 >= e10.length && (u2 /= 2, p10 = u2);
          l10.sort((t11, e11) => e11 - t11).forEach((t11) => d10.apply(n10, e10.splice(t11, 1)));
        }
        for (eb(e10, a10), e10 = e10.map((t11) => ({ size: t11.size, targets: [t11.target], align: ex(t11.align, 0.5) })); g2; ) {
          for (c10 = e10.length; c10--; ) f2 = e10[c10], m2 = (Math.min.apply(0, f2.targets) + Math.max.apply(0, f2.targets)) / 2, f2.pos = em(m2 - f2.size * f2.align, 0, i10 - f2.size);
          for (c10 = e10.length, g2 = false; c10--; ) c10 > 0 && e10[c10 - 1].pos + e10[c10 - 1].size > e10[c10].pos && (e10[c10 - 1].size += e10[c10].size, e10[c10 - 1].targets = e10[c10 - 1].targets.concat(e10[c10].targets), e10[c10 - 1].align = 0.5, e10[c10 - 1].pos + e10[c10 - 1].size > i10 && (e10[c10 - 1].pos = i10 - e10[c10 - 1].size), e10.splice(c10, 1), g2 = true);
        }
        return d10.apply(o10, n10), c10 = 0, e10.some((e11) => {
          let r11 = 0;
          return (e11.targets || []).some(() => (o10[c10].pos = e11.pos + r11, void 0 !== s10 && Math.abs(o10[c10].pos - o10[c10].target) > s10) ? (o10.slice(0, c10 + 1).forEach((t11) => delete t11.pos), o10.reducedLen = (o10.reducedLen || i10) - 0.1 * i10, o10.reducedLen > 0.1 * i10 && t10(o10, i10, s10), true) : (r11 += o10[c10].size, c10++, false));
        }), eb(o10, a10), o10;
      };
      let ev = h, { animate: ek, animObject: eM, stop: ew } = t_, { deg2rad: eS, doc: eA, svg: eT, SVG_NS: eC, win: eP, isFirefox: eO } = L, { addEvent: eE, attr: eL, createElement: eD, crisp: eB, css: eI, defined: ez, erase: eR, extend: eN, fireEvent: eW, getAlignFactor: eG, isArray: eX, isFunction: eH, isNumber: eF, isObject: eY, isString: ej, merge: eU, objectEach: eV, pick: e_, pInt: e$, pushUnique: eZ, replaceNested: eq, syncTimeout: eK, uniqueKey: eJ } = ti;
      class eQ {
        _defaultGetter(t10) {
          let e10 = e_(this[t10 + "Value"], this[t10], this.element ? this.element.getAttribute(t10) : null, 0);
          return /^-?[\d\.]+$/.test(e10) && (e10 = parseFloat(e10)), e10;
        }
        _defaultSetter(t10, e10, i10) {
          i10.setAttribute(e10, t10);
        }
        add(t10) {
          let e10;
          let i10 = this.renderer, s10 = this.element;
          return t10 && (this.parentGroup = t10), void 0 !== this.textStr && "text" === this.element.nodeName && i10.buildText(this), this.added = true, (!t10 || t10.handleZ || this.zIndex) && (e10 = this.zIndexSetter()), e10 || (t10 ? t10.element : i10.box).appendChild(s10), this.onAdd && this.onAdd(), this;
        }
        addClass(t10, e10) {
          let i10 = e10 ? "" : this.attr("class") || "";
          return (t10 = (t10 || "").split(/ /g).reduce(function(t11, e11) {
            return -1 === i10.indexOf(e11) && t11.push(e11), t11;
          }, i10 ? [i10] : []).join(" ")) !== i10 && this.attr("class", t10), this;
        }
        afterSetters() {
          this.doTransform && (this.updateTransform(), this.doTransform = false);
        }
        align(t10, e10, i10, s10 = true) {
          let o10 = this.renderer, r10 = o10.alignedObjects, a10 = !!t10;
          t10 ? (this.alignOptions = t10, this.alignByTranslate = e10, this.alignTo = i10) : (t10 = this.alignOptions || {}, e10 = this.alignByTranslate, i10 = this.alignTo);
          let n10 = !i10 || ej(i10) ? i10 || "renderer" : void 0;
          n10 && (a10 && eZ(r10, this), i10 = void 0);
          let h10 = e_(i10, o10[n10], o10), l10 = (h10.x || 0) + (t10.x || 0) + ((h10.width || 0) - (t10.width || 0)) * eG(t10.align), d10 = (h10.y || 0) + (t10.y || 0) + ((h10.height || 0) - (t10.height || 0)) * eG(t10.verticalAlign), c10 = { "text-align": t10 == null ? void 0 : t10.align };
          return c10[e10 ? "translateX" : "x"] = Math.round(l10), c10[e10 ? "translateY" : "y"] = Math.round(d10), s10 && (this[this.placed ? "animate" : "attr"](c10), this.placed = true), this.alignAttr = c10, this;
        }
        alignSetter(t10) {
          let e10 = { left: "start", center: "middle", right: "end" };
          e10[t10] && (this.alignValue = t10, this.element.setAttribute("text-anchor", e10[t10]));
        }
        animate(t10, e10, i10) {
          let s10 = eM(e_(e10, this.renderer.globalAnimation, true)), o10 = s10.defer;
          return eA.hidden && (s10.duration = 0), 0 !== s10.duration ? (i10 && (s10.complete = i10), eK(() => {
            this.element && ek(this, t10, s10);
          }, o10)) : (this.attr(t10, void 0, i10 || s10.complete), eV(t10, function(t11, e11) {
            s10.step && s10.step.call(this, t11, { prop: e11, pos: 1, elem: this });
          }, this)), this;
        }
        applyTextOutline(t10) {
          let e10 = this.element;
          -1 !== t10.indexOf("contrast") && (t10 = t10.replace(/contrast/g, this.renderer.getContrast(e10.style.fill)));
          let i10 = t10.split(" "), s10 = i10[i10.length - 1], o10 = i10[0];
          if (o10 && "none" !== o10 && L.svg) {
            this.fakeTS = true, o10 = o10.replace(/(^[\d\.]+)(.*?)$/g, function(t12, e11, i12) {
              return 2 * Number(e11) + i12;
            }), this.removeTextOutline();
            let t11 = eA.createElementNS(eC, "tspan");
            eL(t11, { class: "highcharts-text-outline", fill: s10, stroke: s10, "stroke-width": o10, "stroke-linejoin": "round" });
            let i11 = e10.querySelector("textPath") || e10;
            [].forEach.call(i11.childNodes, (e11) => {
              let i12 = e11.cloneNode(true);
              i12.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((t12) => i12.removeAttribute(t12)), t11.appendChild(i12);
            });
            let r10 = 0;
            [].forEach.call(i11.querySelectorAll("text tspan"), (t12) => {
              r10 += Number(t12.getAttribute("dy"));
            });
            let a10 = eA.createElementNS(eC, "tspan");
            a10.textContent = "​", eL(a10, { x: Number(e10.getAttribute("x")), dy: -r10 }), t11.appendChild(a10), i11.insertBefore(t11, i11.firstChild);
          }
        }
        attr(t10, e10, i10, s10) {
          let { element: o10 } = this, r10 = eQ.symbolCustomAttribs, a10, n10, h10 = this, l10;
          return "string" == typeof t10 && void 0 !== e10 && (a10 = t10, (t10 = {})[a10] = e10), "string" == typeof t10 ? h10 = (this[t10 + "Getter"] || this._defaultGetter).call(this, t10, o10) : (eV(t10, function(e11, i11) {
            l10 = false, s10 || ew(this, i11), this.symbolName && -1 !== r10.indexOf(i11) && (n10 || (this.symbolAttr(t10), n10 = true), l10 = true), this.rotation && ("x" === i11 || "y" === i11) && (this.doTransform = true), l10 || (this[i11 + "Setter"] || this._defaultSetter).call(this, e11, i11, o10);
          }, this), this.afterSetters()), i10 && i10.call(this), h10;
        }
        clip(t10) {
          if (t10 && !t10.clipPath) {
            let e10 = eJ() + "-", i10 = this.renderer.createElement("clipPath").attr({ id: e10 }).add(this.renderer.defs);
            eN(t10, { clipPath: i10, id: e10, count: 0 }), t10.add(i10);
          }
          return this.attr("clip-path", t10 ? `url(${this.renderer.url}#${t10.id})` : "none");
        }
        crisp(t10, e10) {
          e10 = Math.round(e10 || t10.strokeWidth || 0);
          let i10 = t10.x || this.x || 0, s10 = t10.y || this.y || 0, o10 = (t10.width || this.width || 0) + i10, r10 = (t10.height || this.height || 0) + s10, a10 = eB(i10, e10), n10 = eB(s10, e10);
          return eN(t10, { x: a10, y: n10, width: eB(o10, e10) - a10, height: eB(r10, e10) - n10 }), ez(t10.strokeWidth) && (t10.strokeWidth = e10), t10;
        }
        complexColor(t10, e10, i10) {
          let s10 = this.renderer, o10, r10, a10, n10, h10, l10, d10, c10, p10, u2, g2 = [], f2;
          eW(this.renderer, "complexColor", { args: arguments }, function() {
            if (t10.radialGradient ? r10 = "radialGradient" : t10.linearGradient && (r10 = "linearGradient"), r10) {
              if (a10 = t10[r10], h10 = s10.gradients, l10 = t10.stops, p10 = i10.radialReference, eX(a10) && (t10[r10] = a10 = { x1: a10[0], y1: a10[1], x2: a10[2], y2: a10[3], gradientUnits: "userSpaceOnUse" }), "radialGradient" === r10 && p10 && !ez(a10.gradientUnits) && (n10 = a10, a10 = eU(a10, s10.getRadialAttr(p10, n10), { gradientUnits: "userSpaceOnUse" })), eV(a10, function(t11, e11) {
                "id" !== e11 && g2.push(e11, t11);
              }), eV(l10, function(t11) {
                g2.push(t11);
              }), h10[g2 = g2.join(",")]) u2 = h10[g2].attr("id");
              else {
                a10.id = u2 = eJ();
                let t11 = h10[g2] = s10.createElement(r10).attr(a10).add(s10.defs);
                t11.radAttr = n10, t11.stops = [], l10.forEach(function(e11) {
                  0 === e11[1].indexOf("rgba") ? (d10 = (o10 = tL.parse(e11[1])).get("rgb"), c10 = o10.get("a")) : (d10 = e11[1], c10 = 1);
                  let i11 = s10.createElement("stop").attr({ offset: e11[0], "stop-color": d10, "stop-opacity": c10 }).add(t11);
                  t11.stops.push(i11);
                });
              }
              f2 = "url(" + s10.url + "#" + u2 + ")", i10.setAttribute(e10, f2), i10.gradient = g2, t10.toString = function() {
                return f2;
              };
            }
          });
        }
        css(t10) {
          let e10 = this.styles, i10 = {}, s10 = this.element, o10, r10 = !e10;
          if (e10 && eV(t10, function(t11, s11) {
            e10 && e10[s11] !== t11 && (i10[s11] = t11, r10 = true);
          }), r10) {
            e10 && (t10 = eN(e10, i10)), null === t10.width || "auto" === t10.width ? delete this.textWidth : "text" === s10.nodeName.toLowerCase() && t10.width && (o10 = this.textWidth = e$(t10.width)), eN(this.styles, t10), o10 && !eT && this.renderer.forExport && delete t10.width;
            let r11 = eO && t10.fontSize || null;
            r11 && (eF(r11) || /^\d+$/.test(r11)) && (t10.fontSize += "px");
            let a10 = eU(t10);
            s10.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "whiteSpace", "width"].forEach((t11) => a10 && delete a10[t11]), a10.color && (a10.fill = a10.color)), eI(s10, a10);
          }
          return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t10.textOutline && this.applyTextOutline(t10.textOutline)), this;
        }
        dashstyleSetter(t10) {
          let e10, i10 = this["stroke-width"];
          if ("inherit" === i10 && (i10 = 1), t10 = t10 && t10.toLowerCase()) {
            let s10 = t10.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
            for (e10 = s10.length; e10--; ) s10[e10] = "" + e$(s10[e10]) * e_(i10, NaN);
            t10 = s10.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t10);
          }
        }
        destroy() {
          var _a;
          let t10 = this, e10 = t10.element || {}, i10 = t10.renderer, s10 = e10.ownerSVGElement, o10 = "SPAN" === e10.nodeName && t10.parentGroup || void 0, r10, a10;
          if (e10.onclick = e10.onmouseout = e10.onmouseover = e10.onmousemove = e10.point = null, ew(t10), t10.clipPath && s10) {
            let e11 = t10.clipPath;
            [].forEach.call(s10.querySelectorAll("[clip-path],[CLIP-PATH]"), function(t11) {
              t11.getAttribute("clip-path").indexOf(e11.element.id) > -1 && t11.removeAttribute("clip-path");
            }), t10.clipPath = e11.destroy();
          }
          if (t10.connector = (_a = t10.connector) == null ? void 0 : _a.destroy(), t10.stops) {
            for (a10 = 0; a10 < t10.stops.length; a10++) t10.stops[a10].destroy();
            t10.stops.length = 0, t10.stops = void 0;
          }
          for (t10.safeRemoveChild(e10); o10 && o10.div && 0 === o10.div.childNodes.length; ) r10 = o10.parentGroup, t10.safeRemoveChild(o10.div), delete o10.div, o10 = r10;
          t10.alignOptions && eR(i10.alignedObjects, t10), eV(t10, function(e11, i11) {
            t10[i11] && t10[i11].parentGroup === t10 && t10[i11].destroy && t10[i11].destroy(), delete t10[i11];
          });
        }
        dSetter(t10, e10, i10) {
          eX(t10) && ("string" == typeof t10[0] && (t10 = this.renderer.pathToSegments(t10)), this.pathArray = t10, t10 = t10.reduce((t11, e11, i11) => e11 && e11.join ? (i11 ? t11 + " " : "") + e11.join(" ") : (e11 || "").toString(), "")), /(NaN| {2}|^$)/.test(t10) && (t10 = "M 0 0"), this[e10] !== t10 && (i10.setAttribute(e10, t10), this[e10] = t10);
        }
        fillSetter(t10, e10, i10) {
          "string" == typeof t10 ? i10.setAttribute(e10, t10) : t10 && this.complexColor(t10, e10, i10);
        }
        hrefSetter(t10, e10, i10) {
          i10.setAttributeNS("http://www.w3.org/1999/xlink", e10, t10);
        }
        getBBox(t10, e10) {
          let i10, s10, o10, r10;
          let { alignValue: a10, element: n10, renderer: h10, styles: l10, textStr: d10 } = this, { cache: c10, cacheKeys: p10 } = h10, u2 = n10.namespaceURI === this.SVG_NS, g2 = e_(e10, this.rotation, 0), f2 = h10.styledMode ? n10 && eQ.prototype.getStyle.call(n10, "font-size") : l10.fontSize;
          if (ez(d10) && (-1 === (r10 = d10.toString()).indexOf("<") && (r10 = r10.replace(/\d/g, "0")), r10 += ["", h10.rootFontSize, f2, g2, this.textWidth, a10, l10.lineClamp, l10.textOverflow, l10.fontWeight].join(",")), r10 && !t10 && (i10 = c10[r10]), !i10 || i10.polygon) {
            if (u2 || h10.forExport) {
              try {
                o10 = this.fakeTS && function(t12) {
                  let e11 = n10.querySelector(".highcharts-text-outline");
                  e11 && eI(e11, { display: t12 });
                }, eH(o10) && o10("none"), i10 = n10.getBBox ? eN({}, n10.getBBox()) : { width: n10.offsetWidth, height: n10.offsetHeight, x: 0, y: 0 }, eH(o10) && o10("");
              } catch (t12) {
              }
              (!i10 || i10.width < 0) && (i10 = { x: 0, y: 0, width: 0, height: 0 });
            } else i10 = this.htmlGetBBox();
            s10 = i10.height, u2 && (i10.height = s10 = { "11px,17": 14, "13px,20": 16 }[`${f2 || ""},${Math.round(s10)}`] || s10), g2 && (i10 = this.getRotatedBox(i10, g2));
            let t11 = { bBox: i10 };
            eW(this, "afterGetBBox", t11), i10 = t11.bBox;
          }
          if (r10 && ("" === d10 || i10.height > 0)) {
            for (; p10.length > 250; ) delete c10[p10.shift()];
            c10[r10] || p10.push(r10), c10[r10] = i10;
          }
          return i10;
        }
        getRotatedBox(t10, e10) {
          let { x: i10, y: s10, width: o10, height: r10 } = t10, { alignValue: a10, translateY: n10, rotationOriginX: h10 = 0, rotationOriginY: l10 = 0 } = this, d10 = eG(a10), c10 = Number(this.element.getAttribute("y") || 0) - (n10 ? 0 : s10), p10 = e10 * eS, u2 = (e10 - 90) * eS, g2 = Math.cos(p10), f2 = Math.sin(p10), m2 = o10 * g2, x2 = o10 * f2, y2 = Math.cos(u2), b2 = Math.sin(u2), [[v2, k2], [M2, w2]] = [h10, l10].map((t11) => [t11 - t11 * g2, t11 * f2]), S2 = i10 + d10 * (o10 - m2) + v2 + w2 + c10 * y2, A2 = S2 + m2, T2 = A2 - r10 * y2, C2 = T2 - m2, P2 = s10 + c10 - d10 * x2 - k2 + M2 + c10 * b2, O2 = P2 + x2, E2 = O2 - r10 * b2, L2 = E2 - x2, D2 = Math.min(S2, A2, T2, C2), B2 = Math.min(P2, O2, E2, L2), I2 = Math.max(S2, A2, T2, C2) - D2, z2 = Math.max(P2, O2, E2, L2) - B2;
          return { x: D2, y: B2, width: I2, height: z2, polygon: [[S2, P2], [A2, O2], [T2, E2], [C2, L2]] };
        }
        getStyle(t10) {
          return eP.getComputedStyle(this.element || this, "").getPropertyValue(t10);
        }
        hasClass(t10) {
          return -1 !== ("" + this.attr("class")).split(" ").indexOf(t10);
        }
        hide() {
          return this.attr({ visibility: "hidden" });
        }
        htmlGetBBox() {
          return { height: 0, width: 0, x: 0, y: 0 };
        }
        constructor(t10, e10) {
          this.onEvents = {}, this.opacity = 1, this.SVG_NS = eC, this.element = "span" === e10 || "body" === e10 ? eD(e10) : eA.createElementNS(this.SVG_NS, e10), this.renderer = t10, this.styles = {}, eW(this, "afterInit");
        }
        on(t10, e10) {
          let { onEvents: i10 } = this;
          return i10[t10] && i10[t10](), i10[t10] = eE(this.element, t10, e10), this;
        }
        opacitySetter(t10, e10, i10) {
          let s10 = Number(Number(t10).toFixed(3));
          this.opacity = s10, i10.setAttribute(e10, s10);
        }
        reAlign() {
          var _a;
          ((_a = this.alignOptions) == null ? void 0 : _a.width) && "left" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = false, this.align());
        }
        removeClass(t10) {
          return this.attr("class", ("" + this.attr("class")).replace(ej(t10) ? RegExp(`(^| )${t10}( |$)`) : t10, " ").replace(/ +/g, " ").trim());
        }
        removeTextOutline() {
          let t10 = this.element.querySelector("tspan.highcharts-text-outline");
          t10 && this.safeRemoveChild(t10);
        }
        safeRemoveChild(t10) {
          let e10 = t10.parentNode;
          e10 && e10.removeChild(t10);
        }
        setRadialReference(t10) {
          let e10 = this.element.gradient && this.renderer.gradients[this.element.gradient];
          return this.element.radialReference = t10, e10 && e10.radAttr && e10.animate(this.renderer.getRadialAttr(t10, e10.radAttr)), this;
        }
        shadow(t10) {
          var _a;
          let { renderer: e10 } = this, i10 = eU(((_a = this.parentGroup) == null ? void 0 : _a.rotation) === 90 ? { offsetX: -1, offsetY: -1 } : {}, eY(t10) ? t10 : {}), s10 = e10.shadowDefinition(i10);
          return this.attr({ filter: t10 ? `url(${e10.url}#${s10})` : "none" });
        }
        show(t10 = true) {
          return this.attr({ visibility: t10 ? "inherit" : "visible" });
        }
        "stroke-widthSetter"(t10, e10, i10) {
          this[e10] = t10, i10.setAttribute(e10, t10);
        }
        strokeWidth() {
          if (!this.renderer.styledMode) return this["stroke-width"] || 0;
          let t10 = this.getStyle("stroke-width"), e10 = 0, i10;
          return /px$/.test(t10) ? e10 = e$(t10) : "" !== t10 && (eL(i10 = eA.createElementNS(eC, "rect"), { width: t10, "stroke-width": 0 }), this.element.parentNode.appendChild(i10), e10 = i10.getBBox().width, i10.parentNode.removeChild(i10)), e10;
        }
        symbolAttr(t10) {
          let e10 = this;
          eQ.symbolCustomAttribs.forEach(function(i10) {
            e10[i10] = e_(t10[i10], e10[i10]);
          }), e10.attr({ d: e10.renderer.symbols[e10.symbolName](e10.x, e10.y, e10.width, e10.height, e10) });
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.textPxLength, this.textStr = t10, this.added && this.renderer.buildText(this), this.reAlign());
        }
        titleSetter(t10) {
          let e10 = this.element, i10 = e10.getElementsByTagName("title")[0] || eA.createElementNS(this.SVG_NS, "title");
          e10.insertBefore ? e10.insertBefore(i10, e10.firstChild) : e10.appendChild(i10), i10.textContent = eq(e_(t10, ""), [/<[^>]*>/g, ""]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        }
        toFront() {
          let t10 = this.element;
          return t10.parentNode.appendChild(t10), this;
        }
        translate(t10, e10) {
          return this.attr({ translateX: t10, translateY: e10 });
        }
        updateTransform(t10 = "transform") {
          var _a;
          let { element: e10, matrix: i10, rotation: s10 = 0, rotationOriginX: o10, rotationOriginY: r10, scaleX: a10, scaleY: n10, translateX: h10 = 0, translateY: l10 = 0 } = this, d10 = ["translate(" + h10 + "," + l10 + ")"];
          ez(i10) && d10.push("matrix(" + i10.join(",") + ")"), s10 && (d10.push("rotate(" + s10 + " " + e_(o10, e10.getAttribute("x"), 0) + " " + e_(r10, e10.getAttribute("y") || 0) + ")"), ((_a = this.text) == null ? void 0 : _a.element.tagName) === "SPAN" && this.text.attr({ rotation: s10, rotationOriginX: (o10 || 0) - this.padding, rotationOriginY: (r10 || 0) - this.padding })), (ez(a10) || ez(n10)) && d10.push("scale(" + e_(a10, 1) + " " + e_(n10, 1) + ")"), d10.length && !(this.text || this).textPath && e10.setAttribute(t10, d10.join(" "));
        }
        visibilitySetter(t10, e10, i10) {
          "inherit" === t10 ? i10.removeAttribute(e10) : this[e10] !== t10 && i10.setAttribute(e10, t10), this[e10] = t10;
        }
        xGetter(t10) {
          return "circle" === this.element.nodeName && ("x" === t10 ? t10 = "cx" : "y" === t10 && (t10 = "cy")), this._defaultGetter(t10);
        }
        zIndexSetter(t10, e10) {
          let i10 = this.renderer, s10 = this.parentGroup, o10 = (s10 || i10).element || i10.box, r10 = this.element, a10 = o10 === i10.box, n10, h10, l10, d10 = false, c10, p10 = this.added, u2;
          if (ez(t10) ? (r10.setAttribute("data-z-index", t10), t10 = +t10, this[e10] === t10 && (p10 = false)) : ez(this[e10]) && r10.removeAttribute("data-z-index"), this[e10] = t10, p10) {
            for ((t10 = this.zIndex) && s10 && (s10.handleZ = true), u2 = (n10 = o10.childNodes).length - 1; u2 >= 0 && !d10; u2--) c10 = !ez(l10 = (h10 = n10[u2]).getAttribute("data-z-index")), h10 !== r10 && (t10 < 0 && c10 && !a10 && !u2 ? (o10.insertBefore(r10, n10[u2]), d10 = true) : (e$(l10) <= t10 || c10 && (!ez(t10) || t10 >= 0)) && (o10.insertBefore(r10, n10[u2 + 1]), d10 = true));
            d10 || (o10.insertBefore(r10, n10[a10 ? 3 : 0]), d10 = true);
          }
          return d10;
        }
      }
      eQ.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], eQ.prototype.strokeSetter = eQ.prototype.fillSetter, eQ.prototype.yGetter = eQ.prototype.xGetter, eQ.prototype.matrixSetter = eQ.prototype.rotationOriginXSetter = eQ.prototype.rotationOriginYSetter = eQ.prototype.rotationSetter = eQ.prototype.scaleXSetter = eQ.prototype.scaleYSetter = eQ.prototype.translateXSetter = eQ.prototype.translateYSetter = eQ.prototype.verticalAlignSetter = function(t10, e10) {
        this[e10] = t10, this.doTransform = true;
      };
      let e0 = eQ, { defined: e1, extend: e2, getAlignFactor: e3, isNumber: e5, merge: e6, pick: e9, removeEvent: e4 } = ti;
      class e8 extends e0 {
        constructor(t10, e10, i10, s10, o10, r10, a10, n10, h10, l10) {
          let d10;
          super(t10, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = false, this.textStr = e10, this.x = i10, this.y = s10, this.anchorX = r10, this.anchorY = a10, this.baseline = h10, this.className = l10, this.addClass("button" === l10 ? "highcharts-no-tooltip" : "highcharts-label"), l10 && this.addClass("highcharts-" + l10), this.text = t10.text(void 0, 0, 0, n10).attr({ zIndex: 1 }), "string" == typeof o10 && ((d10 = /^url\((.*?)\)$/.test(o10)) || this.renderer.symbols[o10]) && (this.symbolKey = o10), this.bBox = e8.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t10.styledMode || d10, this.deferredAttr = {}, this.alignFactor = 0;
        }
        alignSetter(t10) {
          let e10 = e3(t10);
          this.textAlign = t10, e10 !== this.alignFactor && (this.alignFactor = e10, this.bBox && e5(this.xSetting) && this.attr({ x: this.xSetting }));
        }
        anchorXSetter(t10, e10) {
          this.anchorX = t10, this.boxAttr(e10, Math.round(t10) - this.getCrispAdjust() - this.xSetting);
        }
        anchorYSetter(t10, e10) {
          this.anchorY = t10, this.boxAttr(e10, t10 - this.ySetting);
        }
        boxAttr(t10, e10) {
          this.box ? this.box.attr(t10, e10) : this.deferredAttr[t10] = e10;
        }
        css(t10) {
          if (t10) {
            let e10 = {};
            t10 = e6(t10), e8.textProps.forEach((i10) => {
              void 0 !== t10[i10] && (e10[i10] = t10[i10], delete t10[i10]);
            }), this.text.css(e10), "fontSize" in e10 || "fontWeight" in e10 ? this.updateTextPadding() : ("width" in e10 || "textOverflow" in e10) && this.updateBoxSize();
          }
          return e0.prototype.css.call(this, t10);
        }
        destroy() {
          e4(this.element, "mouseenter"), e4(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), e0.prototype.destroy.call(this);
        }
        fillSetter(t10, e10) {
          t10 && (this.needsBox = true), this.fill = t10, this.boxAttr(e10, t10);
        }
        getBBox(t10, e10) {
          this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
          let { padding: i10, height: s10 = 0, translateX: o10 = 0, translateY: r10 = 0, width: a10 = 0 } = this, n10 = e9(this.paddingLeft, i10), h10 = e10 ?? (this.rotation || 0), l10 = { width: a10, height: s10, x: o10 + this.bBox.x - n10, y: r10 + this.bBox.y - i10 + this.baselineOffset };
          return h10 && (l10 = this.getRotatedBox(l10, h10)), l10;
        }
        getCrispAdjust() {
          return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
        }
        heightSetter(t10) {
          this.heightSetting = t10, this.doUpdate = true;
        }
        afterSetters() {
          super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = false);
        }
        onAdd() {
          this.text.add(this), this.attr({ text: e9(this.textStr, ""), x: this.x || 0, y: this.y || 0 }), this.box && e1(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
        }
        paddingSetter(t10, e10) {
          e5(t10) ? t10 !== this[e10] && (this[e10] = t10, this.updateTextPadding()) : this[e10] = void 0;
        }
        rSetter(t10, e10) {
          this.boxAttr(e10, t10);
        }
        strokeSetter(t10, e10) {
          this.stroke = t10, this.boxAttr(e10, t10);
        }
        "stroke-widthSetter"(t10, e10) {
          t10 && (this.needsBox = true), this["stroke-width"] = t10, this.boxAttr(e10, t10);
        }
        "text-alignSetter"(t10) {
          this.textAlign = this["text-align"] = t10, this.updateTextPadding();
        }
        textSetter(t10) {
          void 0 !== t10 && this.text.attr({ text: t10 }), this.updateTextPadding(), this.reAlign();
        }
        updateBoxSize() {
          let t10;
          let e10 = this.text, i10 = {}, s10 = this.padding, o10 = this.bBox = (!e5(this.widthSetting) || !e5(this.heightSetting) || this.textAlign) && e1(e10.textStr) ? e10.getBBox(void 0, 0) : e8.emptyBBox;
          this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o10.height || 0) + 2 * s10;
          let r10 = this.renderer.fontMetrics(e10);
          if (this.baselineOffset = s10 + Math.min((this.text.firstLineMetrics || r10).b, o10.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r10.h) / 2), this.needsBox && !e10.textPath) {
            if (!this.box) {
              let t11 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
              t11.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t11.add(this);
            }
            t10 = this.getCrispAdjust(), i10.x = t10, i10.y = (this.baseline ? -this.baselineOffset : 0) + t10, i10.width = Math.round(this.width), i10.height = Math.round(this.height), this.box.attr(e2(i10, this.deferredAttr)), this.deferredAttr = {};
          }
        }
        updateTextPadding() {
          let t10 = this.text, e10 = t10.styles.textAlign || this.textAlign;
          if (!t10.textPath) {
            this.updateBoxSize();
            let i10 = this.baseline ? 0 : this.baselineOffset, s10 = (this.paddingLeft ?? this.padding) + e3(e10) * (this.widthSetting ?? this.bBox.width);
            (s10 !== t10.x || i10 !== t10.y) && (t10.attr({ align: e10, x: s10 }), void 0 !== i10 && t10.attr("y", i10)), t10.x = s10, t10.y = i10;
          }
        }
        widthSetter(t10) {
          this.widthSetting = e5(t10) ? t10 : void 0, this.doUpdate = true;
        }
        getPaddedWidth() {
          let t10 = this.padding, e10 = e9(this.paddingLeft, t10), i10 = e9(this.paddingRight, t10);
          return (this.widthSetting || this.bBox.width || 0) + e10 + i10;
        }
        xSetter(t10) {
          this.x = t10, this.alignFactor && (t10 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true), this.xSetting = Math.round(t10), this.attr("translateX", this.xSetting);
        }
        ySetter(t10) {
          this.ySetting = this.y = Math.round(t10), this.attr("translateY", this.ySetting);
        }
      }
      e8.emptyBBox = { width: 0, height: 0, x: 0, y: 0 }, e8.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineClamp", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"];
      let { defined: e7, isNumber: it, pick: ie } = ti;
      function ii(t10, e10, i10, s10, o10) {
        let r10 = [];
        if (o10) {
          let a10 = o10.start || 0, n10 = ie(o10.r, i10), h10 = ie(o10.r, s10 || i10), l10 = 2e-4 / (o10.borderRadius ? 1 : Math.max(n10, 1)), d10 = Math.abs((o10.end || 0) - a10 - 2 * Math.PI) < l10, c10 = (o10.end || 0) - (d10 ? l10 : 0), p10 = o10.innerR, u2 = ie(o10.open, d10), g2 = Math.cos(a10), f2 = Math.sin(a10), m2 = Math.cos(c10), x2 = Math.sin(c10), y2 = ie(o10.longArc, c10 - a10 - Math.PI < l10 ? 0 : 1), b2 = ["A", n10, h10, 0, y2, ie(o10.clockwise, 1), t10 + n10 * m2, e10 + h10 * x2];
          b2.params = { start: a10, end: c10, cx: t10, cy: e10 }, r10.push(["M", t10 + n10 * g2, e10 + h10 * f2], b2), e7(p10) && ((b2 = ["A", p10, p10, 0, y2, e7(o10.clockwise) ? 1 - o10.clockwise : 0, t10 + p10 * g2, e10 + p10 * f2]).params = { start: c10, end: a10, cx: t10, cy: e10 }, r10.push(u2 ? ["M", t10 + p10 * m2, e10 + p10 * x2] : ["L", t10 + p10 * m2, e10 + p10 * x2], b2)), u2 || r10.push(["Z"]);
        }
        return r10;
      }
      function is(t10, e10, i10, s10, o10) {
        return o10 && o10.r ? io(t10, e10, i10, s10, o10) : [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
      }
      function io(t10, e10, i10, s10, o10) {
        let r10 = (o10 == null ? void 0 : o10.r) || 0;
        return [["M", t10 + r10, e10], ["L", t10 + i10 - r10, e10], ["A", r10, r10, 0, 0, 1, t10 + i10, e10 + r10], ["L", t10 + i10, e10 + s10 - r10], ["A", r10, r10, 0, 0, 1, t10 + i10 - r10, e10 + s10], ["L", t10 + r10, e10 + s10], ["A", r10, r10, 0, 0, 1, t10, e10 + s10 - r10], ["L", t10, e10 + r10], ["A", r10, r10, 0, 0, 1, t10 + r10, e10], ["Z"]];
      }
      let ir = { arc: ii, callout: function(t10, e10, i10, s10, o10) {
        let r10 = Math.min(o10 && o10.r || 0, i10, s10), a10 = r10 + 6, n10 = o10 && o10.anchorX, h10 = o10 && o10.anchorY || 0, l10 = io(t10, e10, i10, s10, { r: r10 });
        if (!it(n10) || n10 < i10 && n10 > 0 && h10 < s10 && h10 > 0) return l10;
        if (t10 + n10 > i10 - a10) {
          if (h10 > e10 + a10 && h10 < e10 + s10 - a10) l10.splice(3, 1, ["L", t10 + i10, h10 - 6], ["L", t10 + i10 + 6, h10], ["L", t10 + i10, h10 + 6], ["L", t10 + i10, e10 + s10 - r10]);
          else if (n10 < i10) {
            let o11 = h10 < e10 + a10, d10 = o11 ? e10 : e10 + s10;
            l10.splice(o11 ? 2 : 5, 0, ["L", n10, h10], ["L", t10 + i10 - r10, d10]);
          } else l10.splice(3, 1, ["L", t10 + i10, s10 / 2], ["L", n10, h10], ["L", t10 + i10, s10 / 2], ["L", t10 + i10, e10 + s10 - r10]);
        } else if (t10 + n10 < a10) {
          if (h10 > e10 + a10 && h10 < e10 + s10 - a10) l10.splice(7, 1, ["L", t10, h10 + 6], ["L", t10 - 6, h10], ["L", t10, h10 - 6], ["L", t10, e10 + r10]);
          else if (n10 > 0) {
            let i11 = h10 < e10 + a10, o11 = i11 ? e10 : e10 + s10;
            l10.splice(i11 ? 1 : 6, 0, ["L", n10, h10], ["L", t10 + r10, o11]);
          } else l10.splice(7, 1, ["L", t10, s10 / 2], ["L", n10, h10], ["L", t10, s10 / 2], ["L", t10, e10 + r10]);
        } else h10 > s10 && n10 < i10 - a10 ? l10.splice(5, 1, ["L", n10 + 6, e10 + s10], ["L", n10, e10 + s10 + 6], ["L", n10 - 6, e10 + s10], ["L", t10 + r10, e10 + s10]) : h10 < 0 && n10 > a10 && l10.splice(1, 1, ["L", n10 - 6, e10], ["L", n10, e10 - 6], ["L", n10 + 6, e10], ["L", i10 - r10, e10]);
        return l10;
      }, circle: function(t10, e10, i10, s10) {
        return ii(t10 + i10 / 2, e10 + s10 / 2, i10 / 2, s10 / 2, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: false });
      }, diamond: function(t10, e10, i10, s10) {
        return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10 / 2], ["L", t10 + i10 / 2, e10 + s10], ["L", t10, e10 + s10 / 2], ["Z"]];
      }, rect: is, roundedRect: io, square: is, triangle: function(t10, e10, i10, s10) {
        return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
      }, "triangle-down": function(t10, e10, i10, s10) {
        return [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10 / 2, e10 + s10], ["Z"]];
      } }, { doc: ia, SVG_NS: ih, win: il } = L, { attr: id, extend: ic, fireEvent: ip, isString: iu, objectEach: ig, pick: im } = ti, ix = (t10, e10) => t10.substring(0, e10) + "…", iy = class {
        constructor(t10) {
          let e10 = t10.styles;
          this.renderer = t10.renderer, this.svgElement = t10, this.width = t10.textWidth, this.textLineHeight = e10 && e10.lineHeight, this.textOutline = e10 && e10.textOutline, this.ellipsis = !!(e10 && "ellipsis" === e10.textOverflow), this.lineClamp = e10 == null ? void 0 : e10.lineClamp, this.noWrap = !!(e10 && "nowrap" === e10.whiteSpace);
        }
        buildSVG() {
          let t10 = this.svgElement, e10 = t10.element, i10 = t10.renderer, s10 = im(t10.textStr, "").toString(), o10 = -1 !== s10.indexOf("<"), r10 = e10.childNodes, a10 = !t10.added && i10.box, n10 = [s10, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, t10.getStyle("font-size"), t10.styles.lineClamp, this.width].join(",");
          if (n10 !== t10.textCache) {
            t10.textCache = n10, delete t10.actualWidth;
            for (let t11 = r10.length; t11--; ) e10.removeChild(r10[t11]);
            if (o10 || this.ellipsis || this.width || t10.textPath || -1 !== s10.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(s10))) {
              if ("" !== s10) {
                a10 && a10.appendChild(e10);
                let i11 = new t4(s10);
                this.modifyTree(i11.nodes), i11.addToDOM(e10), this.modifyDOM(), this.ellipsis && -1 !== (e10.textContent || "").indexOf("…") && t10.attr("title", this.unescapeEntities(t10.textStr || "", ["&lt;", "&gt;"])), a10 && a10.removeChild(e10);
              }
            } else e10.appendChild(ia.createTextNode(this.unescapeEntities(s10)));
            iu(this.textOutline) && t10.applyTextOutline && t10.applyTextOutline(this.textOutline);
          }
        }
        modifyDOM() {
          let t10;
          let e10 = this.svgElement, i10 = id(e10.element, "x");
          for (e10.firstLineMetrics = void 0; t10 = e10.element.firstChild; ) if (/^[\s\u200B]*$/.test(t10.textContent || " ")) e10.element.removeChild(t10);
          else break;
          [].forEach.call(e10.element.querySelectorAll("tspan.highcharts-br"), (t11, s11) => {
            t11.nextSibling && t11.previousSibling && (0 === s11 && 1 === t11.previousSibling.nodeType && (e10.firstLineMetrics = e10.renderer.fontMetrics(t11.previousSibling)), id(t11, { dy: this.getLineHeight(t11.nextSibling), x: i10 }));
          });
          let s10 = this.width || 0;
          if (!s10) return;
          let o10 = (t11, o11) => {
            var _a;
            let r11 = t11.textContent || "", a10 = r11.replace(/([^\^])-/g, "$1- ").split(" "), n10 = !this.noWrap && (a10.length > 1 || e10.element.childNodes.length > 1), h10 = this.getLineHeight(o11), l10 = Math.max(0, s10 - 0.8 * h10), d10 = 0, c10 = e10.actualWidth;
            if (n10) {
              let r12 = [], n11 = [];
              for (; o11.firstChild && o11.firstChild !== t11; ) n11.push(o11.firstChild), o11.removeChild(o11.firstChild);
              for (; a10.length; ) if (a10.length && !this.noWrap && d10 > 0 && (r12.push(t11.textContent || ""), t11.textContent = a10.join(" ").replace(/- /g, "-")), this.truncate(t11, void 0, a10, 0 === d10 && c10 || 0, s10, l10, (t12, e11) => a10.slice(0, e11).join(" ").replace(/- /g, "-")), c10 = e10.actualWidth, d10++, this.lineClamp && d10 >= this.lineClamp) {
                a10.length && (this.truncate(t11, t11.textContent || "", void 0, 0, s10, l10, ix), t11.textContent = ((_a = t11.textContent) == null ? void 0 : _a.replace("…", "")) + "…");
                break;
              }
              n11.forEach((e11) => {
                o11.insertBefore(e11, t11);
              }), r12.forEach((e11) => {
                o11.insertBefore(ia.createTextNode(e11), t11);
                let s11 = ia.createElementNS(ih, "tspan");
                s11.textContent = "​", id(s11, { dy: h10, x: i10 }), o11.insertBefore(s11, t11);
              });
            } else this.ellipsis && r11 && this.truncate(t11, r11, void 0, 0, s10, l10, ix);
          }, r10 = (t11) => {
            [].slice.call(t11.childNodes).forEach((i11) => {
              i11.nodeType === il.Node.TEXT_NODE ? o10(i11, t11) : (-1 !== i11.className.baseVal.indexOf("highcharts-br") && (e10.actualWidth = 0), r10(i11));
            });
          };
          r10(e10.element);
        }
        getLineHeight(t10) {
          let e10 = t10.nodeType === il.Node.TEXT_NODE ? t10.parentElement : t10;
          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e10 || this.svgElement.element).h;
        }
        modifyTree(t10) {
          let e10 = (i10, s10) => {
            let { attributes: o10 = {}, children: r10, style: a10 = {}, tagName: n10 } = i10, h10 = this.renderer.styledMode;
            if ("b" === n10 || "strong" === n10 ? h10 ? o10.class = "highcharts-strong" : a10.fontWeight = "bold" : ("i" === n10 || "em" === n10) && (h10 ? o10.class = "highcharts-emphasized" : a10.fontStyle = "italic"), a10 && a10.color && (a10.fill = a10.color), "br" === n10) {
              o10.class = "highcharts-br", i10.textContent = "​";
              let e11 = t10[s10 + 1];
              e11 && e11.textContent && (e11.textContent = e11.textContent.replace(/^ +/gm, ""));
            } else "a" === n10 && r10 && r10.some((t11) => "#text" === t11.tagName) && (i10.children = [{ children: r10, tagName: "tspan" }]);
            "#text" !== n10 && "a" !== n10 && (i10.tagName = "tspan"), ic(i10, { attributes: o10, style: a10 }), r10 && r10.filter((t11) => "#text" !== t11.tagName).forEach(e10);
          };
          t10.forEach(e10), ip(this.svgElement, "afterModifyTree", { nodes: t10 });
        }
        truncate(t10, e10, i10, s10, o10, r10, a10) {
          let n10, h10;
          let l10 = this.svgElement, { rotation: d10 } = l10, c10 = [], p10 = i10 && !s10 ? 1 : 0, u2 = (e10 || i10 || "").length, g2 = u2;
          i10 || (o10 = r10);
          let f2 = function(e11, o11) {
            let r11 = o11 || e11, a11 = t10.parentNode;
            if (a11 && void 0 === c10[r11] && a11.getSubStringLength) try {
              c10[r11] = s10 + a11.getSubStringLength(0, i10 ? r11 + 1 : r11);
            } catch (t11) {
            }
            return c10[r11];
          };
          if (l10.rotation = 0, s10 + (h10 = f2(t10.textContent.length)) > o10) {
            for (; p10 <= u2; ) g2 = Math.ceil((p10 + u2) / 2), i10 && (n10 = a10(i10, g2)), h10 = f2(g2, n10 && n10.length - 1), p10 === u2 ? p10 = u2 + 1 : h10 > o10 ? u2 = g2 - 1 : p10 = g2;
            0 === u2 ? t10.textContent = "" : e10 && u2 === e10.length - 1 || (t10.textContent = n10 || a10(e10 || i10, g2)), this.ellipsis && h10 > o10 && this.truncate(t10, t10.textContent || "", void 0, 0, o10, r10, ix);
          }
          i10 && i10.splice(0, g2), l10.actualWidth = h10, l10.rotation = d10;
        }
        unescapeEntities(t10, e10) {
          return ig(this.renderer.escapes, function(i10, s10) {
            e10 && -1 !== e10.indexOf(i10) || (t10 = t10.toString().replace(RegExp(i10, "g"), s10));
          }), t10;
        }
      }, { defaultOptions: ib } = tT, { charts: iv, deg2rad: ik, doc: iM, isFirefox: iw, isMS: iS, isWebKit: iA, noop: iT, SVG_NS: iC, symbolSizes: iP, win: iO } = L, { addEvent: iE, attr: iL, createElement: iD, crisp: iB, css: iI, defined: iz, destroyObjectProperties: iR, extend: iN, isArray: iW, isNumber: iG, isObject: iX, isString: iH, merge: iF, pick: iY, pInt: ij, replaceNested: iU, uniqueKey: iV } = ti;
      class i_ {
        constructor(t10, e10, i10, s10, o10, r10, a10) {
          let n10, h10;
          let l10 = this.createElement("svg").attr({ version: "1.1", class: "highcharts-root" }), d10 = l10.element;
          a10 || l10.css(this.getStyle(s10 || {})), t10.appendChild(d10), iL(t10, "dir", "ltr"), -1 === t10.innerHTML.indexOf("xmlns") && iL(d10, "xmlns", this.SVG_NS), this.box = d10, this.boxWrapper = l10, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(iM.createTextNode("Created with Highcharts 12.1.2")), this.defs = this.createElement("defs").add(), this.allowHTML = r10, this.forExport = o10, this.styledMode = a10, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l10.getStyle("font-size"), this.setSize(e10, i10, false), iw && t10.getBoundingClientRect && ((n10 = function() {
            iI(t10, { left: 0, top: 0 }), h10 = t10.getBoundingClientRect(), iI(t10, { left: Math.ceil(h10.left) - h10.left + "px", top: Math.ceil(h10.top) - h10.top + "px" });
          })(), this.unSubPixelFix = iE(iO, "resize", n10));
        }
        definition(t10) {
          return new t4([t10]).addToDOM(this.defs.element);
        }
        getReferenceURL() {
          if ((iw || iA) && iM.getElementsByTagName("base").length) {
            if (!iz(e)) {
              let t10 = iV(), i10 = new t4([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{ tagName: "defs", children: [{ tagName: "clipPath", attributes: { id: t10 }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }] }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${t10})`, fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(iM.body);
              iI(i10, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
              let s10 = iM.elementFromPoint(6, 6);
              e = "hitme" === (s10 && s10.id), iM.body.removeChild(i10);
            }
            if (e) return iU(iO.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]);
          }
          return "";
        }
        getStyle(t10) {
          return this.style = iN({ fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif', fontSize: "1rem" }, t10), this.style;
        }
        setStyle(t10) {
          this.boxWrapper.css(this.getStyle(t10));
        }
        isHidden() {
          return !this.boxWrapper.getBBox().width;
        }
        destroy() {
          let t10 = this.defs;
          return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), iR(this.gradients || {}), this.gradients = null, this.defs = t10.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
        }
        createElement(t10) {
          return new this.Element(this, t10);
        }
        getRadialAttr(t10, e10) {
          return { cx: t10[0] - t10[2] / 2 + (e10.cx || 0) * t10[2], cy: t10[1] - t10[2] / 2 + (e10.cy || 0) * t10[2], r: (e10.r || 0) * t10[2] };
        }
        shadowDefinition(t10) {
          let e10 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t10).map((e11) => `${e11}-${t10[e11]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i10 = iF({ color: "#000000", offsetX: 1, offsetY: 1, opacity: 0.15, width: 5 }, t10);
          return this.defs.element.querySelector(`#${e10}`) || this.definition({ tagName: "filter", attributes: { id: e10, filterUnits: i10.filterUnits }, children: this.getShadowFilterContent(i10) }), e10;
        }
        getShadowFilterContent(t10) {
          return [{ tagName: "feDropShadow", attributes: { dx: t10.offsetX, dy: t10.offsetY, "flood-color": t10.color, "flood-opacity": Math.min(5 * t10.opacity, 1), stdDeviation: t10.width / 2 } }];
        }
        buildText(t10) {
          new iy(t10).buildSVG();
        }
        getContrast(t10) {
          let e10 = tL.parse(t10).rgba.map((t11) => {
            let e11 = t11 / 255;
            return e11 <= 0.03928 ? e11 / 12.92 : Math.pow((e11 + 0.055) / 1.055, 2.4);
          }), i10 = 0.2126 * e10[0] + 0.7152 * e10[1] + 0.0722 * e10[2];
          return 1.05 / (i10 + 0.05) > (i10 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
        }
        button(t10, e10, i10, s10, o10 = {}, r10, a10, n10, h10, l10) {
          let d10 = this.label(t10, e10, i10, h10, void 0, void 0, l10, void 0, "button"), c10 = this.styledMode, p10 = arguments, u2 = 0;
          o10 = iF(ib.global.buttonTheme, o10), c10 && (delete o10.fill, delete o10.stroke, delete o10["stroke-width"]);
          let g2 = o10.states || {}, f2 = o10.style || {};
          delete o10.states, delete o10.style;
          let m2 = [t4.filterUserAttributes(o10)], x2 = [f2];
          return c10 || ["hover", "select", "disabled"].forEach((t11, e11) => {
            m2.push(iF(m2[0], t4.filterUserAttributes(p10[e11 + 5] || g2[t11] || {}))), x2.push(m2[e11 + 1].style), delete m2[e11 + 1].style;
          }), iE(d10.element, iS ? "mouseover" : "mouseenter", function() {
            3 !== u2 && d10.setState(1);
          }), iE(d10.element, iS ? "mouseout" : "mouseleave", function() {
            3 !== u2 && d10.setState(u2);
          }), d10.setState = (t11 = 0) => {
            if (1 !== t11 && (d10.state = u2 = t11), d10.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t11]), !c10) {
              d10.attr(m2[t11]);
              let e11 = x2[t11];
              iX(e11) && d10.css(e11);
            }
          }, d10.attr(m2[0]), !c10 && (d10.css(iN({ cursor: "default" }, f2)), l10 && d10.text.css({ pointerEvents: "none" })), d10.on("touchstart", (t11) => t11.stopPropagation()).on("click", function(t11) {
            3 !== u2 && s10.call(d10, t11);
          });
        }
        crispLine(t10, e10) {
          let [i10, s10] = t10;
          return iz(i10[1]) && i10[1] === s10[1] && (i10[1] = s10[1] = iB(i10[1], e10)), iz(i10[2]) && i10[2] === s10[2] && (i10[2] = s10[2] = iB(i10[2], e10)), t10;
        }
        path(t10) {
          let e10 = this.styledMode ? {} : { fill: "none" };
          return iW(t10) ? e10.d = t10 : iX(t10) && iN(e10, t10), this.createElement("path").attr(e10);
        }
        circle(t10, e10, i10) {
          let s10 = iX(t10) ? t10 : void 0 === t10 ? {} : { x: t10, y: e10, r: i10 }, o10 = this.createElement("circle");
          return o10.xSetter = o10.ySetter = function(t11, e11, i11) {
            i11.setAttribute("c" + e11, t11);
          }, o10.attr(s10);
        }
        arc(t10, e10, i10, s10, o10, r10) {
          let a10;
          iX(t10) ? (e10 = (a10 = t10).y, i10 = a10.r, s10 = a10.innerR, o10 = a10.start, r10 = a10.end, t10 = a10.x) : a10 = { innerR: s10, start: o10, end: r10 };
          let n10 = this.symbol("arc", t10, e10, i10, i10, a10);
          return n10.r = i10, n10;
        }
        rect(t10, e10, i10, s10, o10, r10) {
          let a10 = iX(t10) ? t10 : void 0 === t10 ? {} : { x: t10, y: e10, r: o10, width: Math.max(i10 || 0, 0), height: Math.max(s10 || 0, 0) }, n10 = this.createElement("rect");
          return this.styledMode || (void 0 !== r10 && (a10["stroke-width"] = r10, iN(a10, n10.crisp(a10))), a10.fill = "none"), n10.rSetter = function(t11, e11, i11) {
            n10.r = t11, iL(i11, { rx: t11, ry: t11 });
          }, n10.rGetter = function() {
            return n10.r || 0;
          }, n10.attr(a10);
        }
        roundedRect(t10) {
          return this.symbol("roundedRect").attr(t10);
        }
        setSize(t10, e10, i10) {
          this.width = t10, this.height = e10, this.boxWrapper.animate({ width: t10, height: e10 }, { step: function() {
            this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
          }, duration: iY(i10, true) ? void 0 : 0 }), this.alignElements();
        }
        g(t10) {
          let e10 = this.createElement("g");
          return t10 ? e10.attr({ class: "highcharts-" + t10 }) : e10;
        }
        image(t10, e10, i10, s10, o10, r10) {
          let a10 = { preserveAspectRatio: "none" };
          iG(e10) && (a10.x = e10), iG(i10) && (a10.y = i10), iG(s10) && (a10.width = s10), iG(o10) && (a10.height = o10);
          let n10 = this.createElement("image").attr(a10), h10 = function(e11) {
            n10.attr({ href: t10 }), r10.call(n10, e11);
          };
          if (r10) {
            n10.attr({ href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" });
            let e11 = new iO.Image();
            iE(e11, "load", h10), e11.src = t10, e11.complete && h10({});
          } else n10.attr({ href: t10 });
          return n10;
        }
        symbol(t10, e10, i10, s10, o10, r10) {
          let a10, n10, h10, l10;
          let d10 = this, c10 = /^url\((.*?)\)$/, p10 = c10.test(t10), u2 = !p10 && (this.symbols[t10] ? t10 : "circle"), g2 = u2 && this.symbols[u2];
          if (g2) "number" == typeof e10 && (n10 = g2.call(this.symbols, e10 || 0, i10 || 0, s10 || 0, o10 || 0, r10)), a10 = this.path(n10), d10.styledMode || a10.attr("fill", "none"), iN(a10, { symbolName: u2 || void 0, x: e10, y: i10, width: s10, height: o10 }), r10 && iN(a10, r10);
          else if (p10) {
            h10 = t10.match(c10)[1];
            let s11 = a10 = this.image(h10);
            s11.imgwidth = iY(r10 && r10.width, iP[h10] && iP[h10].width), s11.imgheight = iY(r10 && r10.height, iP[h10] && iP[h10].height), l10 = (t11) => t11.attr({ width: t11.width, height: t11.height }), ["width", "height"].forEach((t11) => {
              s11[`${t11}Setter`] = function(t12, e11) {
                this[e11] = t12;
                let { alignByTranslate: i11, element: s12, width: o11, height: a11, imgwidth: n11, imgheight: h11 } = this, l11 = "width" === e11 ? n11 : h11, d11 = 1;
                r10 && "within" === r10.backgroundSize && o11 && a11 && n11 && h11 ? (d11 = Math.min(o11 / n11, a11 / h11), iL(s12, { width: Math.round(n11 * d11), height: Math.round(h11 * d11) })) : s12 && l11 && s12.setAttribute(e11, l11), !i11 && n11 && h11 && this.translate(((o11 || 0) - n11 * d11) / 2, ((a11 || 0) - h11 * d11) / 2);
              };
            }), iz(e10) && s11.attr({ x: e10, y: i10 }), s11.isImg = true, s11.symbolUrl = t10, iz(s11.imgwidth) && iz(s11.imgheight) ? l10(s11) : (s11.attr({ width: 0, height: 0 }), iD("img", { onload: function() {
              let t11 = iv[d10.chartIndex];
              0 === this.width && (iI(this, { position: "absolute", top: "-999em" }), iM.body.appendChild(this)), iP[h10] = { width: this.width, height: this.height }, s11.imgwidth = this.width, s11.imgheight = this.height, s11.element && l10(s11), this.parentNode && this.parentNode.removeChild(this), d10.imgCount--, d10.imgCount || !t11 || t11.hasLoaded || t11.onload();
            }, src: h10 }), this.imgCount++);
          }
          return a10;
        }
        clipRect(t10, e10, i10, s10) {
          return this.rect(t10, e10, i10, s10, 0);
        }
        text(t10, e10, i10, s10) {
          let o10 = {};
          if (s10 && (this.allowHTML || !this.forExport)) return this.html(t10, e10, i10);
          o10.x = Math.round(e10 || 0), i10 && (o10.y = Math.round(i10)), iz(t10) && (o10.text = t10);
          let r10 = this.createElement("text").attr(o10);
          return s10 && (!this.forExport || this.allowHTML) || (r10.xSetter = function(t11, e11, i11) {
            let s11 = i11.getElementsByTagName("tspan"), o11 = i11.getAttribute(e11);
            for (let i12 = 0, r11; i12 < s11.length; i12++) (r11 = s11[i12]).getAttribute(e11) === o11 && r11.setAttribute(e11, t11);
            i11.setAttribute(e11, t11);
          }), r10;
        }
        fontMetrics(t10) {
          let e10 = ij(e0.prototype.getStyle.call(t10, "font-size") || 0), i10 = e10 < 24 ? e10 + 3 : Math.round(1.2 * e10), s10 = Math.round(0.8 * i10);
          return { h: i10, b: s10, f: e10 };
        }
        rotCorr(t10, e10, i10) {
          let s10 = t10;
          return e10 && i10 && (s10 = Math.max(s10 * Math.cos(e10 * ik), 4)), { x: -t10 / 3 * Math.sin(e10 * ik), y: s10 };
        }
        pathToSegments(t10) {
          let e10 = [], i10 = [], s10 = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
          for (let o10 = 0; o10 < t10.length; o10++) iH(i10[0]) && iG(t10[o10]) && i10.length === s10[i10[0].toUpperCase()] && t10.splice(o10, 0, i10[0].replace("M", "L").replace("m", "l")), "string" == typeof t10[o10] && (i10.length && e10.push(i10.slice(0)), i10.length = 0), i10.push(t10[o10]);
          return e10.push(i10.slice(0)), e10;
        }
        label(t10, e10, i10, s10, o10, r10, a10, n10, h10) {
          return new e8(this, t10, e10, i10, s10, o10, r10, a10, n10, h10);
        }
        alignElements() {
          this.alignedObjects.forEach((t10) => t10.align());
        }
      }
      iN(i_.prototype, { Element: e0, SVG_NS: iC, escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, symbols: ir, draw: iT }), ef.registerRendererType("svg", i_, true);
      let { composed: i$ } = L, { attr: iZ, css: iq, createElement: iK, defined: iJ, extend: iQ, getAlignFactor: i0, isNumber: i1, pInt: i2, pushUnique: i3 } = ti;
      function i5(t10, e10, i10) {
        var _a;
        let s10 = ((_a = this.div) == null ? void 0 : _a.style) || i10.style;
        e0.prototype[`${e10}Setter`].call(this, t10, e10, i10), s10 && (s10[e10] = t10);
      }
      let i6 = (t10, e10) => {
        var _a;
        if (!t10.div) {
          let i10 = iZ(t10.element, "class"), s10 = t10.css, o10 = iK("div", i10 ? { className: i10 } : void 0, { position: "absolute", left: `${t10.translateX || 0}px`, top: `${t10.translateY || 0}px`, ...t10.styles, display: t10.display, opacity: t10.opacity, visibility: t10.visibility }, ((_a = t10.parentGroup) == null ? void 0 : _a.div) || e10);
          t10.classSetter = (t11, e11, i11) => {
            i11.setAttribute("class", t11), o10.className = t11;
          }, t10.translateXSetter = t10.translateYSetter = (e11, i11) => {
            t10[i11] = e11, o10.style["translateX" === i11 ? "left" : "top"] = `${e11}px`, t10.doTransform = true;
          }, t10.opacitySetter = t10.visibilitySetter = i5, t10.css = (e11) => (s10.call(t10, e11), e11.cursor && (o10.style.cursor = e11.cursor), e11.pointerEvents && (o10.style.pointerEvents = e11.pointerEvents), t10), t10.on = function() {
            return e0.prototype.on.apply({ element: o10, onEvents: t10.onEvents }, arguments), t10;
          }, t10.div = o10;
        }
        return t10.div;
      };
      class i9 extends e0 {
        static compose(t10) {
          i3(i$, this.compose) && (t10.prototype.html = function(t11, e10, i10) {
            return new i9(this, "span").attr({ text: t11, x: Math.round(e10), y: Math.round(i10) });
          });
        }
        constructor(t10, e10) {
          super(t10, e10), this.css({ position: "absolute", ...t10.styledMode ? {} : { fontFamily: t10.style.fontFamily, fontSize: t10.style.fontSize } });
        }
        getSpanCorrection(t10, e10, i10) {
          this.xCorr = -t10 * i10, this.yCorr = -e10;
        }
        css(t10) {
          let e10;
          let { element: i10 } = this, s10 = "SPAN" === i10.tagName && t10 && "width" in t10, o10 = s10 && t10.width;
          return s10 && (delete t10.width, this.textWidth = i2(o10) || void 0, e10 = true), (t10 == null ? void 0 : t10.textOverflow) === "ellipsis" && (t10.overflow = "hidden"), (t10 == null ? void 0 : t10.lineClamp) && (t10.display = "-webkit-box", t10.WebkitLineClamp = t10.lineClamp, t10.WebkitBoxOrient = "vertical", t10.overflow = "hidden"), i1(Number(t10 == null ? void 0 : t10.fontSize)) && (t10.fontSize = t10.fontSize + "px"), iQ(this.styles, t10), iq(i10, t10), e10 && this.updateTransform(), this;
        }
        htmlGetBBox() {
          let { element: t10 } = this;
          return { x: t10.offsetLeft, y: t10.offsetTop, width: t10.offsetWidth, height: t10.offsetHeight };
        }
        updateTransform() {
          var _a;
          if (!this.added) {
            this.alignOnAdd = true;
            return;
          }
          let { element: t10, renderer: e10, rotation: i10, rotationOriginX: s10, rotationOriginY: o10, scaleX: r10, scaleY: a10, styles: n10, textAlign: h10 = "left", textWidth: l10, translateX: d10 = 0, translateY: c10 = 0, x: p10 = 0, y: u2 = 0 } = this, { display: g2 = "block", whiteSpace: f2 } = n10;
          if (iq(t10, { marginLeft: `${d10}px`, marginTop: `${c10}px` }), "SPAN" === t10.tagName) {
            let n11;
            let d11 = [i10, h10, t10.innerHTML, l10, this.textAlign].join(","), c11 = -(((_a = this.parentGroup) == null ? void 0 : _a.padding) * 1) || 0;
            if (l10 !== this.oldTextWidth) {
              let e11 = this.textPxLength ? this.textPxLength : (iq(t10, { width: "", whiteSpace: f2 || "nowrap" }), t10.offsetWidth), s11 = l10 || 0;
              (s11 > this.oldTextWidth || e11 > s11) && (/[ \-]/.test(t10.textContent || t10.innerText) || "ellipsis" === t10.style.textOverflow) && (iq(t10, { width: e11 > s11 || i10 || r10 ? l10 + "px" : "auto", display: g2, whiteSpace: f2 || "normal" }), this.oldTextWidth = l10);
            }
            d11 !== this.cTT && (n11 = e10.fontMetrics(t10).b, iJ(i10) && (i10 !== (this.oldRotation || 0) || h10 !== this.oldAlign) && this.setSpanRotation(i10, c11, c11), this.getSpanCorrection(!iJ(i10) && !this.textWidth && this.textPxLength || t10.offsetWidth, n11, i0(h10)));
            let { xCorr: m2 = 0, yCorr: x2 = 0 } = this, y2 = { left: `${p10 + m2}px`, top: `${u2 + x2}px`, textAlign: h10, transformOrigin: `${(s10 ?? p10) - m2 - p10 - c11}px ${(o10 ?? u2) - x2 - u2 - c11}px` };
            (r10 || a10) && (y2.transform = `scale(${r10 ?? 1},${a10 ?? 1})`), iq(t10, y2), this.cTT = d11, this.oldRotation = i10, this.oldAlign = h10;
          }
        }
        setSpanRotation(t10, e10, i10) {
          iq(this.element, { transform: `rotate(${t10}deg)`, transformOrigin: `${e10}% ${i10}px` });
        }
        add(t10) {
          let e10;
          let i10 = this.renderer.box.parentNode, s10 = [];
          if (this.parentGroup = t10, t10 && !(e10 = t10.div)) {
            let o10 = t10;
            for (; o10; ) s10.push(o10), o10 = o10.parentGroup;
            for (let t11 of s10.reverse()) e10 = i6(t11, i10);
          }
          return (e10 || i10).appendChild(this.element), this.added = true, this.alignOnAdd && this.updateTransform(), this;
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t4.setElementHTML(this.element, t10 ?? ""), this.textStr = t10, this.doTransform = true);
        }
        alignSetter(t10) {
          this.alignValue = this.textAlign = t10, this.doTransform = true;
        }
        xSetter(t10, e10) {
          this[e10] = t10, this.doTransform = true;
        }
      }
      let i4 = i9.prototype;
      i4.visibilitySetter = i4.opacitySetter = i5, i4.ySetter = i4.rotationSetter = i4.rotationOriginXSetter = i4.rotationOriginYSetter = i4.xSetter, function(t10) {
        t10.xAxis = { alignTicks: true, allowDecimals: void 0, panningEnabled: true, zIndex: 2, zoomEnabled: true, dateTimeLabelFormats: { millisecond: { main: "%[HMSL]", range: false }, second: { main: "%[HMS]", range: false }, minute: { main: "%[HM]", range: false }, hour: { main: "%[HM]", range: false }, day: { main: "%[eb]" }, week: { main: "%[eb]" }, month: { main: "%[bY]" }, year: { main: "%Y" } }, endOnTick: false, gridLineDashStyle: "Solid", gridZIndex: 1, labels: { autoRotationLimit: 80, distance: 15, enabled: true, indentation: 10, overflow: "justify", reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: false, zIndex: 7, style: { color: "#333333", cursor: "default", fontSize: "0.8em", textOverflow: "ellipsis" } }, maxPadding: 0.01, minorGridLineDashStyle: "Solid", minorTickLength: 2, minorTickPosition: "outside", minorTicksPerMajor: 5, minPadding: 0.01, offset: void 0, reversed: void 0, reversedStacks: false, showEmpty: true, showFirstLabel: true, showLastLabel: true, startOfWeek: 1, startOnTick: false, tickLength: 10, tickPixelInterval: 100, tickmarkPlacement: "between", tickPosition: "outside", title: { align: "middle", useHTML: false, x: 0, y: 0, style: { color: "#666666", fontSize: "0.8em" } }, visible: true, minorGridLineColor: "#f2f2f2", minorGridLineWidth: 1, minorTickColor: "#999999", lineColor: "#333333", lineWidth: 1, gridLineColor: "#e6e6e6", gridLineWidth: void 0, tickColor: "#333333" }, t10.yAxis = { reversedStacks: true, endOnTick: true, maxPadding: 0.05, minPadding: 0.05, tickPixelInterval: 72, showLastLabel: true, labels: { x: void 0 }, startOnTick: true, title: { text: "Values" }, stackLabels: { animation: {}, allowOverlap: false, enabled: false, crop: true, overflow: "justify", formatter: function() {
          let { numberFormatter: t11 } = this.axis.chart;
          return t11(this.total || 0, -1);
        }, style: { color: "#000000", fontSize: "0.7em", fontWeight: "bold", textOutline: "1px contrast" } }, gridLineWidth: 1, lineWidth: 0 };
      }(l || (l = {}));
      let i8 = l, { addEvent: i7, isFunction: st, objectEach: se, removeEvent: si } = ti;
      (d || (d = {})).registerEventOptions = function(t10, e10) {
        t10.eventOptions = t10.eventOptions || {}, se(e10.events, function(e11, i10) {
          t10.eventOptions[i10] !== e11 && (t10.eventOptions[i10] && (si(t10, i10, t10.eventOptions[i10]), delete t10.eventOptions[i10]), st(e11) && (t10.eventOptions[i10] = e11, i7(t10, i10, e11, { order: 0 })));
        });
      };
      let ss = d, { deg2rad: so } = L, { clamp: sr, correctFloat: sa, defined: sn, destroyObjectProperties: sh, extend: sl, fireEvent: sd, getAlignFactor: sc, isNumber: sp, merge: su, objectEach: sg, pick: sf } = ti, sm = class {
        constructor(t10, e10, i10, s10, o10) {
          this.isNew = true, this.isNewLabel = true, this.axis = t10, this.pos = e10, this.type = i10 || "", this.parameters = o10 || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, sd(this, "init"), i10 || s10 || this.addLabel();
        }
        addLabel() {
          let t10 = this, e10 = t10.axis, i10 = e10.options, s10 = e10.chart, o10 = e10.categories, r10 = e10.logarithmic, a10 = e10.names, n10 = t10.pos, h10 = sf(t10.options && t10.options.labels, i10.labels), l10 = e10.tickPositions, d10 = n10 === l10[0], c10 = n10 === l10[l10.length - 1], p10 = (!h10.step || 1 === h10.step) && 1 === e10.tickInterval, u2 = l10.info, g2 = t10.label, f2, m2, x2, y2 = this.parameters.category || (o10 ? sf(o10[n10], a10[n10], n10) : n10);
          r10 && sp(y2) && (y2 = sa(r10.lin2log(y2))), e10.dateTime && (u2 ? f2 = (m2 = s10.time.resolveDTLFormat(i10.dateTimeLabelFormats[!i10.grid && u2.higherRanks[n10] || u2.unitName])).main : sp(y2) && (f2 = e10.dateTime.getXDateFormat(y2, i10.dateTimeLabelFormats || {}))), t10.isFirst = d10, t10.isLast = c10;
          let b2 = { axis: e10, chart: s10, dateTimeLabelFormat: f2, isFirst: d10, isLast: c10, pos: n10, tick: t10, tickPositionInfo: u2, value: y2 };
          sd(this, "labelFormat", b2);
          let v2 = (t11) => h10.formatter ? h10.formatter.call(t11, t11) : h10.format ? (t11.text = e10.defaultLabelFormatter.call(t11), eg.format(h10.format, t11, s10)) : e10.defaultLabelFormatter.call(t11), k2 = v2.call(b2, b2), M2 = m2 && m2.list;
          M2 ? t10.shortenLabel = function() {
            for (x2 = 0; x2 < M2.length; x2++) if (sl(b2, { dateTimeLabelFormat: M2[x2] }), g2.attr({ text: v2.call(b2, b2) }), g2.getBBox().width < e10.getSlotWidth(t10) - 2 * (h10.padding || 0)) return;
            g2.attr({ text: "" });
          } : t10.shortenLabel = void 0, p10 && e10._addedPlotLB && t10.moveLabel(k2, h10), sn(g2) || t10.movedLabel ? g2 && g2.textStr !== k2 && !p10 && (!g2.textWidth || h10.style.width || g2.styles.width || g2.css({ width: null }), g2.attr({ text: k2 }), g2.textPxLength = g2.getBBox().width) : (t10.label = g2 = t10.createLabel(k2, h10), t10.rotation = 0);
        }
        createLabel(t10, e10, i10) {
          let s10 = this.axis, { renderer: o10, styledMode: r10 } = s10.chart, a10 = sn(t10) && e10.enabled ? o10.text(t10, i10 == null ? void 0 : i10.x, i10 == null ? void 0 : i10.y, e10.useHTML).add(s10.labelGroup) : void 0;
          if (a10) {
            let t11 = e10.style.whiteSpace || "normal";
            r10 || a10.css(su(e10.style, { whiteSpace: "nowrap" })), a10.textPxLength = a10.getBBox().width, r10 || a10.css({ whiteSpace: t11 });
          }
          return a10;
        }
        destroy() {
          sh(this, this.axis);
        }
        getPosition(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart, a10 = s10 && r10.oldChartHeight || r10.chartHeight, n10 = { x: t10 ? sa(o10.translate(e10 + i10, void 0, void 0, s10) + o10.transB) : o10.left + o10.offset + (o10.opposite ? (s10 && r10.oldChartWidth || r10.chartWidth) - o10.right - o10.left : 0), y: t10 ? a10 - o10.bottom + o10.offset - (o10.opposite ? o10.height : 0) : sa(a10 - o10.translate(e10 + i10, void 0, void 0, s10) - o10.transB) };
          return n10.y = sr(n10.y, -1e9, 1e9), sd(this, "afterGetPosition", { pos: n10 }), n10;
        }
        getLabelPosition(t10, e10, i10, s10, o10, r10, a10, n10) {
          let h10, l10;
          let d10 = this.axis, c10 = d10.transA, p10 = d10.isLinked && d10.linkedParent ? d10.linkedParent.reversed : d10.reversed, u2 = d10.staggerLines, g2 = d10.tickRotCorr || { x: 0, y: 0 }, f2 = s10 || d10.reserveSpaceDefault ? 0 : -d10.labelOffset * ("center" === d10.labelAlign ? 0.5 : 1), m2 = o10.distance, x2 = {};
          return h10 = 0 === d10.side ? i10.rotation ? -m2 : -i10.getBBox().height : 2 === d10.side ? g2.y + m2 : Math.cos(i10.rotation * so) * (g2.y - i10.getBBox(false, 0).height / 2), sn(o10.y) && (h10 = 0 === d10.side && d10.horiz ? o10.y + h10 : o10.y), t10 = t10 + sf(o10.x, [0, 1, 0, -1][d10.side] * m2) + f2 + g2.x - (r10 && s10 ? r10 * c10 * (p10 ? -1 : 1) : 0), e10 = e10 + h10 - (r10 && !s10 ? r10 * c10 * (p10 ? 1 : -1) : 0), u2 && (l10 = a10 / (n10 || 1) % u2, d10.opposite && (l10 = u2 - l10 - 1), e10 += l10 * (d10.labelOffset / u2)), x2.x = t10, x2.y = Math.round(e10), sd(this, "afterGetLabelPosition", { pos: x2, tickmarkOffset: r10, index: a10 }), x2;
        }
        getLabelSize() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        }
        getMarkPath(t10, e10, i10, s10, o10 = false, r10) {
          return r10.crispLine([["M", t10, e10], ["L", t10 + (o10 ? 0 : -i10), e10 + (o10 ? i10 : 0)]], s10);
        }
        handleOverflow(t10) {
          let e10 = this.axis, i10 = e10.options.labels, s10 = t10.x, o10 = e10.chart.chartWidth, r10 = e10.chart.spacing, a10 = sf(e10.labelLeft, Math.min(e10.pos, r10[3])), n10 = sf(e10.labelRight, Math.max(e10.isRadial ? 0 : e10.pos + e10.len, o10 - r10[1])), h10 = this.label, l10 = this.rotation, d10 = sc(e10.labelAlign || h10.attr("align")), c10 = h10.getBBox().width, p10 = e10.getSlotWidth(this), u2 = p10, g2 = 1, f2, m2, x2;
          l10 || "justify" !== i10.overflow ? l10 < 0 && s10 - d10 * c10 < a10 ? x2 = Math.round(s10 / Math.cos(l10 * so) - a10) : l10 > 0 && s10 + d10 * c10 > n10 && (x2 = Math.round((o10 - s10) / Math.cos(l10 * so))) : (f2 = s10 - d10 * c10, m2 = s10 + (1 - d10) * c10, f2 < a10 ? u2 = t10.x + u2 * (1 - d10) - a10 : m2 > n10 && (u2 = n10 - t10.x + u2 * d10, g2 = -1), (u2 = Math.min(p10, u2)) < p10 && "center" === e10.labelAlign && (t10.x += g2 * (p10 - u2 - d10 * (p10 - Math.min(c10, u2)))), (c10 > u2 || e10.autoRotation && (h10.styles || {}).width) && (x2 = u2)), x2 && h10 && (this.shortenLabel ? this.shortenLabel() : h10.css(sl({}, { width: Math.floor(x2) + "px", lineClamp: e10.isRadial ? 0 : 1 })));
        }
        moveLabel(t10, e10) {
          let i10 = this, s10 = i10.label, o10 = i10.axis, r10 = false, a10;
          s10 && s10.textStr === t10 ? (i10.movedLabel = s10, r10 = true, delete i10.label) : sg(o10.ticks, function(e11) {
            r10 || e11.isNew || e11 === i10 || !e11.label || e11.label.textStr !== t10 || (i10.movedLabel = e11.label, r10 = true, e11.labelPos = i10.movedLabel.xy, delete e11.label);
          }), !r10 && (i10.labelPos || s10) && (a10 = i10.labelPos || s10.xy, i10.movedLabel = i10.createLabel(t10, e10, a10), i10.movedLabel && i10.movedLabel.attr({ opacity: 0 }));
        }
        render(t10, e10, i10) {
          let s10 = this.axis, o10 = s10.horiz, r10 = this.pos, a10 = sf(this.tickmarkOffset, s10.tickmarkOffset), n10 = this.getPosition(o10, r10, a10, e10), h10 = n10.x, l10 = n10.y, d10 = s10.pos, c10 = d10 + s10.len, p10 = o10 ? h10 : l10;
          !s10.chart.polar && this.isNew && (sa(p10) < d10 || p10 > c10) && (i10 = 0);
          let u2 = sf(i10, this.label && this.label.newOpacity, 1);
          i10 = sf(i10, 1), this.isActive = true, this.renderGridLine(e10, i10), this.renderMark(n10, i10), this.renderLabel(n10, e10, u2, t10), this.isNew = false, sd(this, "afterRender");
        }
        renderGridLine(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = {}, r10 = this.pos, a10 = this.type, n10 = sf(this.tickmarkOffset, i10.tickmarkOffset), h10 = i10.chart.renderer, l10 = this.gridLine, d10, c10 = s10.gridLineWidth, p10 = s10.gridLineColor, u2 = s10.gridLineDashStyle;
          "minor" === this.type && (c10 = s10.minorGridLineWidth, p10 = s10.minorGridLineColor, u2 = s10.minorGridLineDashStyle), l10 || (i10.chart.styledMode || (o10.stroke = p10, o10["stroke-width"] = c10 || 0, o10.dashstyle = u2), a10 || (o10.zIndex = 1), t10 && (e10 = 0), this.gridLine = l10 = h10.path().attr(o10).addClass("highcharts-" + (a10 ? a10 + "-" : "") + "grid-line").add(i10.gridGroup)), l10 && (d10 = i10.getPlotLinePath({ value: r10 + n10, lineWidth: l10.strokeWidth(), force: "pass", old: t10, acrossPanes: false })) && l10[t10 || this.isNew ? "attr" : "animate"]({ d: d10, opacity: e10 });
        }
        renderMark(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = i10.chart.renderer, r10 = this.type, a10 = i10.tickSize(r10 ? r10 + "Tick" : "tick"), n10 = t10.x, h10 = t10.y, l10 = sf(s10["minor" !== r10 ? "tickWidth" : "minorTickWidth"], !r10 && i10.isXAxis ? 1 : 0), d10 = s10["minor" !== r10 ? "tickColor" : "minorTickColor"], c10 = this.mark, p10 = !c10;
          a10 && (i10.opposite && (a10[0] = -a10[0]), c10 || (this.mark = c10 = o10.path().addClass("highcharts-" + (r10 ? r10 + "-" : "") + "tick").add(i10.axisGroup), i10.chart.styledMode || c10.attr({ stroke: d10, "stroke-width": l10 })), c10[p10 ? "attr" : "animate"]({ d: this.getMarkPath(n10, h10, a10[0], c10.strokeWidth(), i10.horiz, o10), opacity: e10 }));
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.horiz, a10 = o10.options, n10 = this.label, h10 = a10.labels, l10 = h10.step, d10 = sf(this.tickmarkOffset, o10.tickmarkOffset), c10 = t10.x, p10 = t10.y, u2 = true;
          n10 && sp(c10) && (n10.xy = t10 = this.getLabelPosition(c10, p10, n10, r10, h10, d10, s10, l10), (!this.isFirst || this.isLast || a10.showFirstLabel) && (!this.isLast || this.isFirst || a10.showLastLabel) ? !r10 || h10.step || h10.rotation || e10 || 0 === i10 || this.handleOverflow(t10) : u2 = false, l10 && s10 % l10 && (u2 = false), u2 && sp(t10.y) ? (t10.opacity = i10, n10[this.isNewLabel ? "attr" : "animate"](t10).show(true), this.isNewLabel = false) : (n10.hide(), this.isNewLabel = true));
        }
        replaceMovedLabel() {
          let t10 = this.label, e10 = this.axis;
          t10 && !this.isNew && (t10.animate({ opacity: 0 }, void 0, t10.destroy), delete this.label), e10.isDirty = true, this.label = this.movedLabel, delete this.movedLabel;
        }
      }, { animObject: sx } = t_, { xAxis: sy, yAxis: sb } = i8, { defaultOptions: sv } = tT, { registerEventOptions: sk } = ss, { deg2rad: sM } = L, { arrayMax: sw, arrayMin: sS, clamp: sA, correctFloat: sT, defined: sC, destroyObjectProperties: sP, erase: sO, error: sE, extend: sL, fireEvent: sD, getClosestDistance: sB, insertItem: sI, isArray: sz, isNumber: sR, isString: sN, merge: sW, normalizeTickInterval: sG, objectEach: sX, pick: sH, relativeLength: sF, removeEvent: sY, splat: sj, syncTimeout: sU } = ti, sV = (t10, e10) => sG(e10, void 0, void 0, sH(t10.options.allowDecimals, e10 < 0.5 || void 0 !== t10.tickAmount), !!t10.tickAmount);
      sL(sv, { xAxis: sy, yAxis: sW(sy, sb) });
      class s_ {
        constructor(t10, e10, i10) {
          this.init(t10, e10, i10);
        }
        init(t10, e10, i10 = this.coll) {
          let s10 = "xAxis" === i10, o10 = this.isZAxis || (t10.inverted ? !s10 : s10);
          this.chart = t10, this.horiz = o10, this.isXAxis = s10, this.coll = i10, sD(this, "init", { userOptions: e10 }), this.opposite = sH(e10.opposite, this.opposite), this.side = sH(e10.side, this.side, o10 ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e10);
          let r10 = this.options, a10 = r10.labels;
          this.type ?? (this.type = r10.type || "linear"), this.uniqueNames ?? (this.uniqueNames = r10.uniqueNames ?? true), sD(this, "afterSetType"), this.userOptions = e10, this.minPixelPadding = 0, this.reversed = sH(r10.reversed, this.reversed), this.visible = r10.visible, this.zoomEnabled = r10.zoomEnabled, this.hasNames = "category" === this.type || true === r10.categories, this.categories = sz(r10.categories) && r10.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = sC(r10.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r10.minRange || r10.maxZoom, this.range = r10.range, this.offset = r10.offset || 0, this.max = void 0, this.min = void 0;
          let n10 = sH(r10.crosshair, sj(t10.options.tooltip.crosshairs)[s10 ? 0 : 1]);
          this.crosshair = true === n10 ? {} : n10, -1 === t10.axes.indexOf(this) && (s10 ? t10.axes.splice(t10.xAxis.length, 0, this) : t10.axes.push(this), sI(this, t10[this.coll])), t10.orderItems(this.coll), this.series = this.series || [], t10.inverted && !this.isZAxis && s10 && !sC(this.reversed) && (this.reversed = true), this.labelRotation = sR(a10.rotation) ? a10.rotation : void 0, sk(this, r10), sD(this, "afterInit");
        }
        setOptions(t10) {
          let e10 = this.horiz ? { labels: { autoRotation: [-45], padding: 3 }, margin: 15 } : { labels: { padding: 1 }, title: { rotation: 90 * this.side } };
          this.options = sW(e10, sv[this.coll], t10), sD(this, "afterSetOptions", { userOptions: t10 });
        }
        defaultLabelFormatter() {
          let t10 = this.axis, { numberFormatter: e10 } = this.chart, i10 = sR(this.value) ? this.value : NaN, s10 = t10.chart.time, o10 = t10.categories, r10 = this.dateTimeLabelFormat, a10 = sv.lang, n10 = a10.numericSymbols, h10 = a10.numericSymbolMagnitude || 1e3, l10 = t10.logarithmic ? Math.abs(i10) : t10.tickInterval, d10 = n10 && n10.length, c10, p10;
          if (o10) p10 = `${this.value}`;
          else if (r10) p10 = s10.dateFormat(r10, i10, true);
          else if (d10 && n10 && l10 >= 1e3) for (; d10-- && void 0 === p10; ) l10 >= (c10 = Math.pow(h10, d10 + 1)) && 10 * i10 % c10 == 0 && null !== n10[d10] && 0 !== i10 && (p10 = e10(i10 / c10, -1) + n10[d10]);
          return void 0 === p10 && (p10 = Math.abs(i10) >= 1e4 ? e10(i10, -1) : e10(i10, -1, void 0, "")), p10;
        }
        getSeriesExtremes() {
          let t10;
          let e10 = this;
          sD(this, "getSeriesExtremes", null, function() {
            e10.hasVisibleSeries = false, e10.dataMin = e10.dataMax = e10.threshold = void 0, e10.softThreshold = !e10.isXAxis, e10.series.forEach((i10) => {
              if (i10.reserveSpace()) {
                let s10 = i10.options, o10, r10 = s10.threshold, a10, n10;
                if (e10.hasVisibleSeries = true, e10.positiveValuesOnly && 0 >= (r10 || 0) && (r10 = void 0), e10.isXAxis) (o10 = i10.getColumn("x")).length && (o10 = e10.logarithmic ? o10.filter((t11) => t11 > 0) : o10, a10 = (t10 = i10.getXExtremes(o10)).min, n10 = t10.max, sR(a10) || a10 instanceof Date || (o10 = o10.filter(sR), a10 = (t10 = i10.getXExtremes(o10)).min, n10 = t10.max), o10.length && (e10.dataMin = Math.min(sH(e10.dataMin, a10), a10), e10.dataMax = Math.max(sH(e10.dataMax, n10), n10)));
                else {
                  let t11 = i10.applyExtremes();
                  sR(t11.dataMin) && (a10 = t11.dataMin, e10.dataMin = Math.min(sH(e10.dataMin, a10), a10)), sR(t11.dataMax) && (n10 = t11.dataMax, e10.dataMax = Math.max(sH(e10.dataMax, n10), n10)), sC(r10) && (e10.threshold = r10), (!s10.softThreshold || e10.positiveValuesOnly) && (e10.softThreshold = false);
                }
              }
            });
          }), sD(this, "afterGetSeriesExtremes");
        }
        translate(t10, e10, i10, s10, o10, r10) {
          var _a;
          let a10 = this.linkedParent || this, n10 = s10 && a10.old ? a10.old.min : a10.min;
          if (!sR(n10)) return NaN;
          let h10 = a10.minPixelPadding, l10 = (a10.isOrdinal || ((_a = a10.brokenAxis) == null ? void 0 : _a.hasBreaks) || a10.logarithmic && o10) && a10.lin2val, d10 = 1, c10 = 0, p10 = s10 && a10.old ? a10.old.transA : a10.transA, u2 = 0;
          return p10 || (p10 = a10.transA), i10 && (d10 *= -1, c10 = a10.len), a10.reversed && (d10 *= -1, c10 -= d10 * (a10.sector || a10.len)), e10 ? (u2 = (t10 = t10 * d10 + c10 - h10) / p10 + n10, l10 && (u2 = a10.lin2val(u2))) : (l10 && (t10 = a10.val2lin(t10)), u2 = d10 * (t10 - n10) * p10 + c10 + d10 * h10 + (sR(r10) ? p10 * r10 : 0), a10.isRadial || (u2 = sT(u2))), u2;
        }
        toPixels(t10, e10) {
          var _a;
          return this.translate(((_a = this.chart) == null ? void 0 : _a.time.parse(t10)) ?? NaN, false, !this.horiz, void 0, true) + (e10 ? 0 : this.pos);
        }
        toValue(t10, e10) {
          return this.translate(t10 - (e10 ? 0 : this.pos), true, !this.horiz, void 0, true);
        }
        getPlotLinePath(t10) {
          let e10 = this, i10 = e10.chart, s10 = e10.left, o10 = e10.top, r10 = t10.old, a10 = t10.value, n10 = t10.lineWidth, h10 = r10 && i10.oldChartHeight || i10.chartHeight, l10 = r10 && i10.oldChartWidth || i10.chartWidth, d10 = e10.transB, c10 = t10.translatedValue, p10 = t10.force, u2, g2, f2, m2, x2;
          function y2(t11, e11, i11) {
            return "pass" !== p10 && (t11 < e11 || t11 > i11) && (p10 ? t11 = sA(t11, e11, i11) : x2 = true), t11;
          }
          let b2 = { value: a10, lineWidth: n10, old: r10, force: p10, acrossPanes: t10.acrossPanes, translatedValue: c10 };
          return sD(this, "getPlotLinePath", b2, function(t11) {
            u2 = f2 = (c10 = sA(c10 = sH(c10, e10.translate(a10, void 0, void 0, r10)), -1e9, 1e9)) + d10, g2 = m2 = h10 - c10 - d10, sR(c10) ? e10.horiz ? (g2 = o10, m2 = h10 - e10.bottom + (e10.options.isInternal ? 0 : i10.scrollablePixelsY || 0), u2 = f2 = y2(u2, s10, s10 + e10.width)) : (u2 = s10, f2 = l10 - e10.right + (i10.scrollablePixelsX || 0), g2 = m2 = y2(g2, o10, o10 + e10.height)) : (x2 = true, p10 = false), t11.path = x2 && !p10 ? void 0 : i10.renderer.crispLine([["M", u2, g2], ["L", f2, m2]], n10 || 1);
          }), b2.path;
        }
        getLinearTickPositions(t10, e10, i10) {
          let s10, o10, r10;
          let a10 = sT(Math.floor(e10 / t10) * t10), n10 = sT(Math.ceil(i10 / t10) * t10), h10 = [];
          if (sT(a10 + t10) === a10 && (r10 = 20), this.single) return [e10];
          for (s10 = a10; s10 <= n10 && (h10.push(s10), (s10 = sT(s10 + t10, r10)) !== o10); ) o10 = s10;
          return h10;
        }
        getMinorTickInterval() {
          let { minorTicks: t10, minorTickInterval: e10 } = this.options;
          return true === t10 ? sH(e10, "auto") : false !== t10 ? e10 : void 0;
        }
        getMinorTickPositions() {
          var _a;
          let t10 = this.options, e10 = this.tickPositions, i10 = this.minorTickInterval, s10 = this.pointRangePadding || 0, o10 = (this.min || 0) - s10, r10 = (this.max || 0) + s10, a10 = ((_a = this.brokenAxis) == null ? void 0 : _a.hasBreaks) ? this.brokenAxis.unitLength : r10 - o10, n10 = [], h10;
          if (a10 && a10 / i10 < this.len / 3) {
            let s11 = this.logarithmic;
            if (s11) this.paddedTicks.forEach(function(t11, e11, o11) {
              e11 && n10.push.apply(n10, s11.getLogTickPositions(i10, o11[e11 - 1], o11[e11], true));
            });
            else if (this.dateTime && "auto" === this.getMinorTickInterval()) n10 = n10.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i10), o10, r10, t10.startOfWeek));
            else for (h10 = o10 + (e10[0] - o10) % i10; h10 <= r10 && h10 !== n10[0]; h10 += i10) n10.push(h10);
          }
          return 0 !== n10.length && this.trimTicks(n10), n10;
        }
        adjustForMinRange() {
          let t10 = this.options, e10 = this.logarithmic, i10 = this.chart.time, { max: s10, min: o10, minRange: r10 } = this, a10, n10, h10, l10;
          this.isXAxis && void 0 === r10 && !e10 && (r10 = sC(t10.min) || sC(t10.max) || sC(t10.floor) || sC(t10.ceiling) ? null : Math.min(5 * (sB(this.series.map((t11) => {
            let e11 = t11.getColumn("x");
            return t11.xIncrement ? e11.slice(0, 2) : e11;
          })) || 0), this.dataMax - this.dataMin)), sR(s10) && sR(o10) && sR(r10) && s10 - o10 < r10 && (n10 = this.dataMax - this.dataMin >= r10, a10 = (r10 - s10 + o10) / 2, h10 = [o10 - a10, i10.parse(t10.min) ?? o10 - a10], n10 && (h10[2] = e10 ? e10.log2lin(this.dataMin) : this.dataMin), l10 = [(o10 = sw(h10)) + r10, i10.parse(t10.max) ?? o10 + r10], n10 && (l10[2] = e10 ? e10.log2lin(this.dataMax) : this.dataMax), (s10 = sS(l10)) - o10 < r10 && (h10[0] = s10 - r10, h10[1] = i10.parse(t10.min) ?? s10 - r10, o10 = sw(h10))), this.minRange = r10, this.min = o10, this.max = s10;
        }
        getClosest() {
          let t10, e10;
          if (this.categories) e10 = 1;
          else {
            let i10 = [];
            this.series.forEach(function(t11) {
              let s10 = t11.closestPointRange, o10 = t11.getColumn("x");
              1 === o10.length ? i10.push(o10[0]) : t11.sorted && sC(s10) && t11.reserveSpace() && (e10 = sC(e10) ? Math.min(e10, s10) : s10);
            }), i10.length && (i10.sort((t11, e11) => t11 - e11), t10 = sB([i10]));
          }
          return t10 && e10 ? Math.min(t10, e10) : t10 || e10;
        }
        nameToX(t10) {
          let e10 = sz(this.options.categories), i10 = e10 ? this.categories : this.names, s10 = t10.options.x, o10;
          return t10.series.requireSorting = false, sC(s10) || (s10 = this.uniqueNames && i10 ? e10 ? i10.indexOf(t10.name) : sH(i10.keys[t10.name], -1) : t10.series.autoIncrement()), -1 === s10 ? !e10 && i10 && (o10 = i10.length) : sR(s10) && (o10 = s10), void 0 !== o10 ? (this.names[o10] = t10.name, this.names.keys[t10.name] = o10) : t10.x && (o10 = t10.x), o10;
        }
        updateNames() {
          let t10 = this, e10 = this.names;
          e10.length > 0 && (Object.keys(e10.keys).forEach(function(t11) {
            delete e10.keys[t11];
          }), e10.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((e11) => {
            e11.xIncrement = null, (!e11.points || e11.isDirtyData) && (t10.max = Math.max(t10.max || 0, e11.dataTable.rowCount - 1), e11.processData(), e11.generatePoints());
            let i10 = e11.getColumn("x").slice();
            e11.data.forEach((e12, s10) => {
              let o10 = i10[s10];
              (e12 == null ? void 0 : e12.options) && void 0 !== e12.name && void 0 !== (o10 = t10.nameToX(e12)) && o10 !== e12.x && (i10[s10] = e12.x = o10);
            }), e11.dataTable.setColumn("x", i10);
          }));
        }
        setAxisTranslation() {
          let t10 = this, e10 = t10.max - t10.min, i10 = t10.linkedParent, s10 = !!t10.categories, o10 = t10.isXAxis, r10 = t10.axisPointRange || 0, a10, n10 = 0, h10 = 0, l10, d10 = t10.transA;
          (o10 || s10 || r10) && (a10 = t10.getClosest(), i10 ? (n10 = i10.minPointOffset, h10 = i10.pointRangePadding) : t10.series.forEach(function(e11) {
            let i11 = s10 ? 1 : o10 ? sH(e11.options.pointRange, a10, 0) : t10.axisPointRange || 0, l11 = e11.options.pointPlacement;
            if (r10 = Math.max(r10, i11), !t10.single || s10) {
              let t11 = e11.is("xrange") ? !o10 : o10;
              n10 = Math.max(n10, t11 && sN(l11) ? 0 : i11 / 2), h10 = Math.max(h10, t11 && "on" === l11 ? 0 : i11);
            }
          }), l10 = t10.ordinal && t10.ordinal.slope && a10 ? t10.ordinal.slope / a10 : 1, t10.minPointOffset = n10 *= l10, t10.pointRangePadding = h10 *= l10, t10.pointRange = Math.min(r10, t10.single && s10 ? 1 : e10), o10 && a10 && (t10.closestPointRange = a10)), t10.translationSlope = t10.transA = d10 = t10.staticScale || t10.len / (e10 + h10 || 1), t10.transB = t10.horiz ? t10.left : t10.bottom, t10.minPixelPadding = d10 * n10, sD(this, "afterSetAxisTranslation");
        }
        minFromRange() {
          let { max: t10, min: e10 } = this;
          return sR(t10) && sR(e10) && t10 - e10 || void 0;
        }
        setTickInterval(t10) {
          var _a, _b, _c, _d;
          let { categories: e10, chart: i10, dataMax: s10, dataMin: o10, dateTime: r10, isXAxis: a10, logarithmic: n10, options: h10, softThreshold: l10 } = this, d10 = i10.time, c10 = sR(this.threshold) ? this.threshold : void 0, p10 = this.minRange || 0, { ceiling: u2, floor: g2, linkedTo: f2, softMax: m2, softMin: x2 } = h10, y2 = sR(f2) && ((_a = i10[this.coll]) == null ? void 0 : _a[f2]), b2 = h10.tickPixelInterval, v2 = h10.maxPadding, k2 = h10.minPadding, M2 = 0, w2, S2 = sR(h10.tickInterval) && h10.tickInterval >= 0 ? h10.tickInterval : void 0, A2, T2, C2, P2;
          if (r10 || e10 || y2 || this.getTickAmount(), C2 = sH(this.userMin, d10.parse(h10.min)), P2 = sH(this.userMax, d10.parse(h10.max)), y2 ? (this.linkedParent = y2, w2 = y2.getExtremes(), this.min = sH(w2.min, w2.dataMin), this.max = sH(w2.max, w2.dataMax), this.type !== y2.type && sE(11, true, i10)) : (l10 && sC(c10) && sR(s10) && sR(o10) && (o10 >= c10 ? (A2 = c10, k2 = 0) : s10 <= c10 && (T2 = c10, v2 = 0)), this.min = sH(C2, A2, o10), this.max = sH(P2, T2, s10)), sR(this.max) && sR(this.min) && (n10 && (this.positiveValuesOnly && !t10 && 0 >= Math.min(this.min, sH(o10, this.min)) && sE(10, true, i10), this.min = sT(n10.log2lin(this.min), 16), this.max = sT(n10.log2lin(this.max), 16)), this.range && sR(o10) && (this.userMin = this.min = C2 = Math.max(o10, this.minFromRange() || 0), this.userMax = P2 = this.max, this.range = void 0)), sD(this, "foundExtremes"), this.adjustForMinRange(), sR(this.min) && sR(this.max)) {
            if (!sR(this.userMin) && sR(x2) && x2 < this.min && (this.min = C2 = x2), !sR(this.userMax) && sR(m2) && m2 > this.max && (this.max = P2 = m2), e10 || this.axisPointRange || ((_b = this.stacking) == null ? void 0 : _b.usePercentage) || y2 || !(M2 = this.max - this.min) || (!sC(C2) && k2 && (this.min -= M2 * k2), sC(P2) || !v2 || (this.max += M2 * v2)), !sR(this.userMin) && sR(g2) && (this.min = Math.max(this.min, g2)), !sR(this.userMax) && sR(u2) && (this.max = Math.min(this.max, u2)), l10 && sR(o10) && sR(s10)) {
              let t11 = c10 || 0;
              !sC(C2) && this.min < t11 && o10 >= t11 ? this.min = h10.minRange ? Math.min(t11, this.max - p10) : t11 : !sC(P2) && this.max > t11 && s10 <= t11 && (this.max = h10.minRange ? Math.max(t11, this.min + p10) : t11);
            }
            !i10.polar && this.min > this.max && (sC(h10.min) ? this.max = this.min : sC(h10.max) && (this.min = this.max)), M2 = this.max - this.min;
          }
          if (this.min !== this.max && sR(this.min) && sR(this.max) ? y2 && !S2 && b2 === y2.options.tickPixelInterval ? this.tickInterval = S2 = y2.tickInterval : this.tickInterval = sH(S2, this.tickAmount ? M2 / Math.max(this.tickAmount - 1, 1) : void 0, e10 ? 1 : M2 * b2 / Math.max(this.len, b2)) : this.tickInterval = 1, a10 && !t10) {
            let t11 = this.min !== ((_c = this.old) == null ? void 0 : _c.min) || this.max !== ((_d = this.old) == null ? void 0 : _d.max);
            this.series.forEach(function(e11) {
              var _a2;
              e11.forceCrop = (_a2 = e11.forceCropping) == null ? void 0 : _a2.call(e11), e11.processData(t11);
            }), sD(this, "postProcessData", { hasExtremesChanged: t11 });
          }
          this.setAxisTranslation(), sD(this, "initialAxisTranslation"), this.pointRange && !S2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
          let O2 = sH(h10.minTickInterval, r10 && !this.series.some((t11) => !t11.sorted) ? this.closestPointRange : 0);
          !S2 && this.tickInterval < O2 && (this.tickInterval = O2), r10 || n10 || S2 || (this.tickInterval = sV(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
        }
        setTickPositions() {
          var _a, _b;
          let t10 = this.options, e10 = t10.tickPositions, i10 = t10.tickPositioner, s10 = this.getMinorTickInterval(), o10 = !this.isPanning, r10 = o10 && t10.startOnTick, a10 = o10 && t10.endOnTick, n10 = [], h10;
          if (this.tickmarkOffset = this.categories && "between" === t10.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0, this.single = this.min === this.max && sC(this.min) && !this.tickAmount && (this.min % 1 == 0 || false !== t10.allowDecimals), e10) n10 = e10.slice();
          else if (sR(this.min) && sR(this.max)) {
            if (!((_a = this.ordinal) == null ? void 0 : _a.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) n10 = [this.min, this.max], sE(19, false, this.chart);
            else if (this.dateTime) n10 = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t10.units), this.min, this.max, t10.startOfWeek, (_b = this.ordinal) == null ? void 0 : _b.positions, this.closestPointRange, true);
            else if (this.logarithmic) n10 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
            else {
              let t11 = this.tickInterval, e11 = t11;
              for (; e11 <= 2 * t11; ) if (n10 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && n10.length > this.tickAmount) this.tickInterval = sV(this, e11 *= 1.1);
              else break;
            }
            n10.length > this.len && (n10 = [n10[0], n10[n10.length - 1]])[0] === n10[1] && (n10.length = 1), i10 && (this.tickPositions = n10, (h10 = i10.apply(this, [this.min, this.max])) && (n10 = h10));
          }
          this.tickPositions = n10, this.minorTickInterval = "auto" === s10 && this.tickInterval ? this.tickInterval / t10.minorTicksPerMajor : s10, this.paddedTicks = n10.slice(0), this.trimTicks(n10, r10, a10), !this.isLinked && sR(this.min) && sR(this.max) && (this.single && n10.length < 2 && !this.categories && !this.series.some((t11) => t11.is("heatmap") && "between" === t11.options.pointPlacement) && (this.min -= 0.5, this.max += 0.5), e10 || h10 || this.adjustTickAmount()), sD(this, "afterSetTickPositions");
        }
        trimTicks(t10, e10, i10) {
          let s10 = t10[0], o10 = t10[t10.length - 1], r10 = !this.isOrdinal && this.minPointOffset || 0;
          if (sD(this, "trimTicks"), !this.isLinked) {
            if (e10 && s10 !== -1 / 0) this.min = s10;
            else for (; this.min - r10 > t10[0]; ) t10.shift();
            if (i10) this.max = o10;
            else for (; this.max + r10 < t10[t10.length - 1]; ) t10.pop();
            0 === t10.length && sC(s10) && !this.options.tickPositions && t10.push((o10 + s10) / 2);
          }
        }
        alignToOthers() {
          let t10;
          let e10 = this, i10 = e10.chart, s10 = [this], o10 = e10.options, r10 = i10.options.chart, a10 = "yAxis" === this.coll && r10.alignThresholds, n10 = [];
          if (e10.thresholdAlignment = void 0, (false !== r10.alignTicks && o10.alignTicks || a10) && false !== o10.startOnTick && false !== o10.endOnTick && !e10.logarithmic) {
            let o11 = (t11) => {
              let { horiz: e11, options: i11 } = t11;
              return [e11 ? i11.left : i11.top, i11.width, i11.height, i11.pane].join(",");
            }, r11 = o11(this);
            i10[this.coll].forEach(function(i11) {
              let { series: a11 } = i11;
              a11.length && a11.some((t11) => t11.visible) && i11 !== e10 && o11(i11) === r11 && (t10 = true, s10.push(i11));
            });
          }
          if (t10 && a10) {
            s10.forEach((t12) => {
              let i11 = t12.getThresholdAlignment(e10);
              sR(i11) && n10.push(i11);
            });
            let t11 = n10.length > 1 ? n10.reduce((t12, e11) => t12 += e11, 0) / n10.length : void 0;
            s10.forEach((e11) => {
              e11.thresholdAlignment = t11;
            });
          }
          return t10;
        }
        getThresholdAlignment(t10) {
          if ((!sR(this.dataMin) || this !== t10 && this.series.some((t11) => t11.isDirty || t11.isDirtyData)) && this.getSeriesExtremes(), sR(this.threshold)) {
            let t11 = sA((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
            return this.options.reversed && (t11 = 1 - t11), t11;
          }
        }
        getTickAmount() {
          let t10 = this.options, e10 = t10.tickPixelInterval, i10 = t10.tickAmount;
          sC(t10.tickInterval) || i10 || !(this.len < e10) || this.isRadial || this.logarithmic || !t10.startOnTick || !t10.endOnTick || (i10 = 2), !i10 && this.alignToOthers() && (i10 = Math.ceil(this.len / e10) + 1), i10 < 4 && (this.finalTickAmt = i10, i10 = 5), this.tickAmount = i10;
        }
        adjustTickAmount() {
          let t10 = this, { finalTickAmt: e10, max: i10, min: s10, options: o10, tickPositions: r10, tickAmount: a10, thresholdAlignment: n10 } = t10, h10 = r10 == null ? void 0 : r10.length, l10 = sH(t10.threshold, t10.softThreshold ? 0 : null), d10, c10, p10 = t10.tickInterval, u2, g2 = () => r10.push(sT(r10[r10.length - 1] + p10)), f2 = () => r10.unshift(sT(r10[0] - p10));
          if (sR(n10) && (u2 = n10 < 0.5 ? Math.ceil(n10 * (a10 - 1)) : Math.floor(n10 * (a10 - 1)), o10.reversed && (u2 = a10 - 1 - u2)), t10.hasData() && sR(s10) && sR(i10)) {
            let n11 = () => {
              t10.transA *= (h10 - 1) / (a10 - 1), t10.min = o10.startOnTick ? r10[0] : Math.min(s10, r10[0]), t10.max = o10.endOnTick ? r10[r10.length - 1] : Math.max(i10, r10[r10.length - 1]);
            };
            if (sR(u2) && sR(t10.threshold)) {
              for (; r10[u2] !== l10 || r10.length !== a10 || r10[0] > s10 || r10[r10.length - 1] < i10; ) {
                for (r10.length = 0, r10.push(t10.threshold); r10.length < a10; ) void 0 === r10[u2] || r10[u2] > t10.threshold ? f2() : g2();
                if (p10 > 8 * t10.tickInterval) break;
                p10 *= 2;
              }
              n11();
            } else if (h10 < a10) {
              for (; r10.length < a10; ) r10.length % 2 || s10 === l10 ? g2() : f2();
              n11();
            }
            if (sC(e10)) {
              for (c10 = d10 = r10.length; c10--; ) (3 === e10 && c10 % 2 == 1 || e10 <= 2 && c10 > 0 && c10 < d10 - 1) && r10.splice(c10, 1);
              t10.finalTickAmt = void 0;
            }
          }
        }
        setScale() {
          var _a, _b;
          let { coll: t10, stacking: e10 } = this, i10 = false, s10 = false;
          this.series.forEach((t11) => {
            i10 = i10 || t11.isDirtyData || t11.isDirty, s10 = s10 || t11.xAxis && t11.xAxis.isDirty || false;
          }), this.setAxisSize();
          let o10 = this.len !== (this.old && this.old.len);
          o10 || i10 || s10 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e10 && "yAxis" === t10 && e10.buildStacks(), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e10 && "xAxis" === t10 && e10.buildStacks(), this.isDirty || (this.isDirty = o10 || this.min !== ((_a = this.old) == null ? void 0 : _a.min) || this.max !== ((_b = this.old) == null ? void 0 : _b.max))) : e10 && e10.cleanStacks(), i10 && delete this.allExtremes, sD(this, "afterSetScale");
        }
        setExtremes(t10, e10, i10 = true, s10, o10) {
          let r10 = this.chart;
          this.series.forEach((t11) => {
            delete t11.kdTree;
          }), t10 = r10.time.parse(t10), e10 = r10.time.parse(e10), sD(this, "setExtremes", o10 = sL(o10, { min: t10, max: e10 }), (t11) => {
            this.userMin = t11.min, this.userMax = t11.max, this.eventArgs = t11, i10 && r10.redraw(s10);
          });
        }
        setAxisSize() {
          let t10 = this.chart, e10 = this.options, i10 = e10.offsets || [0, 0, 0, 0], s10 = this.horiz, o10 = this.width = Math.round(sF(sH(e10.width, t10.plotWidth - i10[3] + i10[1]), t10.plotWidth)), r10 = this.height = Math.round(sF(sH(e10.height, t10.plotHeight - i10[0] + i10[2]), t10.plotHeight)), a10 = this.top = Math.round(sF(sH(e10.top, t10.plotTop + i10[0]), t10.plotHeight, t10.plotTop)), n10 = this.left = Math.round(sF(sH(e10.left, t10.plotLeft + i10[3]), t10.plotWidth, t10.plotLeft));
          this.bottom = t10.chartHeight - r10 - a10, this.right = t10.chartWidth - o10 - n10, this.len = Math.max(s10 ? o10 : r10, 0), this.pos = s10 ? n10 : a10;
        }
        getExtremes() {
          let t10 = this.logarithmic;
          return { min: t10 ? sT(t10.lin2log(this.min)) : this.min, max: t10 ? sT(t10.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
        }
        getThreshold(t10) {
          let e10 = this.logarithmic, i10 = e10 ? e10.lin2log(this.min) : this.min, s10 = e10 ? e10.lin2log(this.max) : this.max;
          return null === t10 || t10 === -1 / 0 ? t10 = i10 : t10 === 1 / 0 ? t10 = s10 : i10 > t10 ? t10 = i10 : s10 < t10 && (t10 = s10), this.translate(t10, 0, 1, 0, 1);
        }
        autoLabelAlign(t10) {
          let e10 = (sH(t10, 0) - 90 * this.side + 720) % 360, i10 = { align: "center" };
          return sD(this, "autoLabelAlign", i10, function(t11) {
            e10 > 15 && e10 < 165 ? t11.align = "right" : e10 > 195 && e10 < 345 && (t11.align = "left");
          }), i10.align;
        }
        tickSize(t10) {
          let e10 = this.options, i10 = sH(e10["tick" === t10 ? "tickWidth" : "minorTickWidth"], "tick" === t10 && this.isXAxis && !this.categories ? 1 : 0), s10 = e10["tick" === t10 ? "tickLength" : "minorTickLength"], o10;
          i10 && s10 && ("inside" === e10[t10 + "Position"] && (s10 = -s10), o10 = [s10, i10]);
          let r10 = { tickSize: o10 };
          return sD(this, "afterTickSize", r10), r10.tickSize;
        }
        labelMetrics() {
          let t10 = this.chart.renderer, e10 = this.ticks, i10 = e10[Object.keys(e10)[0]] || {};
          return this.chart.renderer.fontMetrics(i10.label || i10.movedLabel || t10.box);
        }
        unsquish() {
          let t10 = this.options.labels, e10 = t10.padding || 0, i10 = this.horiz, s10 = this.tickInterval, o10 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s10), r10 = t10.rotation, a10 = sT(0.8 * this.labelMetrics().h), n10 = Math.max(this.max - this.min, 0), h10 = function(t11) {
            let i11 = (t11 + 2 * e10) / (o10 || 1);
            return (i11 = i11 > 1 ? Math.ceil(i11) : 1) * s10 > n10 && t11 !== 1 / 0 && o10 !== 1 / 0 && n10 && (i11 = Math.ceil(n10 / s10)), sT(i11 * s10);
          }, l10 = s10, d10, c10 = Number.MAX_VALUE, p10;
          if (i10) {
            if (!t10.staggerLines && (sR(r10) ? p10 = [r10] : o10 < t10.autoRotationLimit && (p10 = t10.autoRotation)), p10) {
              let t11, e11;
              for (let i11 of p10) (i11 === r10 || i11 && i11 >= -90 && i11 <= 90) && (e11 = (t11 = h10(Math.abs(a10 / Math.sin(sM * i11)))) + Math.abs(i11 / 360)) < c10 && (c10 = e11, d10 = i11, l10 = t11);
            }
          } else l10 = h10(0.75 * a10);
          return this.autoRotation = p10, this.labelRotation = sH(d10, sR(r10) ? r10 : 0), t10.step ? s10 : l10;
        }
        getSlotWidth(t10) {
          let e10 = this.chart, i10 = this.horiz, s10 = this.options.labels, o10 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), r10 = e10.margin[3];
          if (t10 && sR(t10.slotWidth)) return t10.slotWidth;
          if (i10 && s10.step < 2 && !this.isRadial) return s10.rotation ? 0 : (this.staggerLines || 1) * this.len / o10;
          if (!i10) {
            let t11 = s10.style.width;
            if (void 0 !== t11) return parseInt(String(t11), 10);
            if (r10) return r10 - e10.spacing[3];
          }
          return 0.33 * e10.chartWidth;
        }
        renderUnsquish() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.tickPositions, s10 = this.ticks, o10 = this.options.labels, r10 = o10.style, a10 = this.horiz, n10 = this.getSlotWidth(), h10 = Math.max(1, Math.round(n10 - (a10 ? 2 * (o10.padding || 0) : o10.distance || 0))), l10 = {}, d10 = this.labelMetrics(), c10 = r10.lineClamp, p10, u2 = c10 ?? (Math.floor(this.len / (i10.length * d10.h)) || 1), g2 = 0;
          sN(o10.rotation) || (l10.rotation = o10.rotation || 0), i10.forEach(function(t11) {
            var _a;
            let e11 = s10[t11];
            e11.movedLabel && e11.replaceMovedLabel();
            let i11 = ((_a = e11.label) == null ? void 0 : _a.textPxLength) || 0;
            i11 > g2 && (g2 = i11);
          }), this.maxLabelLength = g2, this.autoRotation ? g2 > h10 && g2 > d10.h ? l10.rotation = this.labelRotation : this.labelRotation = 0 : n10 && (p10 = h10), l10.rotation && (p10 = g2 > 0.5 * t10.chartHeight ? 0.33 * t10.chartHeight : g2, c10 || (u2 = 1)), this.labelAlign = o10.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l10.align = this.labelAlign), i10.forEach(function(t11) {
            let e11 = s10[t11], i11 = e11 && e11.label, o11 = r10.width, a11 = {};
            i11 && (i11.attr(l10), e11.shortenLabel ? e11.shortenLabel() : p10 && !o11 && "nowrap" !== r10.whiteSpace && (p10 < (i11.textPxLength || 0) || "SPAN" === i11.element.tagName) ? i11.css(sL(a11, { width: `${p10}px`, lineClamp: u2 })) : !i11.styles.width || a11.width || o11 || i11.css({ width: "auto" }), e11.rotation = l10.rotation);
          }, this), this.tickRotCorr = e10.rotCorr(d10.b, this.labelRotation || 0, 0 !== this.side);
        }
        hasData() {
          return this.series.some(function(t10) {
            return t10.hasData();
          }) || this.options.showEmpty && sC(this.min) && sC(this.max);
        }
        addTitle(t10) {
          let e10;
          let i10 = this.chart.renderer, s10 = this.horiz, o10 = this.opposite, r10 = this.options.title, a10 = this.chart.styledMode;
          this.axisTitle || ((e10 = r10.textAlign) || (e10 = (s10 ? { low: "left", middle: "center", high: "right" } : { low: o10 ? "right" : "left", middle: "center", high: o10 ? "left" : "right" })[r10.align]), this.axisTitle = i10.text(r10.text || "", 0, 0, r10.useHTML).attr({ zIndex: 7, rotation: r10.rotation || 0, align: e10 }).addClass("highcharts-axis-title"), a10 || this.axisTitle.css(sW(r10.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true), a10 || r10.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" }), this.axisTitle[t10 ? "show" : "hide"](t10);
        }
        generateTick(t10) {
          let e10 = this.ticks;
          e10[t10] ? e10[t10].addLabel() : e10[t10] = new sm(this, t10);
        }
        createGroups() {
          let { axisParent: t10, chart: e10, coll: i10, options: s10 } = this, o10 = e10.renderer, r10 = (e11, r11, a10) => o10.g(e11).attr({ zIndex: a10 }).addClass(`highcharts-${i10.toLowerCase()}${r11} ` + (this.isRadial ? `highcharts-radial-axis${r11} ` : "") + (s10.className || "")).add(t10);
          this.axisGroup || (this.gridGroup = r10("grid", "-grid", s10.gridZIndex), this.axisGroup = r10("axis", "", s10.zIndex), this.labelGroup = r10("axis-labels", "-labels", s10.labels.zIndex));
        }
        getOffset() {
          let t10 = this, { chart: e10, horiz: i10, options: s10, side: o10, ticks: r10, tickPositions: a10, coll: n10 } = t10, h10 = e10.inverted && !t10.isZAxis ? [1, 0, 3, 2][o10] : o10, l10 = t10.hasData(), d10 = s10.title, c10 = s10.labels, p10 = sR(s10.crossing), u2 = e10.axisOffset, g2 = e10.clipOffset, f2 = [-1, 1, 1, -1][o10], m2, x2 = 0, y2, b2 = 0, v2 = 0, k2, M2;
          if (t10.showAxis = m2 = l10 || s10.showEmpty, t10.staggerLines = t10.horiz && c10.staggerLines || void 0, t10.createGroups(), l10 || t10.isLinked ? (a10.forEach(function(e11) {
            t10.generateTick(e11);
          }), t10.renderUnsquish(), t10.reserveSpaceDefault = 0 === o10 || 2 === o10 || { 1: "left", 3: "right" }[o10] === t10.labelAlign, sH(c10.reserveSpace, !p10 && null, "center" === t10.labelAlign || null, t10.reserveSpaceDefault) && a10.forEach(function(t11) {
            v2 = Math.max(r10[t11].getLabelSize(), v2);
          }), t10.staggerLines && (v2 *= t10.staggerLines), t10.labelOffset = v2 * (t10.opposite ? -1 : 1)) : sX(r10, function(t11, e11) {
            t11.destroy(), delete r10[e11];
          }), (d10 == null ? void 0 : d10.text) && false !== d10.enabled && (t10.addTitle(m2), m2 && !p10 && false !== d10.reserveSpace && (t10.titleOffset = x2 = t10.axisTitle.getBBox()[i10 ? "height" : "width"], b2 = sC(y2 = d10.offset) ? 0 : sH(d10.margin, i10 ? 5 : 10))), t10.renderLine(), t10.offset = f2 * sH(s10.offset, u2[o10] ? u2[o10] + (s10.margin || 0) : 0), t10.tickRotCorr = t10.tickRotCorr || { x: 0, y: 0 }, M2 = 0 === o10 ? -t10.labelMetrics().h : 2 === o10 ? t10.tickRotCorr.y : 0, k2 = Math.abs(v2) + b2, v2 && (k2 -= M2, k2 += f2 * (i10 ? sH(c10.y, t10.tickRotCorr.y + f2 * c10.distance) : sH(c10.x, f2 * c10.distance))), t10.axisTitleMargin = sH(y2, k2), t10.getMaxLabelDimensions && (t10.maxLabelDimensions = t10.getMaxLabelDimensions(r10, a10)), "colorAxis" !== n10 && g2) {
            let e11 = this.tickSize("tick");
            u2[o10] = Math.max(u2[o10], (t10.axisTitleMargin || 0) + x2 + f2 * t10.offset, k2, a10 && a10.length && e11 ? e11[0] + f2 * t10.offset : 0);
            let i11 = !t10.axisLine || s10.offset ? 0 : t10.axisLine.strokeWidth() / 2;
            g2[h10] = Math.max(g2[h10], i11);
          }
          sD(this, "afterGetOffset");
        }
        getLinePath(t10) {
          let e10 = this.chart, i10 = this.opposite, s10 = this.offset, o10 = this.horiz, r10 = this.left + (i10 ? this.width : 0) + s10, a10 = e10.chartHeight - this.bottom - (i10 ? this.height : 0) + s10;
          return i10 && (t10 *= -1), e10.renderer.crispLine([["M", o10 ? this.left : r10, o10 ? a10 : this.top], ["L", o10 ? e10.chartWidth - this.right : r10, o10 ? a10 : e10.chartHeight - this.bottom]], t10);
        }
        renderLine() {
          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
        }
        getTitlePosition(t10) {
          let e10 = this.horiz, i10 = this.left, s10 = this.top, o10 = this.len, r10 = this.options.title, a10 = e10 ? i10 : s10, n10 = this.opposite, h10 = this.offset, l10 = r10.x, d10 = r10.y, c10 = this.chart.renderer.fontMetrics(t10), p10 = t10 ? Math.max(t10.getBBox(false, 0).height - c10.h - 1, 0) : 0, u2 = { low: a10 + (e10 ? 0 : o10), middle: a10 + o10 / 2, high: a10 + (e10 ? o10 : 0) }[r10.align], g2 = (e10 ? s10 + this.height : i10) + (e10 ? 1 : -1) * (n10 ? -1 : 1) * (this.axisTitleMargin || 0) + [-p10, p10, c10.f, -p10][this.side], f2 = { x: e10 ? u2 + l10 : g2 + (n10 ? this.width : 0) + h10 + l10, y: e10 ? g2 + d10 - (n10 ? this.height : 0) + h10 : u2 + d10 };
          return sD(this, "afterGetTitlePosition", { titlePosition: f2 }), f2;
        }
        renderMinorTick(t10, e10) {
          let i10 = this.minorTicks;
          i10[t10] || (i10[t10] = new sm(this, t10, "minor")), e10 && i10[t10].isNew && i10[t10].render(null, true), i10[t10].render(null, false, 1);
        }
        renderTick(t10, e10, i10) {
          let s10 = this.isLinked, o10 = this.ticks;
          (!s10 || t10 >= this.min && t10 <= this.max || this.grid && this.grid.isColumn) && (o10[t10] || (o10[t10] = new sm(this, t10)), i10 && o10[t10].isNew && o10[t10].render(e10, true, -1), o10[t10].render(e10));
        }
        render() {
          let t10, e10;
          let i10 = this, s10 = i10.chart, o10 = i10.logarithmic, r10 = s10.renderer, a10 = i10.options, n10 = i10.isLinked, h10 = i10.tickPositions, l10 = i10.axisTitle, d10 = i10.ticks, c10 = i10.minorTicks, p10 = i10.alternateBands, u2 = a10.stackLabels, g2 = a10.alternateGridColor, f2 = a10.crossing, m2 = i10.tickmarkOffset, x2 = i10.axisLine, y2 = i10.showAxis, b2 = sx(r10.globalAnimation);
          if (i10.labelEdge.length = 0, i10.overlap = false, [d10, c10, p10].forEach(function(t11) {
            sX(t11, function(t12) {
              t12.isActive = false;
            });
          }), sR(f2)) {
            let t11 = this.isXAxis ? s10.yAxis[0] : s10.xAxis[0], e11 = [1, -1, -1, 1][this.side];
            if (t11) {
              let s11 = t11.toPixels(f2, true);
              i10.horiz && (s11 = t11.len - s11), i10.offset = e11 * s11;
            }
          }
          if (i10.hasData() || n10) {
            let r11 = i10.chart.hasRendered && i10.old && sR(i10.old.min);
            i10.minorTickInterval && !i10.categories && i10.getMinorTickPositions().forEach(function(t11) {
              i10.renderMinorTick(t11, r11);
            }), h10.length && (h10.forEach(function(t11, e11) {
              i10.renderTick(t11, e11, r11);
            }), m2 && (0 === i10.min || i10.single) && (d10[-1] || (d10[-1] = new sm(i10, -1, null, true)), d10[-1].render(-1))), g2 && h10.forEach(function(r12, a11) {
              e10 = void 0 !== h10[a11 + 1] ? h10[a11 + 1] + m2 : i10.max - m2, a11 % 2 == 0 && r12 < i10.max && e10 <= i10.max + (s10.polar ? -m2 : m2) && (p10[r12] || (p10[r12] = new L.PlotLineOrBand(i10, {})), t10 = r12 + m2, p10[r12].options = { from: o10 ? o10.lin2log(t10) : t10, to: o10 ? o10.lin2log(e10) : e10, color: g2, className: "highcharts-alternate-grid" }, p10[r12].render(), p10[r12].isActive = true);
            }), i10._addedPlotLB || (i10._addedPlotLB = true, (a10.plotLines || []).concat(a10.plotBands || []).forEach(function(t11) {
              i10.addPlotBandOrLine(t11);
            }));
          }
          [d10, c10, p10].forEach(function(t11) {
            let e11 = [], i11 = b2.duration;
            sX(t11, function(t12, i12) {
              t12.isActive || (t12.render(i12, false, 0), t12.isActive = false, e11.push(i12));
            }), sU(function() {
              let i12 = e11.length;
              for (; i12--; ) t11[e11[i12]] && !t11[e11[i12]].isActive && (t11[e11[i12]].destroy(), delete t11[e11[i12]]);
            }, t11 !== p10 && s10.hasRendered && i11 ? i11 : 0);
          }), x2 && (x2[x2.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(x2.strokeWidth()) }), x2.isPlaced = true, x2[y2 ? "show" : "hide"](y2)), l10 && y2 && (l10[l10.isNew ? "attr" : "animate"](i10.getTitlePosition(l10)), l10.isNew = false), u2 && u2.enabled && i10.stacking && i10.stacking.renderStackTotals(), i10.old = { len: i10.len, max: i10.max, min: i10.min, transA: i10.transA, userMax: i10.userMax, userMin: i10.userMin }, i10.isDirty = false, sD(this, "afterRender");
        }
        redraw() {
          this.visible && (this.render(), this.plotLinesAndBands.forEach(function(t10) {
            t10.render();
          })), this.series.forEach(function(t10) {
            t10.isDirty = true;
          });
        }
        getKeepProps() {
          return this.keepProps || s_.keepProps;
        }
        destroy(t10) {
          let e10 = this, i10 = e10.plotLinesAndBands, s10 = this.eventOptions;
          if (sD(this, "destroy", { keepEvents: t10 }), t10 || sY(e10), [e10.ticks, e10.minorTicks, e10.alternateBands].forEach(function(t11) {
            sP(t11);
          }), i10) {
            let t11 = i10.length;
            for (; t11--; ) i10[t11].destroy();
          }
          for (let t11 in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function(t12) {
            e10[t12] && (e10[t12] = e10[t12].destroy());
          }), e10.plotLinesAndBandsGroups) e10.plotLinesAndBandsGroups[t11] = e10.plotLinesAndBandsGroups[t11].destroy();
          sX(e10, function(t11, i11) {
            -1 === e10.getKeepProps().indexOf(i11) && delete e10[i11];
          }), this.eventOptions = s10;
        }
        drawCrosshair(t10, e10) {
          let i10 = this.crosshair, s10 = sH(i10 && i10.snap, true), o10 = this.chart, r10, a10, n10, h10 = this.cross, l10;
          if (sD(this, "drawCrosshair", { e: t10, point: e10 }), t10 || (t10 = this.cross && this.cross.e), i10 && false !== (sC(e10) || !s10)) {
            if (s10 ? sC(e10) && (a10 = sH("colorAxis" !== this.coll ? e10.crosshairPos : null, this.isXAxis ? e10.plotX : this.len - e10.plotY)) : a10 = t10 && (this.horiz ? t10.chartX - this.pos : this.len - t10.chartY + this.pos), sC(a10) && (l10 = { value: e10 && (this.isXAxis ? e10.x : sH(e10.stackY, e10.y)), translatedValue: a10 }, o10.polar && sL(l10, { isCrosshair: true, chartX: t10 && t10.chartX, chartY: t10 && t10.chartY, point: e10 }), r10 = this.getPlotLinePath(l10) || null), !sC(r10)) {
              this.hideCrosshair();
              return;
            }
            n10 = this.categories && !this.isRadial, h10 || (this.cross = h10 = o10.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (n10 ? "category " : "thin ") + (i10.className || "")).attr({ zIndex: sH(i10.zIndex, 2) }).add(), !o10.styledMode && (h10.attr({ stroke: i10.color || (n10 ? tL.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"), "stroke-width": sH(i10.width, 1) }).css({ "pointer-events": "none" }), i10.dashStyle && h10.attr({ dashstyle: i10.dashStyle }))), h10.show().attr({ d: r10 }), n10 && !i10.width && h10.attr({ "stroke-width": this.transA }), this.cross.e = t10;
          } else this.hideCrosshair();
          sD(this, "afterDrawCrosshair", { e: t10, point: e10 });
        }
        hideCrosshair() {
          this.cross && this.cross.hide(), sD(this, "afterHideCrosshair");
        }
        update(t10, e10) {
          let i10 = this.chart;
          t10 = sW(this.userOptions, t10), this.destroy(true), this.init(i10, t10), i10.isDirtyBox = true, sH(e10, true) && i10.redraw();
        }
        remove(t10) {
          let e10 = this.chart, i10 = this.coll, s10 = this.series, o10 = s10.length;
          for (; o10--; ) s10[o10] && s10[o10].remove(false);
          sO(e10.axes, this), sO(e10[i10] || [], this), e10.orderItems(i10), this.destroy(), e10.isDirtyBox = true, sH(t10, true) && e10.redraw();
        }
        setTitle(t10, e10) {
          this.update({ title: t10 }, e10);
        }
        setCategories(t10, e10) {
          this.update({ categories: t10 }, e10);
        }
      }
      s_.keepProps = ["coll", "extKey", "hcEvents", "len", "names", "series", "userMax", "userMin"];
      let { addEvent: s$, getMagnitude: sZ, normalizeTickInterval: sq, timeUnits: sK } = ti;
      !function(t10) {
        function e10() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        }
        function i10() {
          if ("datetime" !== this.type) {
            this.dateTime = void 0;
            return;
          }
          this.dateTime || (this.dateTime = new s10(this));
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("dateTime") || (t11.keepProps.push("dateTime"), t11.prototype.getTimeTicks = e10, s$(t11, "afterSetType", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          normalizeTimeTickInterval(t11, e11) {
            let i11 = e11 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], s11 = i11[i11.length - 1], o10 = sK[s11[0]], r10 = s11[1], a10;
            for (a10 = 0; a10 < i11.length && (o10 = sK[(s11 = i11[a10])[0]], r10 = s11[1], !i11[a10 + 1] || !(t11 <= (o10 * r10[r10.length - 1] + sK[i11[a10 + 1][0]]) / 2)); a10++) ;
            o10 === sK.year && t11 < 5 * o10 && (r10 = [1, 2, 5]);
            let n10 = sq(t11 / o10, r10, "year" === s11[0] ? Math.max(sZ(t11 / o10), 1) : 1);
            return { unitRange: o10, count: n10, unitName: s11[0] };
          }
          getXDateFormat(t11, e11) {
            let { axis: i11 } = this, s11 = i11.chart.time;
            return i11.closestPointRange ? s11.getDateFormat(i11.closestPointRange, t11, i11.options.startOfWeek, e11) || s11.resolveDTLFormat(e11.year).main : s11.resolveDTLFormat(e11.day).main;
          }
        }
        t10.Additions = s10;
      }(c || (c = {}));
      let sJ = c, { addEvent: sQ, normalizeTickInterval: s0, pick: s1 } = ti;
      !function(t10) {
        function e10() {
          "logarithmic" !== this.type ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new s10(this));
        }
        function i10() {
          let t11 = this.logarithmic;
          t11 && (this.lin2val = function(e11) {
            return t11.lin2log(e11);
          }, this.val2lin = function(e11) {
            return t11.log2lin(e11);
          });
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("logarithmic") || (t11.keepProps.push("logarithmic"), sQ(t11, "afterSetType", e10), sQ(t11, "afterInit", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          getLogTickPositions(t11, e11, i11, s11) {
            let o10 = this.axis, r10 = o10.len, a10 = o10.options, n10 = [];
            if (s11 || (this.minorAutoInterval = void 0), t11 >= 0.5) t11 = Math.round(t11), n10 = o10.getLinearTickPositions(t11, e11, i11);
            else if (t11 >= 0.08) {
              let o11, r11, a11, h10, l10, d10, c10;
              let p10 = Math.floor(e11);
              for (o11 = t11 > 0.3 ? [1, 2, 4] : t11 > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], r11 = p10; r11 < i11 + 1 && !c10; r11++) for (a11 = 0, h10 = o11.length; a11 < h10 && !c10; a11++) (l10 = this.log2lin(this.lin2log(r11) * o11[a11])) > e11 && (!s11 || d10 <= i11) && void 0 !== d10 && n10.push(d10), d10 > i11 && (c10 = true), d10 = l10;
            } else {
              let h10 = this.lin2log(e11), l10 = this.lin2log(i11), d10 = s11 ? o10.getMinorTickInterval() : a10.tickInterval, c10 = a10.tickPixelInterval / (s11 ? 5 : 1), p10 = s11 ? r10 / o10.tickPositions.length : r10;
              t11 = s0(t11 = s1("auto" === d10 ? null : d10, this.minorAutoInterval, (l10 - h10) * c10 / (p10 || 1))), n10 = o10.getLinearTickPositions(t11, h10, l10).map(this.log2lin), s11 || (this.minorAutoInterval = t11 / 5);
            }
            return s11 || (o10.tickInterval = t11), n10;
          }
          lin2log(t11) {
            return Math.pow(10, t11);
          }
          log2lin(t11) {
            return Math.log(t11) / Math.LN10;
          }
        }
        t10.Additions = s10;
      }(p || (p = {}));
      let s2 = p, { erase: s3, extend: s5, isNumber: s6 } = ti;
      !function(t10) {
        let e10;
        function i10(t11) {
          return this.addPlotBandOrLine(t11, "plotBands");
        }
        function s10(t11, i11) {
          let s11 = this.userOptions, o11 = new e10(this, t11);
          if (this.visible && (o11 = o11.render()), o11) {
            if (this._addedPlotLB || (this._addedPlotLB = true, (s11.plotLines || []).concat(s11.plotBands || []).forEach((t12) => {
              this.addPlotBandOrLine(t12);
            })), i11) {
              let e11 = s11[i11] || [];
              e11.push(t11), s11[i11] = e11;
            }
            this.plotLinesAndBands.push(o11);
          }
          return o11;
        }
        function o10(t11) {
          return this.addPlotBandOrLine(t11, "plotLines");
        }
        function r10(t11, e11, i11) {
          i11 = i11 || this.options;
          let s11 = this.getPlotLinePath({ value: e11, force: true, acrossPanes: i11.acrossPanes }), o11 = [], r11 = this.horiz, a11 = !s6(this.min) || !s6(this.max) || t11 < this.min && e11 < this.min || t11 > this.max && e11 > this.max, n11 = this.getPlotLinePath({ value: t11, force: true, acrossPanes: i11.acrossPanes }), h11, l10 = 1, d10;
          if (n11 && s11) for (a11 && (d10 = n11.toString() === s11.toString(), l10 = 0), h11 = 0; h11 < n11.length; h11 += 2) {
            let t12 = n11[h11], e12 = n11[h11 + 1], i12 = s11[h11], a12 = s11[h11 + 1];
            ("M" === t12[0] || "L" === t12[0]) && ("M" === e12[0] || "L" === e12[0]) && ("M" === i12[0] || "L" === i12[0]) && ("M" === a12[0] || "L" === a12[0]) && (r11 && i12[1] === t12[1] ? (i12[1] += l10, a12[1] += l10) : r11 || i12[2] !== t12[2] || (i12[2] += l10, a12[2] += l10), o11.push(["M", t12[1], t12[2]], ["L", e12[1], e12[2]], ["L", a12[1], a12[2]], ["L", i12[1], i12[2]], ["Z"])), o11.isFlat = d10;
          }
          return o11;
        }
        function a10(t11) {
          this.removePlotBandOrLine(t11);
        }
        function n10(t11) {
          let e11 = this.plotLinesAndBands, i11 = this.options, s11 = this.userOptions;
          if (e11) {
            let o11 = e11.length;
            for (; o11--; ) e11[o11].id === t11 && e11[o11].destroy();
            [i11.plotLines || [], s11.plotLines || [], i11.plotBands || [], s11.plotBands || []].forEach(function(e12) {
              for (o11 = e12.length; o11--; ) (e12[o11] || {}).id === t11 && s3(e12, e12[o11]);
            });
          }
        }
        function h10(t11) {
          this.removePlotBandOrLine(t11);
        }
        t10.compose = function(t11, l10) {
          let d10 = l10.prototype;
          return d10.addPlotBand || (e10 = t11, s5(d10, { addPlotBand: i10, addPlotLine: o10, addPlotBandOrLine: s10, getPlotBandPath: r10, removePlotBand: a10, removePlotLine: h10, removePlotBandOrLine: n10 })), l10;
        };
      }(u || (u = {}));
      let s9 = u, { addEvent: s4, arrayMax: s8, arrayMin: s7, defined: ot, destroyObjectProperties: oe, erase: oi, fireEvent: os, merge: oo, objectEach: or, pick: oa } = ti;
      class on {
        static compose(t10, e10) {
          return s4(t10, "afterInit", function() {
            this.labelCollectors.push(() => {
              var _a;
              let t11 = [];
              for (let e11 of this.axes) for (let { label: i10, options: s10 } of e11.plotLinesAndBands) i10 && !((_a = s10 == null ? void 0 : s10.label) == null ? void 0 : _a.allowOverlap) && t11.push(i10);
              return t11;
            });
          }), s9.compose(on, e10);
        }
        constructor(t10, e10) {
          this.axis = t10, this.options = e10, this.id = e10.id;
        }
        render() {
          os(this, "render");
          let { axis: t10, options: e10 } = this, { horiz: i10, logarithmic: s10 } = t10, { color: o10, events: r10, zIndex: a10 = 0 } = e10, { renderer: n10, time: h10 } = t10.chart, l10 = {}, d10 = h10.parse(e10.to), c10 = h10.parse(e10.from), p10 = h10.parse(e10.value), u2 = e10.borderWidth, g2 = e10.label, { label: f2, svgElem: m2 } = this, x2 = [], y2, b2 = ot(c10) && ot(d10), v2 = ot(p10), k2 = !m2, M2 = { class: "highcharts-plot-" + (b2 ? "band " : "line ") + (e10.className || "") }, w2 = b2 ? "bands" : "lines";
          if (!t10.chart.styledMode && (v2 ? (M2.stroke = o10 || "#999999", M2["stroke-width"] = oa(e10.width, 1), e10.dashStyle && (M2.dashstyle = e10.dashStyle)) : b2 && (M2.fill = o10 || "#e6e9ff", u2 && (M2.stroke = e10.borderColor, M2["stroke-width"] = u2))), l10.zIndex = a10, w2 += "-" + a10, (y2 = t10.plotLinesAndBandsGroups[w2]) || (t10.plotLinesAndBandsGroups[w2] = y2 = n10.g("plot-" + w2).attr(l10).add()), m2 || (this.svgElem = m2 = n10.path().attr(M2).add(y2)), ot(p10)) x2 = t10.getPlotLinePath({ value: (s10 == null ? void 0 : s10.log2lin(p10)) ?? p10, lineWidth: m2.strokeWidth(), acrossPanes: e10.acrossPanes });
          else {
            if (!(ot(c10) && ot(d10))) return;
            x2 = t10.getPlotBandPath((s10 == null ? void 0 : s10.log2lin(c10)) ?? c10, (s10 == null ? void 0 : s10.log2lin(d10)) ?? d10, e10);
          }
          return !this.eventsAdded && r10 && (or(r10, (t11, e11) => {
            m2 == null ? void 0 : m2.on(e11, (t12) => {
              r10[e11].apply(this, [t12]);
            });
          }), this.eventsAdded = true), (k2 || !m2.d) && (x2 == null ? void 0 : x2.length) ? m2.attr({ d: x2 }) : m2 && (x2 ? (m2.show(), m2.animate({ d: x2 })) : m2.d && (m2.hide(), f2 && (this.label = f2 = f2.destroy()))), g2 && (ot(g2.text) || ot(g2.formatter)) && (x2 == null ? void 0 : x2.length) && t10.width > 0 && t10.height > 0 && !x2.isFlat ? (g2 = oo({ align: i10 && b2 ? "center" : void 0, x: i10 ? !b2 && 4 : 10, verticalAlign: !i10 && b2 ? "middle" : void 0, y: i10 ? b2 ? 16 : 10 : b2 ? 6 : -4, rotation: i10 && !b2 ? 90 : 0, ...b2 ? { inside: true } : {} }, g2), this.renderLabel(g2, x2, b2, a10)) : f2 && f2.hide(), this;
        }
        renderLabel(t10, e10, i10, s10) {
          var _a;
          let o10 = this.axis, r10 = o10.chart.renderer, a10 = t10.inside, n10 = this.label;
          n10 || (this.label = n10 = r10.text(this.getLabelText(t10), 0, 0, t10.useHTML).attr({ align: t10.textAlign || t10.align, rotation: t10.rotation, class: "highcharts-plot-" + (i10 ? "band" : "line") + "-label " + (t10.className || ""), zIndex: s10 }), o10.chart.styledMode || n10.css(oo({ fontSize: "0.8em", textOverflow: i10 && !a10 ? "" : "ellipsis" }, t10.style)), n10.add());
          let h10 = e10.xBounds || [e10[0][1], e10[1][1], i10 ? e10[2][1] : e10[0][1]], l10 = e10.yBounds || [e10[0][2], e10[1][2], i10 ? e10[2][2] : e10[0][2]], d10 = s7(h10), c10 = s7(l10), p10 = s8(h10) - d10;
          n10.align(t10, false, { x: d10, y: c10, width: p10, height: s8(l10) - c10 }), (!n10.alignValue || "left" === n10.alignValue || ot(a10)) && n10.css({ width: (((_a = t10.style) == null ? void 0 : _a.width) || (i10 && a10 ? p10 : 90 === n10.rotation ? o10.height - (n10.alignAttr.y - o10.top) : (t10.clip ? o10.width : o10.chart.chartWidth) - (n10.alignAttr.x - o10.left))) + "px" }), n10.show(true);
        }
        getLabelText(t10) {
          return ot(t10.formatter) ? t10.formatter.call(this) : t10.text;
        }
        destroy() {
          oi(this.axis.plotLinesAndBands, this), delete this.axis, oe(this);
        }
      }
      let { animObject: oh } = t_, { format: ol } = eg, { composed: od, dateFormats: oc, doc: op, isSafari: ou } = L, { distribute: og } = ev, { addEvent: of, clamp: om, css: ox, discardElement: oy, extend: ob, fireEvent: ov, isArray: ok, isNumber: oM, isObject: ow, isString: oS, merge: oA, pick: oT, pushUnique: oC, splat: oP, syncTimeout: oO } = ti;
      class oE {
        constructor(t10, e10, i10) {
          this.allowShared = true, this.crosshairs = [], this.distance = 0, this.isHidden = true, this.isSticky = false, this.options = {}, this.outside = false, this.chart = t10, this.init(t10, e10), this.pointer = i10;
        }
        bodyFormatter(t10) {
          return t10.map((t11) => {
            let e10 = t11.series.tooltipOptions, i10 = t11.formatPrefix || "point";
            return (e10[i10 + "Formatter"] || t11.tooltipFormatter).call(t11, e10[i10 + "Format"] || "");
          });
        }
        cleanSplit(t10) {
          this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.tt;
            i10 && (!i10.isActive || t10 ? e10.tt = i10.destroy() : i10.isActive = false);
          });
        }
        defaultFormatter(t10) {
          let e10;
          let i10 = this.points || oP(this);
          return (e10 = (e10 = [t10.headerFooterFormatter(i10[0])]).concat(t10.bodyFormatter(i10))).push(t10.headerFooterFormatter(i10[0], true)), e10;
        }
        destroy() {
          this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), oy(this.container)), ti.clearTimeout(this.hideTimer);
        }
        getAnchor(t10, e10) {
          let i10;
          let { chart: s10, pointer: o10 } = this, r10 = s10.inverted, a10 = s10.plotTop, n10 = s10.plotLeft;
          if ((t10 = oP(t10))[0].series && t10[0].series.yAxis && !t10[0].series.yAxis.options.reversedStacks && (t10 = t10.slice().reverse()), this.followPointer && e10) void 0 === e10.chartX && (e10 = o10.normalize(e10)), i10 = [e10.chartX - n10, e10.chartY - a10];
          else if (t10[0].tooltipPos) i10 = t10[0].tooltipPos;
          else {
            let s11 = 0, o11 = 0;
            t10.forEach(function(t11) {
              let e11 = t11.pos(true);
              e11 && (s11 += e11[0], o11 += e11[1]);
            }), s11 /= t10.length, o11 /= t10.length, this.shared && t10.length > 1 && e10 && (r10 ? s11 = e10.chartX : o11 = e10.chartY), i10 = [s11 - n10, o11 - a10];
          }
          return i10.map(Math.round);
        }
        getClassName(t10, e10, i10) {
          let s10 = this.options, o10 = t10.series, r10 = o10.options;
          return [s10.className, "highcharts-label", i10 && "highcharts-tooltip-header", e10 ? "highcharts-tooltip-box" : "highcharts-tooltip", !i10 && "highcharts-color-" + oT(t10.colorIndex, o10.colorIndex), r10 && r10.className].filter(oS).join(" ");
        }
        getLabel({ anchorX: t10, anchorY: e10 } = { anchorX: 0, anchorY: 0 }) {
          let i10 = this, s10 = this.chart.styledMode, o10 = this.options, r10 = this.split && this.allowShared, a10 = this.container, n10 = this.chart.renderer;
          if (this.label) {
            let t11 = !this.label.hasClass("highcharts-label");
            (!r10 && t11 || r10 && !t11) && this.destroy();
          }
          if (!this.label) {
            if (this.outside) {
              let t11 = this.chart, e11 = t11.options.chart.style, i11 = ef.getRendererType();
              this.container = a10 = L.doc.createElement("div"), a10.className = "highcharts-tooltip-container " + (t11.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || ""), ox(a10, { position: "absolute", top: "1px", pointerEvents: "none", zIndex: Math.max(this.options.style.zIndex || 0, (e11 && e11.zIndex || 0) + 3) }), this.renderer = n10 = new i11(a10, 0, 0, e11, void 0, void 0, n10.styledMode);
            }
            if (r10 ? this.label = n10.g("tooltip") : (this.label = n10.label("", t10, e10, o10.shape, void 0, void 0, o10.useHTML, void 0, "tooltip").attr({ padding: o10.padding, r: o10.borderRadius }), s10 || this.label.attr({ fill: o10.backgroundColor, "stroke-width": o10.borderWidth || 0 }).css(o10.style).css({ pointerEvents: o10.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none") })), i10.outside) {
              let t11 = this.label;
              [t11.xSetter, t11.ySetter].forEach((e11, s11) => {
                t11[s11 ? "ySetter" : "xSetter"] = (o11) => {
                  e11.call(t11, i10.distance), t11[s11 ? "y" : "x"] = o11, a10 && (a10.style[s11 ? "top" : "left"] = `${o11}px`);
                };
              });
            }
            this.label.attr({ zIndex: 8 }).shadow(o10.shadow).add();
          }
          return a10 && !a10.parentElement && L.doc.body.appendChild(a10), this.label;
        }
        getPlayingField() {
          let { body: t10, documentElement: e10 } = op, { chart: i10, distance: s10, outside: o10 } = this;
          return { width: o10 ? Math.max(t10.scrollWidth, e10.scrollWidth, t10.offsetWidth, e10.offsetWidth, e10.clientWidth) - 2 * s10 - 2 : i10.chartWidth, height: o10 ? Math.max(t10.scrollHeight, e10.scrollHeight, t10.offsetHeight, e10.offsetHeight, e10.clientHeight) : i10.chartHeight };
        }
        getPosition(t10, e10, i10) {
          var _a, _b;
          let { distance: s10, chart: o10, outside: r10, pointer: a10 } = this, { inverted: n10, plotLeft: h10, plotTop: l10, polar: d10 } = o10, { plotX: c10 = 0, plotY: p10 = 0 } = i10, u2 = {}, g2 = n10 && i10.h || 0, { height: f2, width: m2 } = this.getPlayingField(), x2 = a10.getChartPosition(), y2 = (t11) => t11 * x2.scaleX, b2 = (t11) => t11 * x2.scaleY, v2 = (i11) => {
            let a11 = "x" === i11;
            return [i11, a11 ? m2 : f2, a11 ? t10 : e10].concat(r10 ? [a11 ? y2(t10) : b2(e10), a11 ? x2.left - s10 + y2(c10 + h10) : x2.top - s10 + b2(p10 + l10), 0, a11 ? m2 : f2] : [a11 ? t10 : e10, a11 ? c10 + h10 : p10 + l10, a11 ? h10 : l10, a11 ? h10 + o10.plotWidth : l10 + o10.plotHeight]);
          }, k2 = v2("y"), M2 = v2("x"), w2, S2 = !!i10.negative;
          !d10 && ((_b = (_a = o10.hoverSeries) == null ? void 0 : _a.yAxis) == null ? void 0 : _b.reversed) && (S2 = !S2);
          let A2 = !this.followPointer && oT(i10.ttBelow, !d10 && !n10 === S2), T2 = function(t11, e11, i11, o11, a11, n11, h11) {
            let l11 = r10 ? "y" === t11 ? b2(s10) : y2(s10) : s10, d11 = (i11 - o11) / 2, c11 = o11 < a11 - s10, p11 = a11 + s10 + o11 < e11, f3 = a11 - l11 - i11 + d11, m3 = a11 + l11 - d11;
            if (A2 && p11) u2[t11] = m3;
            else if (!A2 && c11) u2[t11] = f3;
            else if (c11) u2[t11] = Math.min(h11 - o11, f3 - g2 < 0 ? f3 : f3 - g2);
            else {
              if (!p11) return false;
              u2[t11] = Math.max(n11, m3 + g2 + i11 > e11 ? m3 : m3 + g2);
            }
          }, C2 = function(t11, e11, i11, o11, r11) {
            if (r11 < s10 || r11 > e11 - s10) return false;
            r11 < i11 / 2 ? u2[t11] = 1 : r11 > e11 - o11 / 2 ? u2[t11] = e11 - o11 - 2 : u2[t11] = r11 - i11 / 2;
          }, P2 = function(t11) {
            [k2, M2] = [M2, k2], w2 = t11;
          }, O2 = () => {
            false !== T2.apply(0, k2) ? false !== C2.apply(0, M2) || w2 || (P2(true), O2()) : w2 ? u2.x = u2.y = 0 : (P2(true), O2());
          };
          return (n10 && !d10 || this.len > 1) && P2(), O2(), u2;
        }
        hide(t10) {
          let e10 = this;
          ti.clearTimeout(this.hideTimer), t10 = oT(t10, this.options.hideDelay), this.isHidden || (this.hideTimer = oO(function() {
            let i10 = e10.getLabel();
            e10.getLabel().animate({ opacity: 0 }, { duration: t10 ? 150 : t10, complete: () => {
              i10.hide(), e10.container && e10.container.remove();
            } }), e10.isHidden = true;
          }, t10));
        }
        init(t10, e10) {
          this.chart = t10, this.options = e10, this.crosshairs = [], this.isHidden = true, this.split = e10.split && !t10.inverted && !t10.polar, this.shared = e10.shared || this.split, this.outside = oT(e10.outside, !!(t10.scrollablePixelsX || t10.scrollablePixelsY));
        }
        shouldStickOnContact(t10) {
          return !!(!this.followPointer && this.options.stickOnContact && (!t10 || this.pointer.inClass(t10.target, "highcharts-tooltip")));
        }
        move(t10, e10, i10, s10) {
          let o10 = this, r10 = oh(!o10.isHidden && o10.options.animation), a10 = o10.followPointer || (o10.len || 0) > 1, n10 = { x: t10, y: e10 };
          a10 || (n10.anchorX = i10, n10.anchorY = s10), r10.step = () => o10.drawTracker(), o10.getLabel().animate(n10, r10);
        }
        refresh(t10, e10) {
          let { chart: i10, options: s10, pointer: o10, shared: r10 } = this, a10 = oP(t10), n10 = a10[0], h10 = s10.format, l10 = s10.formatter || this.defaultFormatter, d10 = i10.styledMode, c10 = this.allowShared;
          if (!s10.enabled || !n10.series) return;
          ti.clearTimeout(this.hideTimer), this.allowShared = !(!ok(t10) && t10.series && t10.series.noSharedTooltip), c10 = c10 && !this.allowShared, this.followPointer = !this.split && n10.series.tooltipOptions.followPointer;
          let p10 = this.getAnchor(t10, e10), u2 = p10[0], g2 = p10[1];
          r10 && this.allowShared && (o10.applyInactiveState(a10), a10.forEach((t11) => t11.setState("hover")), n10.points = a10), this.len = a10.length;
          let f2 = oS(h10) ? ol(h10, n10, i10) : l10.call(n10, this);
          n10.points = void 0;
          let m2 = n10.series;
          if (this.distance = oT(m2.tooltipOptions.distance, 16), false === f2) this.hide();
          else {
            if (this.split && this.allowShared) this.renderSplit(f2, a10);
            else {
              let t11 = u2, r11 = g2;
              if (e10 && o10.isDirectTouch && (t11 = e10.chartX - i10.plotLeft, r11 = e10.chartY - i10.plotTop), i10.polar || false === m2.options.clip || a10.some((e11) => o10.isDirectTouch || e11.series.shouldShowTooltip(t11, r11))) {
                let t12 = this.getLabel(c10 && this.tt || {});
                (!s10.style.width || d10) && t12.css({ width: (this.outside ? this.getPlayingField() : i10.spacingBox).width + "px" }), t12.attr({ class: this.getClassName(n10), text: f2 && f2.join ? f2.join("") : f2 }), this.outside && t12.attr({ x: om(t12.x || 0, 0, this.getPlayingField().width - (t12.width || 0) - 1) }), d10 || t12.attr({ stroke: s10.borderColor || n10.color || m2.color || "#666666" }), this.updatePosition({ plotX: u2, plotY: g2, negative: n10.negative, ttBelow: n10.ttBelow, h: p10[2] || 0 });
              } else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({ opacity: 1 }).show(), this.isHidden = false;
          }
          ov(this, "refresh");
        }
        renderSplit(t10, e10) {
          var _a;
          let i10 = this, { chart: s10, chart: { chartWidth: o10, chartHeight: r10, plotHeight: a10, plotLeft: n10, plotTop: h10, scrollablePixelsY: l10 = 0, scrollablePixelsX: d10, styledMode: c10 }, distance: p10, options: u2, options: { positioner: g2 }, pointer: f2 } = i10, { scrollLeft: m2 = 0, scrollTop: x2 = 0 } = ((_a = s10.scrollablePlotArea) == null ? void 0 : _a.scrollingContainer) || {}, y2 = i10.outside && "number" != typeof d10 ? op.documentElement.getBoundingClientRect() : { left: m2, right: m2 + o10, top: x2, bottom: x2 + r10 }, b2 = i10.getLabel(), v2 = this.renderer || s10.renderer, k2 = !!(s10.xAxis[0] && s10.xAxis[0].opposite), { left: M2, top: w2 } = f2.getChartPosition(), S2 = h10 + x2, A2 = 0, T2 = a10 - l10;
          function C2(t11, e11, s11, o11, r11 = true) {
            let a11, n11;
            return s11 ? (a11 = k2 ? 0 : T2, n11 = om(t11 - o11 / 2, y2.left, y2.right - o11 - (i10.outside ? M2 : 0))) : (a11 = e11 - S2, n11 = om(n11 = r11 ? t11 - o11 - p10 : t11 + p10, r11 ? n11 : y2.left, y2.right)), { x: n11, y: a11 };
          }
          oS(t10) && (t10 = [false, t10]);
          let P2 = t10.slice(0, e10.length + 1).reduce(function(t11, s11, o11) {
            if (false !== s11 && "" !== s11) {
              let r11 = e10[o11 - 1] || { isHeader: true, plotX: e10[0].plotX, plotY: a10, series: {} }, l11 = r11.isHeader, d11 = l11 ? i10 : r11.series, f3 = d11.tt = function(t12, e11, s12) {
                let o12 = t12, { isHeader: r12, series: a11 } = e11;
                if (!o12) {
                  let t13 = { padding: u2.padding, r: u2.borderRadius };
                  c10 || (t13.fill = u2.backgroundColor, t13["stroke-width"] = u2.borderWidth ?? 1), o12 = v2.label("", 0, 0, u2[r12 ? "headerShape" : "shape"], void 0, void 0, u2.useHTML).addClass(i10.getClassName(e11, true, r12)).attr(t13).add(b2);
                }
                return o12.isActive = true, o12.attr({ text: s12 }), c10 || o12.css(u2.style).attr({ stroke: u2.borderColor || e11.color || a11.color || "#333333" }), o12;
              }(d11.tt, r11, s11.toString()), m3 = f3.getBBox(), x3 = m3.width + f3.strokeWidth();
              l11 && (A2 = m3.height, T2 += A2, k2 && (S2 -= A2));
              let { anchorX: M3, anchorY: w3 } = function(t12) {
                let e11, i11;
                let { isHeader: s12, plotX: o12 = 0, plotY: r12 = 0, series: l12 } = t12;
                if (s12) e11 = Math.max(n10 + o12, n10), i11 = h10 + a10 / 2;
                else {
                  let { xAxis: t13, yAxis: s13 } = l12;
                  e11 = t13.pos + om(o12, -p10, t13.len + p10), l12.shouldShowTooltip(0, s13.pos - h10 + r12, { ignoreX: true }) && (i11 = s13.pos + r12);
                }
                return { anchorX: e11 = om(e11, y2.left - p10, y2.right + p10), anchorY: i11 };
              }(r11);
              if ("number" == typeof w3) {
                let e11 = m3.height + 1, s12 = g2 ? g2.call(i10, x3, e11, r11) : C2(M3, w3, l11, x3);
                t11.push({ align: g2 ? 0 : void 0, anchorX: M3, anchorY: w3, boxWidth: x3, point: r11, rank: oT(s12.rank, l11 ? 1 : 0), size: e11, target: s12.y, tt: f3, x: s12.x });
              } else f3.isActive = false;
            }
            return t11;
          }, []);
          !g2 && P2.some((t11) => {
            let { outside: e11 } = i10, s11 = (e11 ? M2 : 0) + t11.anchorX;
            return s11 < y2.left && s11 + t11.boxWidth < y2.right || s11 < M2 - y2.left + t11.boxWidth && y2.right - s11 > s11;
          }) && (P2 = P2.map((t11) => {
            let { x: e11, y: i11 } = C2(t11.anchorX, t11.anchorY, t11.point.isHeader, t11.boxWidth, false);
            return ob(t11, { target: i11, x: e11 });
          })), i10.cleanSplit(), og(P2, T2);
          let O2 = { left: M2, right: M2 };
          P2.forEach(function(t11) {
            let { x: e11, boxWidth: s11, isHeader: o11 } = t11;
            !o11 && (i10.outside && M2 + e11 < O2.left && (O2.left = M2 + e11), !o11 && i10.outside && O2.left + s11 > O2.right && (O2.right = M2 + e11));
          }), P2.forEach(function(t11) {
            let { x: e11, anchorX: s11, anchorY: o11, pos: r11, point: { isHeader: a11 } } = t11, n11 = { visibility: void 0 === r11 ? "hidden" : "inherit", x: e11, y: (r11 || 0) + S2, anchorX: s11, anchorY: o11 };
            if (i10.outside && e11 < s11) {
              let t12 = M2 - O2.left;
              t12 > 0 && (a11 || (n11.x = e11 + t12, n11.anchorX = s11 + t12), a11 && (n11.x = (O2.right - O2.left) / 2, n11.anchorX = s11 + t12));
            }
            t11.tt.attr(n11);
          });
          let { container: E2, outside: L2, renderer: D2 } = i10;
          if (L2 && E2 && D2) {
            let { width: t11, height: e11, x: i11, y: s11 } = b2.getBBox();
            D2.setSize(t11 + i11, e11 + s11, false), E2.style.left = O2.left + "px", E2.style.top = w2 + "px";
          }
          ou && b2.attr({ opacity: 1 === b2.opacity ? 0.999 : 1 });
        }
        drawTracker() {
          if (!this.shouldStickOnContact()) {
            this.tracker && (this.tracker = this.tracker.destroy());
            return;
          }
          let t10 = this.chart, e10 = this.label, i10 = this.shared ? t10.hoverPoints : t10.hoverPoint;
          if (!e10 || !i10) return;
          let s10 = { x: 0, y: 0, width: 0, height: 0 }, o10 = this.getAnchor(i10), r10 = e10.getBBox();
          o10[0] += t10.plotLeft - (e10.translateX || 0), o10[1] += t10.plotTop - (e10.translateY || 0), s10.x = Math.min(0, o10[0]), s10.y = Math.min(0, o10[1]), s10.width = o10[0] < 0 ? Math.max(Math.abs(o10[0]), r10.width - o10[0]) : Math.max(Math.abs(o10[0]), r10.width), s10.height = o10[1] < 0 ? Math.max(Math.abs(o10[1]), r10.height - Math.abs(o10[1])) : Math.max(Math.abs(o10[1]), r10.height), this.tracker ? this.tracker.attr(s10) : (this.tracker = e10.renderer.rect(s10).addClass("highcharts-tracker").add(e10), t10.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
        }
        styledModeFormat(t10) {
          return t10.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
        }
        headerFooterFormatter(t10, e10) {
          let i10 = t10.series, s10 = i10.tooltipOptions, o10 = i10.xAxis, r10 = o10 && o10.dateTime, a10 = { isFooter: e10, point: t10 }, n10 = s10.xDateFormat || "", h10 = s10[e10 ? "footerFormat" : "headerFormat"];
          return ov(this, "headerFormatter", a10, function(e11) {
            if (r10 && !n10 && oM(t10.key) && (n10 = r10.getXDateFormat(t10.key, s10.dateTimeLabelFormats)), r10 && n10) {
              if (ow(n10)) {
                let t11 = n10;
                oc[0] = (e12) => i10.chart.time.dateFormat(t11, e12), n10 = "%0";
              }
              (t10.tooltipDateKeys || ["key"]).forEach((t11) => {
                h10 = h10.replace(RegExp("point\\." + t11 + "([ \\)}])", ""), `(point.${t11}:${n10})$1`);
              });
            }
            i10.chart.styledMode && (h10 = this.styledModeFormat(h10)), e11.text = ol(h10, t10, this.chart);
          }), a10.text || "";
        }
        update(t10) {
          this.destroy(), this.init(this.chart, oA(true, this.options, t10));
        }
        updatePosition(t10) {
          let { chart: e10, container: i10, distance: s10, options: o10, pointer: r10, renderer: a10 } = this, { height: n10 = 0, width: h10 = 0 } = this.getLabel(), { left: l10, top: d10, scaleX: c10, scaleY: p10 } = r10.getChartPosition(), u2 = (o10.positioner || this.getPosition).call(this, h10, n10, t10), g2 = L.doc, f2 = (t10.plotX || 0) + e10.plotLeft, m2 = (t10.plotY || 0) + e10.plotTop, x2;
          a10 && i10 && (o10.positioner && (u2.x += l10 - s10, u2.y += d10 - s10), x2 = (o10.borderWidth || 0) + 2 * s10 + 2, a10.setSize(om(h10 + x2, 0, g2.documentElement.clientWidth) - 1, n10 + x2, false), (1 !== c10 || 1 !== p10) && (ox(i10, { transform: `scale(${c10}, ${p10})` }), f2 *= c10, m2 *= p10), f2 += l10 - u2.x, m2 += d10 - u2.y), this.move(Math.round(u2.x), Math.round(u2.y || 0), f2, m2);
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          oC(od, "Core.Tooltip") && of(e10, "afterInit", function() {
            let e11 = this.chart;
            e11.options.tooltip && (e11.tooltip = new t10(e11, e11.options.tooltip, this));
          });
        };
      }(oE || (oE = {}));
      let oL = oE, { animObject: oD } = t_, { defaultOptions: oB } = tT, { format: oI } = eg, { addEvent: oz, crisp: oR, erase: oN, extend: oW, fireEvent: oG, getNestedProperty: oX, isArray: oH, isFunction: oF, isNumber: oY, isObject: oj, merge: oU, pick: oV, syncTimeout: o_, removeEvent: o$, uniqueKey: oZ } = ti;
      class oq {
        animateBeforeDestroy() {
          let t10 = this, e10 = { x: t10.startXPos, opacity: 0 }, i10 = t10.getGraphicalProps();
          i10.singular.forEach(function(i11) {
            t10[i11] = t10[i11].animate("dataLabel" === i11 ? { x: t10[i11].startXPos, y: t10[i11].startYPos, opacity: 0 } : e10);
          }), i10.plural.forEach(function(e11) {
            t10[e11].forEach(function(e12) {
              e12.element && e12.animate(oW({ x: t10.startXPos }, e12.startYPos ? { x: e12.startXPos, y: e12.startYPos } : {}));
            });
          });
        }
        applyOptions(t10, e10) {
          let i10 = this.series, s10 = i10.options.pointValKey || i10.pointValKey;
          return oW(this, t10 = oq.prototype.optionsToObject.call(this, t10)), this.options = this.options ? oW(this.options, t10) : t10, t10.group && delete this.group, t10.dataLabels && delete this.dataLabels, s10 && (this.y = oq.prototype.getNestedProperty.call(this, s10)), this.selected && (this.state = "select"), "name" in this && void 0 === e10 && i10.xAxis && i10.xAxis.hasNames && (this.x = i10.xAxis.nameToX(this)), void 0 === this.x && i10 ? this.x = e10 ?? i10.autoIncrement() : oY(t10.x) && i10.options.relativeXValue ? this.x = i10.autoIncrement(t10.x) : "string" == typeof this.x && (e10 ?? (e10 = i10.chart.time.parse(this.x)), oY(e10) && (this.x = e10)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
        }
        destroy() {
          if (!this.destroyed) {
            let t10 = this, e10 = t10.series, i10 = e10.chart, s10 = e10.options.dataSorting, o10 = i10.hoverPoints, r10 = oD(t10.series.chart.renderer.globalAnimation), a10 = () => {
              for (let e11 in (t10.graphic || t10.graphics || t10.dataLabel || t10.dataLabels) && (o$(t10), t10.destroyElements()), t10) delete t10[e11];
            };
            t10.legendItem && i10.legend.destroyItem(t10), o10 && (t10.setState(), oN(o10, t10), o10.length || (i10.hoverPoints = null)), t10 === i10.hoverPoint && t10.onMouseOut(), s10 && s10.enabled ? (this.animateBeforeDestroy(), o_(a10, r10.duration)) : a10(), i10.pointCount--;
          }
          this.destroyed = true;
        }
        destroyElements(t10) {
          let e10 = this, i10 = e10.getGraphicalProps(t10);
          i10.singular.forEach(function(t11) {
            e10[t11] = e10[t11].destroy();
          }), i10.plural.forEach(function(t11) {
            e10[t11].forEach(function(t12) {
              t12 && t12.element && t12.destroy();
            }), delete e10[t11];
          });
        }
        firePointEvent(t10, e10, i10) {
          let s10 = this, o10 = this.series.options;
          s10.manageEvent(t10), "click" === t10 && o10.allowPointSelect && (i10 = function(t11) {
            !s10.destroyed && s10.select && s10.select(null, t11.ctrlKey || t11.metaKey || t11.shiftKey);
          }), oG(s10, t10, e10, i10);
        }
        getClassName() {
          return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
        }
        getGraphicalProps(t10) {
          let e10, i10;
          let s10 = this, o10 = [], r10 = { singular: [], plural: [] };
          for ((t10 = t10 || { graphic: 1, dataLabel: 1 }).graphic && o10.push("graphic", "connector"), t10.dataLabel && o10.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i10 = o10.length; i10--; ) s10[e10 = o10[i10]] && r10.singular.push(e10);
          return ["graphic", "dataLabel"].forEach(function(e11) {
            let i11 = e11 + "s";
            t10[e11] && s10[i11] && r10.plural.push(i11);
          }), r10;
        }
        getNestedProperty(t10) {
          return t10 ? 0 === t10.indexOf("custom.") ? oX(t10, this.options) : this[t10] : void 0;
        }
        getZone() {
          let t10 = this.series, e10 = t10.zones, i10 = t10.zoneAxis || "y", s10, o10 = 0;
          for (s10 = e10[0]; this[i10] >= s10.value; ) s10 = e10[++o10];
          return this.nonZonedColor || (this.nonZonedColor = this.color), s10 && s10.color && !this.options.color ? this.color = s10.color : this.color = this.nonZonedColor, s10;
        }
        hasNewShapeType() {
          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
        }
        constructor(t10, e10, i10) {
          this.formatPrefix = "point", this.visible = true, this.point = this, this.series = t10, this.applyOptions(e10, i10), this.id ?? (this.id = oZ()), this.resolveColor(), t10.chart.pointCount++, oG(this, "afterInit");
        }
        isValid() {
          return (oY(this.x) || this.x instanceof Date) && oY(this.y);
        }
        optionsToObject(t10) {
          var _a;
          let e10 = this.series, i10 = e10.options.keys, s10 = i10 || e10.pointArrayMap || ["y"], o10 = s10.length, r10 = {}, a10, n10 = 0, h10 = 0;
          if (oY(t10) || null === t10) r10[s10[0]] = t10;
          else if (oH(t10)) for (!i10 && t10.length > o10 && ("string" == (a10 = typeof t10[0]) ? ((_a = e10.xAxis) == null ? void 0 : _a.dateTime) ? r10.x = e10.chart.time.parse(t10[0]) : r10.name = t10[0] : "number" === a10 && (r10.x = t10[0]), n10++); h10 < o10; ) i10 && void 0 === t10[n10] || (s10[h10].indexOf(".") > 0 ? oq.prototype.setNestedProperty(r10, t10[n10], s10[h10]) : r10[s10[h10]] = t10[n10]), n10++, h10++;
          else "object" == typeof t10 && (r10 = t10, t10.dataLabels && (e10.hasDataLabels = () => true), t10.marker && (e10._hasPointMarkers = true));
          return r10;
        }
        pos(t10, e10 = this.plotY) {
          if (!this.destroyed) {
            let { plotX: i10, series: s10 } = this, { chart: o10, xAxis: r10, yAxis: a10 } = s10, n10 = 0, h10 = 0;
            if (oY(i10) && oY(e10)) return t10 && (n10 = r10 ? r10.pos : o10.plotLeft, h10 = a10 ? a10.pos : o10.plotTop), o10.inverted && r10 && a10 ? [a10.len - e10 + h10, r10.len - i10 + n10] : [i10 + n10, e10 + h10];
          }
        }
        resolveColor() {
          let t10 = this.series, e10 = t10.chart.options.chart, i10 = t10.chart.styledMode, s10, o10, r10 = e10.colorCount, a10;
          delete this.nonZonedColor, t10.options.colorByPoint ? (i10 || (s10 = (o10 = t10.options.colors || t10.chart.options.colors)[t10.colorCounter], r10 = o10.length), a10 = t10.colorCounter, t10.colorCounter++, t10.colorCounter === r10 && (t10.colorCounter = 0)) : (i10 || (s10 = t10.color), a10 = t10.colorIndex), this.colorIndex = oV(this.options.colorIndex, a10), this.color = oV(this.options.color, s10);
        }
        setNestedProperty(t10, e10, i10) {
          return i10.split(".").reduce(function(t11, i11, s10, o10) {
            let r10 = o10.length - 1 === s10;
            return t11[i11] = r10 ? e10 : oj(t11[i11], true) ? t11[i11] : {}, t11[i11];
          }, t10), t10;
        }
        shouldDraw() {
          return !this.isNull;
        }
        tooltipFormatter(t10) {
          var _a;
          let { chart: e10, pointArrayMap: i10 = ["y"], tooltipOptions: s10 } = this.series, { valueDecimals: o10 = "", valuePrefix: r10 = "", valueSuffix: a10 = "" } = s10;
          return e10.styledMode && (t10 = ((_a = e10.tooltip) == null ? void 0 : _a.styledModeFormat(t10)) || t10), i10.forEach((e11) => {
            e11 = "{point." + e11, (r10 || a10) && (t10 = t10.replace(RegExp(e11 + "}", "g"), r10 + e11 + "}" + a10)), t10 = t10.replace(RegExp(e11 + "}", "g"), e11 + ":,." + o10 + "f}");
          }), oI(t10, this, e10);
        }
        update(t10, e10, i10, s10) {
          let o10;
          let r10 = this, a10 = r10.series, n10 = r10.graphic, h10 = a10.chart, l10 = a10.options;
          function d10() {
            r10.applyOptions(t10);
            let s11 = n10 && r10.hasMockGraphic, d11 = null === r10.y ? !s11 : s11;
            n10 && d11 && (r10.graphic = n10.destroy(), delete r10.hasMockGraphic), oj(t10, true) && (n10 && n10.element && t10 && t10.marker && void 0 !== t10.marker.symbol && (r10.graphic = n10.destroy()), (t10 == null ? void 0 : t10.dataLabels) && r10.dataLabel && (r10.dataLabel = r10.dataLabel.destroy())), o10 = r10.index;
            let c10 = {};
            for (let t11 of a10.dataColumnKeys()) c10[t11] = r10[t11];
            a10.dataTable.setRow(c10, o10), l10.data[o10] = oj(l10.data[o10], true) || oj(t10, true) ? r10.options : oV(t10, l10.data[o10]), a10.isDirty = a10.isDirtyData = true, !a10.fixedBox && a10.hasCartesianSeries && (h10.isDirtyBox = true), "point" === l10.legendType && (h10.isDirtyLegend = true), e10 && h10.redraw(i10);
          }
          e10 = oV(e10, true), false === s10 ? d10() : r10.firePointEvent("update", { options: t10 }, d10);
        }
        remove(t10, e10) {
          this.series.removePoint(this.series.data.indexOf(this), t10, e10);
        }
        select(t10, e10) {
          let i10 = this, s10 = i10.series, o10 = s10.chart;
          t10 = oV(t10, !i10.selected), this.selectedStaging = t10, i10.firePointEvent(t10 ? "select" : "unselect", { accumulate: e10 }, function() {
            i10.selected = i10.options.selected = t10, s10.options.data[s10.data.indexOf(i10)] = i10.options, i10.setState(t10 && "select"), e10 || o10.getSelectedPoints().forEach(function(t11) {
              let e11 = t11.series;
              t11.selected && t11 !== i10 && (t11.selected = t11.options.selected = false, e11.options.data[e11.data.indexOf(t11)] = t11.options, t11.setState(o10.hoverPoints && e11.options.inactiveOtherPoints ? "inactive" : ""), t11.firePointEvent("unselect"));
            });
          }), delete this.selectedStaging;
        }
        onMouseOver(t10) {
          let { inverted: e10, pointer: i10 } = this.series.chart;
          i10 && (t10 = t10 ? i10.normalize(t10) : i10.getChartCoordinatesFromPoint(this, e10), i10.runPointActions(t10, this));
        }
        onMouseOut() {
          let t10 = this.series.chart;
          this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t10.hoverPoints || []).forEach(function(t11) {
            t11.setState();
          }), t10.hoverPoints = t10.hoverPoint = null;
        }
        manageEvent(t10) {
          var _a, _b, _c, _d, _e, _f, _g;
          let e10 = oU(this.series.options.point, this.options), i10 = (_a = e10.events) == null ? void 0 : _a[t10];
          oF(i10) && (!((_b = this.hcEvents) == null ? void 0 : _b[t10]) || ((_d = (_c = this.hcEvents) == null ? void 0 : _c[t10]) == null ? void 0 : _d.map((t11) => t11.fn).indexOf(i10)) === -1) ? ((_e = this.importedUserEvent) == null ? void 0 : _e.call(this), this.importedUserEvent = oz(this, t10, i10), this.hcEvents && (this.hcEvents[t10].userEvent = true)) : this.importedUserEvent && !i10 && ((_f = this.hcEvents) == null ? void 0 : _f[t10]) && ((_g = this.hcEvents) == null ? void 0 : _g[t10].userEvent) && (o$(this, t10), delete this.hcEvents[t10], Object.keys(this.hcEvents) || delete this.importedUserEvent);
        }
        setState(t10, e10) {
          var _a;
          let i10 = this.series, s10 = this.state, o10 = i10.options.states[t10 || "normal"] || {}, r10 = oB.plotOptions[i10.type].marker && i10.options.marker, a10 = r10 && false === r10.enabled, n10 = r10 && r10.states && r10.states[t10 || "normal"] || {}, h10 = false === n10.enabled, l10 = this.marker || {}, d10 = i10.chart, c10 = r10 && i10.markerAttribs, p10 = i10.halo, u2, g2, f2, m2 = i10.stateMarkerGraphic, x2;
          if ((t10 = t10 || "") === this.state && !e10 || this.selected && "select" !== t10 || false === o10.enabled || t10 && (h10 || a10 && false === n10.enabled) || t10 && l10.states && l10.states[t10] && false === l10.states[t10].enabled) return;
          if (this.state = t10, c10 && (u2 = i10.markerAttribs(this, t10)), this.graphic && !this.hasMockGraphic) {
            if (s10 && this.graphic.removeClass("highcharts-point-" + s10), t10 && this.graphic.addClass("highcharts-point-" + t10), !d10.styledMode) {
              g2 = i10.pointAttribs(this, t10), f2 = oV(d10.options.chart.animation, o10.animation);
              let e11 = g2.opacity;
              i10.options.inactiveOtherPoints && oY(e11) && (this.dataLabels || []).forEach(function(t11) {
                t11 && !t11.hasClass("highcharts-data-label-hidden") && (t11.animate({ opacity: e11 }, f2), t11.connector && t11.connector.animate({ opacity: e11 }, f2));
              }), this.graphic.animate(g2, f2);
            }
            u2 && this.graphic.animate(u2, oV(d10.options.chart.animation, n10.animation, r10.animation)), m2 && m2.hide();
          } else t10 && n10 && (x2 = l10.symbol || i10.symbol, m2 && m2.currentSymbol !== x2 && (m2 = m2.destroy()), u2 && (m2 ? m2[e10 ? "animate" : "attr"]({ x: u2.x, y: u2.y }) : x2 && (i10.stateMarkerGraphic = m2 = d10.renderer.symbol(x2, u2.x, u2.y, u2.width, u2.height, oU(r10, n10)).add(i10.markerGroup), m2.currentSymbol = x2)), !d10.styledMode && m2 && "inactive" !== this.state && m2.attr(i10.pointAttribs(this, t10))), m2 && (m2[t10 && this.isInside ? "show" : "hide"](), m2.element.point = this, m2.addClass(this.getClassName(), true));
          let y2 = o10.halo, b2 = this.graphic || m2, v2 = b2 && b2.visibility || "inherit";
          y2 && y2.size && b2 && "hidden" !== v2 && !this.isCluster ? (p10 || (i10.halo = p10 = d10.renderer.path().add(b2.parentGroup)), p10.show()[e10 ? "animate" : "attr"]({ d: this.haloPath(y2.size) }), p10.attr({ class: "highcharts-halo highcharts-color-" + oV(this.colorIndex, i10.colorIndex) + (this.className ? " " + this.className : ""), visibility: v2, zIndex: -1 }), p10.point = this, d10.styledMode || p10.attr(oW({ fill: this.color || i10.color, "fill-opacity": y2.opacity }, t4.filterUserAttributes(y2.attributes || {})))) : ((_a = p10 == null ? void 0 : p10.point) == null ? void 0 : _a.haloPath) && !p10.point.destroyed && p10.animate({ d: p10.point.haloPath(0) }, null, p10.hide), oG(this, "afterSetState", { state: t10 });
        }
        haloPath(t10) {
          let e10 = this.pos();
          return e10 ? this.series.chart.renderer.symbols.circle(oR(e10[0], 1) - t10, e10[1] - t10, 2 * t10, 2 * t10) : [];
        }
      }
      let oK = oq, { parse: oJ } = tL, { charts: oQ, composed: o0, isTouchDevice: o1 } = L, { addEvent: o2, attr: o3, css: o5, extend: o6, find: o9, fireEvent: o4, isNumber: o8, isObject: o7, objectEach: rt, offset: re, pick: ri, pushUnique: rs, splat: ro } = ti;
      class rr {
        applyInactiveState(t10) {
          let e10 = [], i10;
          (t10 || []).forEach(function(t11) {
            i10 = t11.series, e10.push(i10), i10.linkedParent && e10.push(i10.linkedParent), i10.linkedSeries && (e10 = e10.concat(i10.linkedSeries)), i10.navigatorSeries && e10.push(i10.navigatorSeries);
          }), this.chart.series.forEach(function(t11) {
            -1 === e10.indexOf(t11) ? t11.setState("inactive", true) : t11.options.inactiveOtherPoints && t11.setAllPointsToState("inactive");
          });
        }
        destroy() {
          let t10 = this;
          this.eventsToUnbind.forEach((t11) => t11()), this.eventsToUnbind = [], !L.chartCount && (rr.unbindDocumentMouseUp.forEach((t11) => t11.unbind()), rr.unbindDocumentMouseUp.length = 0, rr.unbindDocumentTouchEnd && (rr.unbindDocumentTouchEnd = rr.unbindDocumentTouchEnd())), clearInterval(t10.tooltipTimeout), rt(t10, function(e10, i10) {
            t10[i10] = void 0;
          });
        }
        getSelectionMarkerAttrs(t10, e10) {
          let i10 = { args: { chartX: t10, chartY: e10 }, attrs: {}, shapeType: "rect" };
          return o4(this, "getSelectionMarkerAttrs", i10, (i11) => {
            let s10;
            let { chart: o10, zoomHor: r10, zoomVert: a10 } = this, { mouseDownX: n10 = 0, mouseDownY: h10 = 0 } = o10, l10 = i11.attrs;
            l10.x = o10.plotLeft, l10.y = o10.plotTop, l10.width = r10 ? 1 : o10.plotWidth, l10.height = a10 ? 1 : o10.plotHeight, r10 && (s10 = t10 - n10, l10.width = Math.max(1, Math.abs(s10)), l10.x = (s10 > 0 ? 0 : s10) + n10), a10 && (s10 = e10 - h10, l10.height = Math.max(1, Math.abs(s10)), l10.y = (s10 > 0 ? 0 : s10) + h10);
          }), i10;
        }
        drag(t10) {
          let { chart: e10 } = this, { mouseDownX: i10 = 0, mouseDownY: s10 = 0 } = e10, { panning: o10, panKey: r10, selectionMarkerFill: a10 } = e10.options.chart, n10 = e10.plotLeft, h10 = e10.plotTop, l10 = e10.plotWidth, d10 = e10.plotHeight, c10 = o7(o10) ? o10.enabled : o10, p10 = r10 && t10[`${r10}Key`], u2 = t10.chartX, g2 = t10.chartY, f2, m2 = this.selectionMarker;
          if ((!m2 || !m2.touch) && (u2 < n10 ? u2 = n10 : u2 > n10 + l10 && (u2 = n10 + l10), g2 < h10 ? g2 = h10 : g2 > h10 + d10 && (g2 = h10 + d10), this.hasDragged = Math.sqrt(Math.pow(i10 - u2, 2) + Math.pow(s10 - g2, 2)), this.hasDragged > 10)) {
            f2 = e10.isInsidePlot(i10 - n10, s10 - h10, { visiblePlotOnly: true });
            let { shapeType: r11, attrs: l11 } = this.getSelectionMarkerAttrs(u2, g2);
            (e10.hasCartesianSeries || e10.mapView) && this.hasZoom && f2 && !p10 && !m2 && (this.selectionMarker = m2 = e10.renderer[r11](), m2.attr({ class: "highcharts-selection-marker", zIndex: 7 }).add(), e10.styledMode || m2.attr({ fill: a10 || oJ("#334eff").setOpacity(0.25).get() })), m2 && m2.attr(l11), f2 && !m2 && c10 && e10.pan(t10, o10);
          }
        }
        dragStart(t10) {
          let e10 = this.chart;
          e10.mouseIsDown = t10.type, e10.cancelClick = false, e10.mouseDownX = t10.chartX, e10.mouseDownY = t10.chartY;
        }
        getSelectionBox(t10) {
          let e10 = { args: { marker: t10 }, result: t10.getBBox() };
          return o4(this, "getSelectionBox", e10), e10.result;
        }
        drop(t10) {
          let e10;
          let { chart: i10, selectionMarker: s10 } = this;
          for (let t11 of i10.axes) t11.isPanning && (t11.isPanning = false, (t11.options.startOnTick || t11.options.endOnTick || t11.series.some((t12) => t12.boosted)) && (t11.forceRedraw = true, t11.setExtremes(t11.userMin, t11.userMax, false), e10 = true));
          if (e10 && i10.redraw(), s10 && t10) {
            if (this.hasDragged) {
              let e11 = this.getSelectionBox(s10);
              i10.transform({ axes: i10.axes.filter((t11) => t11.zoomEnabled && ("xAxis" === t11.coll && this.zoomX || "yAxis" === t11.coll && this.zoomY)), selection: { originalEvent: t10, xAxis: [], yAxis: [], ...e11 }, from: e11 });
            }
            o8(i10.index) && (this.selectionMarker = s10.destroy());
          }
          i10 && o8(i10.index) && (o5(i10.container, { cursor: i10._cursor }), i10.cancelClick = this.hasDragged > 10, i10.mouseIsDown = false, this.hasDragged = 0, this.pinchDown = []);
        }
        findNearestKDPoint(t10, e10, i10) {
          let s10;
          return t10.forEach(function(t11) {
            let o10 = !(t11.noSharedTooltip && e10) && 0 > t11.options.findNearestPointBy.indexOf("y"), r10 = t11.searchPoint(i10, o10);
            o7(r10, true) && r10.series && (!o7(s10, true) || function(t12, i11) {
              var _a, _b;
              let s11 = t12.distX - i11.distX, o11 = t12.dist - i11.dist, r11 = ((_a = i11.series.group) == null ? void 0 : _a.zIndex) - ((_b = t12.series.group) == null ? void 0 : _b.zIndex);
              return 0 !== s11 && e10 ? s11 : 0 !== o11 ? o11 : 0 !== r11 ? r11 : t12.series.index > i11.series.index ? -1 : 1;
            }(s10, r10) > 0) && (s10 = r10);
          }), s10;
        }
        getChartCoordinatesFromPoint(t10, e10) {
          let { xAxis: i10, yAxis: s10 } = t10.series, o10 = t10.shapeArgs;
          if (i10 && s10) {
            let r10 = t10.clientX ?? t10.plotX ?? 0, a10 = t10.plotY || 0;
            return t10.isNode && o10 && o8(o10.x) && o8(o10.y) && (r10 = o10.x, a10 = o10.y), e10 ? { chartX: s10.len + s10.pos - a10, chartY: i10.len + i10.pos - r10 } : { chartX: r10 + i10.pos, chartY: a10 + s10.pos };
          }
          if (o10 && o10.x && o10.y) return { chartX: o10.x, chartY: o10.y };
        }
        getChartPosition() {
          if (this.chartPosition) return this.chartPosition;
          let { container: t10 } = this.chart, e10 = re(t10);
          this.chartPosition = { left: e10.left, top: e10.top, scaleX: 1, scaleY: 1 };
          let { offsetHeight: i10, offsetWidth: s10 } = t10;
          return s10 > 2 && i10 > 2 && (this.chartPosition.scaleX = e10.width / s10, this.chartPosition.scaleY = e10.height / i10), this.chartPosition;
        }
        getCoordinates(t10) {
          let e10 = { xAxis: [], yAxis: [] };
          for (let i10 of this.chart.axes) e10[i10.isXAxis ? "xAxis" : "yAxis"].push({ axis: i10, value: i10.toValue(t10[i10.horiz ? "chartX" : "chartY"]) });
          return e10;
        }
        getHoverData(t10, e10, i10, s10, o10, r10) {
          let a10 = [], n10 = function(t11) {
            return t11.visible && !(!o10 && t11.directTouch) && ri(t11.options.enableMouseTracking, true);
          }, h10 = e10, l10, d10 = { chartX: r10 ? r10.chartX : void 0, chartY: r10 ? r10.chartY : void 0, shared: o10 };
          o4(this, "beforeGetHoverData", d10), l10 = h10 && !h10.stickyTracking ? [h10] : i10.filter((t11) => t11.stickyTracking && (d10.filter || n10)(t11));
          let c10 = s10 && t10 || !r10 ? t10 : this.findNearestKDPoint(l10, o10, r10);
          return h10 = c10 && c10.series, c10 && (o10 && !h10.noSharedTooltip ? (l10 = i10.filter(function(t11) {
            return d10.filter ? d10.filter(t11) : n10(t11) && !t11.noSharedTooltip;
          })).forEach(function(t11) {
            let e11 = o9(t11.points, function(t12) {
              return t12.x === c10.x && !t12.isNull;
            });
            o7(e11) && (t11.boosted && t11.boost && (e11 = t11.boost.getPoint(e11)), a10.push(e11));
          }) : a10.push(c10)), o4(this, "afterGetHoverData", d10 = { hoverPoint: c10 }), { hoverPoint: d10.hoverPoint, hoverSeries: h10, hoverPoints: a10 };
        }
        getPointFromEvent(t10) {
          let e10 = t10.target, i10;
          for (; e10 && !i10; ) i10 = e10.point, e10 = e10.parentNode;
          return i10;
        }
        onTrackerMouseOut(t10) {
          let e10 = this.chart, i10 = t10.relatedTarget, s10 = e10.hoverSeries;
          this.isDirectTouch = false, !s10 || !i10 || s10.stickyTracking || this.inClass(i10, "highcharts-tooltip") || this.inClass(i10, "highcharts-series-" + s10.index) && this.inClass(i10, "highcharts-tracker") || s10.onMouseOut();
        }
        inClass(t10, e10) {
          let i10 = t10, s10;
          for (; i10; ) {
            if (s10 = o3(i10, "class")) {
              if (-1 !== s10.indexOf(e10)) return true;
              if (-1 !== s10.indexOf("highcharts-container")) return false;
            }
            i10 = i10.parentElement;
          }
        }
        constructor(t10, e10) {
          var _a;
          this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e10, this.chart = t10, this.runChartClick = !!((_a = e10.chart.events) == null ? void 0 : _a.click), this.pinchDown = [], this.setDOMEvents(), o4(this, "afterInit");
        }
        normalize(t10, e10) {
          let i10 = t10.touches, s10 = i10 ? i10.length ? i10.item(0) : ri(i10.changedTouches, t10.changedTouches)[0] : t10;
          e10 || (e10 = this.getChartPosition());
          let o10 = s10.pageX - e10.left, r10 = s10.pageY - e10.top;
          return o6(t10, { chartX: Math.round(o10 /= e10.scaleX), chartY: Math.round(r10 /= e10.scaleY) });
        }
        onContainerClick(t10) {
          let e10 = this.chart, i10 = e10.hoverPoint, s10 = this.normalize(t10), o10 = e10.plotLeft, r10 = e10.plotTop;
          !e10.cancelClick && (i10 && this.inClass(s10.target, "highcharts-tracker") ? (o4(i10.series, "click", o6(s10, { point: i10 })), e10.hoverPoint && i10.firePointEvent("click", s10)) : (o6(s10, this.getCoordinates(s10)), e10.isInsidePlot(s10.chartX - o10, s10.chartY - r10, { visiblePlotOnly: true }) && o4(e10, "click", s10)));
        }
        onContainerMouseDown(t10) {
          var _a;
          let e10 = (1 & (t10.buttons || t10.button)) == 1;
          t10 = this.normalize(t10), L.isFirefox && 0 !== t10.button && this.onContainerMouseMove(t10), (void 0 === t10.button || e10) && (this.zoomOption(t10), e10 && ((_a = t10.preventDefault) == null ? void 0 : _a.call(t10)), this.dragStart(t10));
        }
        onContainerMouseLeave(t10) {
          let { pointer: e10 } = oQ[ri(rr.hoverChartIndex, -1)] || {};
          t10 = this.normalize(t10), this.onContainerMouseMove(t10), e10 && !this.inClass(t10.relatedTarget, "highcharts-tooltip") && (e10.reset(), e10.chartPosition = void 0);
        }
        onContainerMouseEnter() {
          delete this.chartPosition;
        }
        onContainerMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.normalize(t10);
          this.setHoverChartIndex(t10), ("mousedown" === e10.mouseIsDown || this.touchSelect(s10)) && this.drag(s10), !e10.openMenu && (this.inClass(s10.target, "highcharts-tracker") || e10.isInsidePlot(s10.chartX - e10.plotLeft, s10.chartY - e10.plotTop, { visiblePlotOnly: true })) && !(i10 && i10.shouldStickOnContact(s10)) && (this.inClass(s10.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(s10));
        }
        onDocumentTouchEnd(t10) {
          this.onDocumentMouseUp(t10);
        }
        onContainerTouchMove(t10) {
          this.touchSelect(t10) ? this.onContainerMouseMove(t10) : this.touch(t10);
        }
        onContainerTouchStart(t10) {
          this.touchSelect(t10) ? this.onContainerMouseDown(t10) : (this.zoomOption(t10), this.touch(t10, true));
        }
        onDocumentMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.chartPosition, o10 = this.normalize(t10, s10);
          !s10 || e10.isInsidePlot(o10.chartX - e10.plotLeft, o10.chartY - e10.plotTop, { visiblePlotOnly: true }) || i10 && i10.shouldStickOnContact(o10) || o10.target !== e10.container.ownerDocument && this.inClass(o10.target, "highcharts-tracker") || this.reset();
        }
        onDocumentMouseUp(t10) {
          var _a, _b;
          (_b = (_a = oQ[ri(rr.hoverChartIndex, -1)]) == null ? void 0 : _a.pointer) == null ? void 0 : _b.drop(t10);
        }
        pinch(t10) {
          let e10 = this, { chart: i10, hasZoom: s10, lastTouches: o10 } = e10, r10 = [].map.call(t10.touches || [], (t11) => e10.normalize(t11)), a10 = r10.length, n10 = 1 === a10 && (e10.inClass(t10.target, "highcharts-tracker") && i10.runTrackerClick || e10.runChartClick), h10 = i10.tooltip, l10 = 1 === a10 && ri(h10 == null ? void 0 : h10.options.followTouchMove, true);
          a10 > 1 ? e10.initiated = true : l10 && (e10.initiated = false), s10 && e10.initiated && !n10 && false !== t10.cancelable && t10.preventDefault(), "touchstart" === t10.type ? (e10.pinchDown = r10, e10.res = true, i10.mouseDownX = t10.chartX) : l10 ? this.runPointActions(e10.normalize(t10)) : o10 && (o4(i10, "touchpan", { originalEvent: t10, touches: r10 }, () => {
            let e11 = (t11) => {
              let e12 = t11[0], i11 = t11[1] || e12;
              return { x: e12.chartX, y: e12.chartY, width: i11.chartX - e12.chartX, height: i11.chartY - e12.chartY };
            };
            i10.transform({ axes: i10.axes.filter((t11) => t11.zoomEnabled && (this.zoomHor && t11.horiz || this.zoomVert && !t11.horiz)), to: e11(r10), from: e11(o10), trigger: t10.type });
          }), e10.res && (e10.res = false, this.reset(false, 0))), e10.lastTouches = r10;
        }
        reset(t10, e10) {
          let i10 = this.chart, s10 = i10.hoverSeries, o10 = i10.hoverPoint, r10 = i10.hoverPoints, a10 = i10.tooltip, n10 = a10 && a10.shared ? r10 : o10;
          t10 && n10 && ro(n10).forEach(function(e11) {
            e11.series.isCartesian && void 0 === e11.plotX && (t10 = false);
          }), t10 ? a10 && n10 && ro(n10).length && (a10.refresh(n10), a10.shared && r10 ? r10.forEach(function(t11) {
            t11.setState(t11.state, true), t11.series.isCartesian && (t11.series.xAxis.crosshair && t11.series.xAxis.drawCrosshair(null, t11), t11.series.yAxis.crosshair && t11.series.yAxis.drawCrosshair(null, t11));
          }) : o10 && (o10.setState(o10.state, true), i10.axes.forEach(function(t11) {
            t11.crosshair && o10.series[t11.coll] === t11 && t11.drawCrosshair(null, o10);
          }))) : (o10 && o10.onMouseOut(), r10 && r10.forEach(function(t11) {
            t11.setState();
          }), s10 && s10.onMouseOut(), a10 && a10.hide(e10), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i10.axes.forEach(function(t11) {
            t11.hideCrosshair();
          }), i10.hoverPoints = i10.hoverPoint = void 0);
        }
        runPointActions(t10, e10, i10) {
          let s10 = this.chart, o10 = s10.series, r10 = s10.tooltip && s10.tooltip.options.enabled ? s10.tooltip : void 0, a10 = !!r10 && r10.shared, n10 = e10 || s10.hoverPoint, h10 = n10 && n10.series || s10.hoverSeries, l10 = (!t10 || "touchmove" !== t10.type) && (!!e10 || h10 && h10.directTouch && this.isDirectTouch), d10 = this.getHoverData(n10, h10, o10, l10, a10, t10);
          n10 = d10.hoverPoint, h10 = d10.hoverSeries;
          let c10 = d10.hoverPoints, p10 = h10 && h10.tooltipOptions.followPointer && !h10.tooltipOptions.split, u2 = a10 && h10 && !h10.noSharedTooltip;
          if (n10 && (i10 || n10 !== s10.hoverPoint || r10 && r10.isHidden)) {
            if ((s10.hoverPoints || []).forEach(function(t11) {
              -1 === c10.indexOf(t11) && t11.setState();
            }), s10.hoverSeries !== h10 && h10.onMouseOver(), this.applyInactiveState(c10), (c10 || []).forEach(function(t11) {
              t11.setState("hover");
            }), s10.hoverPoint && s10.hoverPoint.firePointEvent("mouseOut"), !n10.series) return;
            s10.hoverPoints = c10, s10.hoverPoint = n10, n10.firePointEvent("mouseOver", void 0, () => {
              r10 && n10 && r10.refresh(u2 ? c10 : n10, t10);
            });
          } else if (p10 && r10 && !r10.isHidden) {
            let e11 = r10.getAnchor([{}], t10);
            s10.isInsidePlot(e11[0], e11[1], { visiblePlotOnly: true }) && r10.updatePosition({ plotX: e11[0], plotY: e11[1] });
          }
          this.unDocMouseMove || (this.unDocMouseMove = o2(s10.container.ownerDocument, "mousemove", (t11) => {
            var _a, _b;
            return (_b = (_a = oQ[rr.hoverChartIndex ?? -1]) == null ? void 0 : _a.pointer) == null ? void 0 : _b.onDocumentMouseMove(t11);
          }), this.eventsToUnbind.push(this.unDocMouseMove)), s10.axes.forEach(function(e11) {
            let i11;
            let o11 = ri((e11.crosshair || {}).snap, true);
            !o11 || (i11 = s10.hoverPoint) && i11.series[e11.coll] === e11 || (i11 = o9(c10, (t11) => t11.series && t11.series[e11.coll] === e11)), i11 || !o11 ? e11.drawCrosshair(t10, i11) : e11.hideCrosshair();
          });
        }
        setDOMEvents() {
          let t10 = this.chart.container, e10 = t10.ownerDocument;
          t10.onmousedown = this.onContainerMouseDown.bind(this), t10.onmousemove = this.onContainerMouseMove.bind(this), t10.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(o2(t10, "mouseenter", this.onContainerMouseEnter.bind(this)), o2(t10, "mouseleave", this.onContainerMouseLeave.bind(this))), rr.unbindDocumentMouseUp.some((t11) => t11.doc === e10) || rr.unbindDocumentMouseUp.push({ doc: e10, unbind: o2(e10, "mouseup", this.onDocumentMouseUp.bind(this)) });
          let i10 = this.chart.renderTo.parentElement;
          for (; i10 && "BODY" !== i10.tagName; ) this.eventsToUnbind.push(o2(i10, "scroll", () => {
            delete this.chartPosition;
          })), i10 = i10.parentElement;
          this.eventsToUnbind.push(o2(t10, "touchstart", this.onContainerTouchStart.bind(this), { passive: false }), o2(t10, "touchmove", this.onContainerTouchMove.bind(this), { passive: false })), rr.unbindDocumentTouchEnd || (rr.unbindDocumentTouchEnd = o2(e10, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false })), this.setPointerCapture(), o2(this.chart, "redraw", this.setPointerCapture.bind(this));
        }
        setPointerCapture() {
          var _a, _b;
          if (!o1) return;
          let t10 = this.pointerCaptureEventsToUnbind, e10 = this.chart, i10 = e10.container, s10 = ri((_a = e10.options.tooltip) == null ? void 0 : _a.followTouchMove, true) && e10.series.some((t11) => t11.options.findNearestPointBy.indexOf("y") > -1);
          !this.hasPointerCapture && s10 ? (t10.push(o2(i10, "pointerdown", (t11) => {
            var _a2, _b2;
            ((_a2 = t11.target) == null ? void 0 : _a2.hasPointerCapture(t11.pointerId)) && ((_b2 = t11.target) == null ? void 0 : _b2.releasePointerCapture(t11.pointerId));
          }), o2(i10, "pointermove", (t11) => {
            var _a2, _b2;
            (_b2 = (_a2 = e10.pointer) == null ? void 0 : _a2.getPointFromEvent(t11)) == null ? void 0 : _b2.onMouseOver(t11);
          })), e10.styledMode || o5(i10, { "touch-action": "none" }), i10.className += " highcharts-no-touch-action", this.hasPointerCapture = true) : this.hasPointerCapture && !s10 && (t10.forEach((t11) => t11()), t10.length = 0, e10.styledMode || o5(i10, { "touch-action": ri((_b = e10.options.chart.style) == null ? void 0 : _b["touch-action"], "manipulation") }), i10.className = i10.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = false);
        }
        setHoverChartIndex(t10) {
          var _a;
          let e10 = this.chart, i10 = L.charts[ri(rr.hoverChartIndex, -1)];
          if (i10 && i10 !== e10) {
            let s10 = { relatedTarget: e10.container };
            t10 && !(t10 == null ? void 0 : t10.relatedTarget) && Object.assign({}, t10, s10), (_a = i10.pointer) == null ? void 0 : _a.onContainerMouseLeave(t10 || s10);
          }
          i10 && i10.mouseIsDown || (rr.hoverChartIndex = e10.index);
        }
        touch(t10, e10) {
          let i10;
          let { chart: s10, pinchDown: o10 = [] } = this;
          this.setHoverChartIndex(), 1 === (t10 = this.normalize(t10)).touches.length ? s10.isInsidePlot(t10.chartX - s10.plotLeft, t10.chartY - s10.plotTop, { visiblePlotOnly: true }) && !s10.openMenu ? (e10 && this.runPointActions(t10), "touchmove" === t10.type && (i10 = !!o10[0] && Math.pow(o10[0].chartX - t10.chartX, 2) + Math.pow(o10[0].chartY - t10.chartY, 2) >= 16), ri(i10, true) && this.pinch(t10)) : e10 && this.reset() : 2 === t10.touches.length && this.pinch(t10);
        }
        touchSelect(t10) {
          return !!(this.chart.zooming.singleTouch && t10.touches && 1 === t10.touches.length);
        }
        zoomOption(t10) {
          let e10 = this.chart, i10 = e10.inverted, s10 = e10.zooming.type || "", o10, r10;
          /touch/.test(t10.type) && (s10 = ri(e10.zooming.pinchType, s10)), this.zoomX = o10 = /x/.test(s10), this.zoomY = r10 = /y/.test(s10), this.zoomHor = o10 && !i10 || r10 && i10, this.zoomVert = r10 && !i10 || o10 && i10, this.hasZoom = o10 || r10;
        }
      }
      rr.unbindDocumentMouseUp = [], function(t10) {
        t10.compose = function(e10) {
          rs(o0, "Core.Pointer") && o2(e10, "beforeRender", function() {
            this.pointer = new t10(this, this.options);
          });
        };
      }(rr || (rr = {}));
      let ra = rr, { fireEvent: rn, isArray: rh, objectEach: rl, uniqueKey: rd } = ti, rc = class {
        constructor(t10 = {}) {
          this.autoId = !t10.id, this.columns = {}, this.id = t10.id || rd(), this.modified = this, this.rowCount = 0, this.versionTag = rd();
          let e10 = 0;
          rl(t10.columns || {}, (t11, i10) => {
            this.columns[i10] = t11.slice(), e10 = Math.max(e10, t11.length);
          }), this.applyRowCount(e10);
        }
        applyRowCount(t10) {
          this.rowCount = t10, rl(this.columns, (e10) => {
            rh(e10) && (e10.length = t10);
          });
        }
        getColumn(t10, e10) {
          return this.columns[t10];
        }
        getColumns(t10, e10) {
          return (t10 || Object.keys(this.columns)).reduce((t11, e11) => (t11[e11] = this.columns[e11], t11), {});
        }
        getRow(t10, e10) {
          return (e10 || Object.keys(this.columns)).map((e11) => {
            var _a;
            return (_a = this.columns[e11]) == null ? void 0 : _a[t10];
          });
        }
        setColumn(t10, e10 = [], i10 = 0, s10) {
          this.setColumns({ [t10]: e10 }, i10, s10);
        }
        setColumns(t10, e10, i10) {
          let s10 = this.rowCount;
          rl(t10, (t11, e11) => {
            this.columns[e11] = t11.slice(), s10 = t11.length;
          }), this.applyRowCount(s10), (i10 == null ? void 0 : i10.silent) || (rn(this, "afterSetColumns"), this.versionTag = rd());
        }
        setRow(t10, e10 = this.rowCount, i10, s10) {
          let { columns: o10 } = this, r10 = i10 ? this.rowCount + 1 : e10 + 1;
          rl(t10, (t11, a10) => {
            let n10 = o10[a10] || (s10 == null ? void 0 : s10.addColumns) !== false && Array(r10);
            n10 && (i10 ? n10.splice(e10, 0, t11) : n10[e10] = t11, o10[a10] = n10);
          }), r10 > this.rowCount && this.applyRowCount(r10), (s10 == null ? void 0 : s10.silent) || (rn(this, "afterSetRows"), this.versionTag = rd());
        }
      }, { extend: rp, merge: ru, pick: rg } = ti;
      !function(t10) {
        function e10(t11, e11, i10) {
          var _a, _b;
          let s10 = this.legendItem = this.legendItem || {}, { chart: o10, options: r10 } = this, { baseline: a10 = 0, symbolWidth: n10, symbolHeight: h10 } = t11, l10 = this.symbol || "circle", d10 = h10 / 2, c10 = o10.renderer, p10 = s10.group, u2 = a10 - Math.round((((_a = t11.fontMetrics) == null ? void 0 : _a.b) || h10) * (i10 ? 0.4 : 0.3)), g2 = {}, f2, m2 = r10.marker, x2 = 0;
          if (o10.styledMode || (g2["stroke-width"] = Math.min(r10.lineWidth || 0, 24), r10.dashStyle ? g2.dashstyle = r10.dashStyle : "square" === r10.linecap || (g2["stroke-linecap"] = "round")), s10.line = c10.path().addClass("highcharts-graph").attr(g2).add(p10), i10 && (s10.area = c10.path().addClass("highcharts-area").add(p10)), g2["stroke-linecap"] && (x2 = Math.min(s10.line.strokeWidth(), n10) / 2), n10) {
            let t12 = [["M", x2, u2], ["L", n10 - x2, u2]];
            s10.line.attr({ d: t12 }), (_b = s10.area) == null ? void 0 : _b.attr({ d: [...t12, ["L", n10 - x2, a10], ["L", x2, a10]] });
          }
          if (m2 && false !== m2.enabled && n10) {
            let t12 = Math.min(rg(m2.radius, d10), d10);
            0 === l10.indexOf("url") && (m2 = ru(m2, { width: h10, height: h10 }), t12 = 0), s10.symbol = f2 = c10.symbol(l10, n10 / 2 - t12, u2 - t12, 2 * t12, 2 * t12, rp({ context: "legend" }, m2)).addClass("highcharts-point").add(p10), f2.isMarker = true;
          }
        }
        t10.areaMarker = function(t11, i10) {
          e10.call(this, t11, i10, true);
        }, t10.lineMarker = e10, t10.rectangle = function(t11, e11) {
          let i10 = e11.legendItem || {}, s10 = t11.options, o10 = t11.symbolHeight, r10 = s10.squareSymbol, a10 = r10 ? o10 : t11.symbolWidth;
          i10.symbol = this.chart.renderer.rect(r10 ? (t11.symbolWidth - o10) / 2 : 0, t11.baseline - o10 + 1, a10, o10, rg(t11.options.symbolRadius, o10 / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(i10.group);
        };
      }(g || (g = {}));
      let rf = g, { defaultOptions: rm } = tT, { extend: rx, extendClass: ry, merge: rb } = ti;
      !function(t10) {
        function e10(e11, i10) {
          let s10 = rm.plotOptions || {}, o10 = i10.defaultOptions, r10 = i10.prototype;
          return r10.type = e11, r10.pointClass || (r10.pointClass = oK), !t10.seriesTypes[e11] && (o10 && (s10[e11] = o10), t10.seriesTypes[e11] = i10, true);
        }
        t10.seriesTypes = L.seriesTypes, t10.registerSeriesType = e10, t10.seriesType = function(i10, s10, o10, r10, a10) {
          let n10 = rm.plotOptions || {};
          if (s10 = s10 || "", n10[i10] = rb(n10[s10], o10), delete t10.seriesTypes[i10], e10(i10, ry(t10.seriesTypes[s10] || function() {
          }, r10)), t10.seriesTypes[i10].prototype.type = i10, a10) {
            class e11 extends oK {
            }
            rx(e11.prototype, a10), t10.seriesTypes[i10].prototype.pointClass = e11;
          }
          return t10.seriesTypes[i10];
        };
      }(f || (f = {}));
      let rv = f, { animObject: rk, setAnimation: rM } = t_, { defaultOptions: rw } = tT, { registerEventOptions: rS } = ss, { svg: rA, win: rT } = L, { seriesTypes: rC } = rv, { arrayMax: rP, arrayMin: rO, clamp: rE, correctFloat: rL, crisp: rD, defined: rB, destroyObjectProperties: rI, diffObjects: rz, erase: rR, error: rN, extend: rW, find: rG, fireEvent: rX, getClosestDistance: rH, getNestedProperty: rF, insertItem: rY, isArray: rj, isNumber: rU, isString: rV, merge: r_, objectEach: r$, pick: rZ, removeEvent: rq, syncTimeout: rK } = ti;
      class rJ {
        constructor() {
          this.zoneAxis = "y";
        }
        init(t10, e10) {
          let i10;
          rX(this, "init", { options: e10 }), this.dataTable ?? (this.dataTable = new rc());
          let s10 = t10.series;
          this.eventsToUnbind = [], this.chart = t10, this.options = this.setOptions(e10);
          let o10 = this.options, r10 = false !== o10.visible;
          this.linkedSeries = [], this.bindAxes(), rW(this, { name: o10.name, state: "", visible: r10, selected: true === o10.selected }), rS(this, o10);
          let a10 = o10.events;
          (a10 && a10.click || o10.point && o10.point.events && o10.point.events.click || o10.allowPointSelect) && (t10.runTrackerClick = true), this.getColor(), this.getSymbol(), this.isCartesian && (t10.hasCartesianSeries = true), s10.length && (i10 = s10[s10.length - 1]), this._i = rZ(i10 && i10._i, -1) + 1, this.opacity = this.options.opacity, t10.orderItems("series", rY(this, s10)), o10.dataSorting && o10.dataSorting.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o10.data, false), rX(this, "afterInit");
        }
        is(t10) {
          return rC[t10] && this instanceof rC[t10];
        }
        bindAxes() {
          let t10;
          let e10 = this, i10 = e10.options, s10 = e10.chart;
          rX(this, "bindAxes", null, function() {
            (e10.axisTypes || []).forEach(function(o10) {
              (s10[o10] || []).forEach(function(s11) {
                t10 = s11.options, (rZ(i10[o10], 0) === s11.index || void 0 !== i10[o10] && i10[o10] === t10.id) && (rY(e10, s11.series), e10[o10] = s11, s11.isDirty = true);
              }), e10[o10] || e10.optionalAxis === o10 || rN(18, true, s10);
            });
          }), rX(this, "afterBindAxes");
        }
        hasData() {
          return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.dataTable.rowCount > 0;
        }
        hasMarkerChanged(t10, e10) {
          let i10 = t10.marker, s10 = e10.marker || {};
          return i10 && (s10.enabled && !i10.enabled || s10.symbol !== i10.symbol || s10.height !== i10.height || s10.width !== i10.width);
        }
        autoIncrement(t10) {
          let e10;
          let i10 = this.options, { pointIntervalUnit: s10, relativeXValue: o10 } = this.options, r10 = this.chart.time, a10 = this.xIncrement ?? r10.parse(i10.pointStart) ?? 0;
          if (this.pointInterval = e10 = rZ(this.pointInterval, i10.pointInterval, 1), o10 && rU(t10) && (e10 *= t10), s10) {
            let t11 = r10.toParts(a10);
            "day" === s10 ? t11[2] += e10 : "month" === s10 ? t11[1] += e10 : "year" === s10 && (t11[0] += e10), e10 = r10.makeTime.apply(r10, t11) - a10;
          }
          return o10 && rU(t10) ? a10 + e10 : (this.xIncrement = a10 + e10, a10);
        }
        setDataSortingOptions() {
          let t10 = this.options;
          rW(this, { requireSorting: false, sorted: false, enabledDataSorting: true, allowDG: false }), rB(t10.pointRange) || (t10.pointRange = 1);
        }
        setOptions(t10) {
          var _a, _b;
          let e10;
          let i10 = this.chart, s10 = i10.options.plotOptions, o10 = i10.userOptions || {}, r10 = r_(t10), a10 = i10.styledMode, n10 = { plotOptions: s10, userOptions: r10 };
          rX(this, "setOptions", n10);
          let h10 = n10.plotOptions[this.type], l10 = o10.plotOptions || {}, d10 = l10.series || {}, c10 = rw.plotOptions[this.type] || {}, p10 = l10[this.type] || {};
          this.userOptions = n10.userOptions;
          let u2 = r_(h10, s10.series, p10, r10);
          this.tooltipOptions = r_(rw.tooltip, (_a = rw.plotOptions.series) == null ? void 0 : _a.tooltip, c10 == null ? void 0 : c10.tooltip, i10.userOptions.tooltip, (_b = l10.series) == null ? void 0 : _b.tooltip, p10.tooltip, r10.tooltip), this.stickyTracking = rZ(r10.stickyTracking, p10.stickyTracking, d10.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || u2.stickyTracking), null === h10.marker && delete u2.marker, this.zoneAxis = u2.zoneAxis || "y";
          let g2 = this.zones = (u2.zones || []).map((t11) => ({ ...t11 }));
          return (u2.negativeColor || u2.negativeFillColor) && !u2.zones && (e10 = { value: u2[this.zoneAxis + "Threshold"] || u2.threshold || 0, className: "highcharts-negative" }, a10 || (e10.color = u2.negativeColor, e10.fillColor = u2.negativeFillColor), g2.push(e10)), g2.length && rB(g2[g2.length - 1].value) && g2.push(a10 ? {} : { color: this.color, fillColor: this.fillColor }), rX(this, "afterSetOptions", { options: u2 }), u2;
        }
        getName() {
          return rZ(this.options.name, "Series " + (this.index + 1));
        }
        getCyclic(t10, e10, i10) {
          let s10, o10;
          let r10 = this.chart, a10 = `${t10}Index`, n10 = `${t10}Counter`, h10 = (i10 == null ? void 0 : i10.length) || r10.options.chart.colorCount;
          !e10 && (rB(o10 = rZ("color" === t10 ? this.options.colorIndex : void 0, this[a10])) ? s10 = o10 : (r10.series.length || (r10[n10] = 0), s10 = r10[n10] % h10, r10[n10] += 1), i10 && (e10 = i10[s10])), void 0 !== s10 && (this[a10] = s10), this[t10] = e10;
        }
        getColor() {
          this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || rw.plotOptions[this.type].color, this.chart.options.colors);
        }
        getPointsCollection() {
          return (this.hasGroupedData ? this.points : this.data) || [];
        }
        getSymbol() {
          let t10 = this.options.marker;
          this.getCyclic("symbol", t10.symbol, this.chart.options.symbols);
        }
        getColumn(t10, e10) {
          return (e10 ? this.dataTable.modified : this.dataTable).getColumn(t10, true) || [];
        }
        findPointIndex(t10, e10) {
          let i10, s10, o10;
          let r10 = t10.id, a10 = t10.x, n10 = this.points, h10 = this.options.dataSorting;
          if (r10) {
            let t11 = this.chart.get(r10);
            t11 instanceof oK && (i10 = t11);
          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
            let e11 = (e12) => !e12.touched && e12.index === t10.index;
            if (h10 && h10.matchByName ? e11 = (e12) => !e12.touched && e12.name === t10.name : this.options.relativeXValue && (e11 = (e12) => !e12.touched && e12.options.x === t10.x), !(i10 = rG(n10, e11))) return;
          }
          return i10 && void 0 !== (o10 = i10 && i10.index) && (s10 = true), void 0 === o10 && rU(a10) && (o10 = this.getColumn("x").indexOf(a10, e10)), -1 !== o10 && void 0 !== o10 && this.cropped && (o10 = o10 >= this.cropStart ? o10 - this.cropStart : o10), !s10 && rU(o10) && n10[o10] && n10[o10].touched && (o10 = void 0), o10;
        }
        updateData(t10, e10) {
          let i10 = this.options, s10 = i10.dataSorting, o10 = this.points, r10 = [], a10 = this.requireSorting, n10 = t10.length === o10.length, h10, l10, d10, c10, p10 = true;
          if (this.xIncrement = null, t10.forEach(function(t11, e11) {
            let l11;
            let d11 = rB(t11) && this.pointClass.prototype.optionsToObject.call({ series: this }, t11) || {}, p11 = d11.x;
            d11.id || rU(p11) ? (-1 === (l11 = this.findPointIndex(d11, c10)) || void 0 === l11 ? r10.push(t11) : o10[l11] && t11 !== i10.data[l11] ? (o10[l11].update(t11, false, null, false), o10[l11].touched = true, a10 && (c10 = l11 + 1)) : o10[l11] && (o10[l11].touched = true), (!n10 || e11 !== l11 || s10 && s10.enabled || this.hasDerivedData) && (h10 = true)) : r10.push(t11);
          }, this), h10) for (l10 = o10.length; l10--; ) (d10 = o10[l10]) && !d10.touched && d10.remove && d10.remove(false, e10);
          else !n10 || s10 && s10.enabled ? p10 = false : (t10.forEach(function(t11, e11) {
            t11 === o10[e11].y || o10[e11].destroyed || o10[e11].update(t11, false, null, false);
          }), r10.length = 0);
          if (o10.forEach(function(t11) {
            t11 && (t11.touched = false);
          }), !p10) return false;
          r10.forEach(function(t11) {
            this.addPoint(t11, false, null, null, false);
          }, this);
          let u2 = this.getColumn("x");
          return null === this.xIncrement && u2.length && (this.xIncrement = rP(u2), this.autoIncrement()), true;
        }
        dataColumnKeys() {
          return ["x", ...this.pointArrayMap || ["y"]];
        }
        setData(t10, e10 = true, i10, s10) {
          var _a, _b;
          let o10 = this.points, r10 = o10 && o10.length || 0, a10 = this.options, n10 = this.chart, h10 = a10.dataSorting, l10 = this.xAxis, d10 = a10.turboThreshold, c10 = this.dataTable, p10 = this.dataColumnKeys(), u2 = this.pointValKey || "y", g2 = (this.pointArrayMap || []).length, f2 = a10.keys, m2, x2, y2 = 0, b2 = 1, v2;
          n10.options.chart.allowMutatingData || (a10.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v2 = r_(true, t10));
          let k2 = (t10 = v2 || t10 || []).length;
          if (h10 && h10.enabled && (t10 = this.sortData(t10)), n10.options.chart.allowMutatingData && false !== s10 && k2 && r10 && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x2 = this.updateData(t10, i10)), !x2) {
            this.xIncrement = null, this.colorCounter = 0;
            let e11 = d10 && k2 > d10;
            if (e11) {
              let i11 = this.getFirstValidPoint(t10), s11 = this.getFirstValidPoint(t10, k2 - 1, -1), o11 = (t11) => !!(rj(t11) && (f2 || rU(t11[0])));
              if (rU(i11) && rU(s11)) {
                let e12 = [], i12 = [];
                for (let s12 of t10) e12.push(this.autoIncrement()), i12.push(s12);
                c10.setColumns({ x: e12, [u2]: i12 });
              } else if (o11(i11) && o11(s11)) {
                if (g2) {
                  let e12 = i11.length === g2 ? 1 : 0, s12 = Array(p10.length).fill(0).map(() => []);
                  for (let i12 of t10) {
                    e12 && s12[0].push(this.autoIncrement());
                    for (let t11 = e12; t11 <= g2; t11++) (_a = s12[t11]) == null ? void 0 : _a.push(i12[t11 - e12]);
                  }
                  c10.setColumns(p10.reduce((t11, e13, i12) => (t11[e13] = s12[i12], t11), {}));
                } else {
                  f2 && (y2 = f2.indexOf("x"), b2 = f2.indexOf("y"), y2 = y2 >= 0 ? y2 : 0, b2 = b2 >= 0 ? b2 : 1), 1 === i11.length && (b2 = 0);
                  let e12 = [], s12 = [];
                  if (y2 === b2) for (let i12 of t10) e12.push(this.autoIncrement()), s12.push(i12[b2]);
                  else for (let i12 of t10) e12.push(i12[y2]), s12.push(i12[b2]);
                  c10.setColumns({ x: e12, [u2]: s12 });
                }
              } else e11 = false;
            }
            if (!e11) {
              let e12 = p10.reduce((t11, e13) => (t11[e13] = [], t11), {});
              for (m2 = 0; m2 < k2; m2++) {
                let i11 = this.pointClass.prototype.applyOptions.apply({ series: this }, [t10[m2]]);
                for (let t11 of p10) e12[t11][m2] = i11[t11];
              }
              c10.setColumns(e12);
            }
            for (rV(this.getColumn("y")[0]) && rN(14, true, n10), this.data = [], this.options.data = this.userOptions.data = t10, m2 = r10; m2--; ) (_b = o10[m2]) == null ? void 0 : _b.destroy();
            l10 && (l10.minRange = l10.userMinRange), this.isDirty = n10.isDirtyBox = true, this.isDirtyData = !!o10, i10 = false;
          }
          "point" === a10.legendType && (this.processData(), this.generatePoints()), e10 && n10.redraw(i10);
        }
        sortData(t10) {
          let e10 = this, i10 = e10.options.dataSorting.sortKey || "y", s10 = function(t11, e11) {
            return rB(e11) && t11.pointClass.prototype.optionsToObject.call({ series: t11 }, e11) || {};
          };
          return t10.forEach(function(i11, o10) {
            t10[o10] = s10(e10, i11), t10[o10].index = o10;
          }, this), t10.concat().sort((t11, e11) => {
            let s11 = rF(i10, t11), o10 = rF(i10, e11);
            return o10 < s11 ? -1 : o10 > s11 ? 1 : 0;
          }).forEach(function(t11, e11) {
            t11.x = e11;
          }, this), e10.linkedSeries && e10.linkedSeries.forEach(function(e11) {
            let i11 = e11.options, o10 = i11.data;
            i11.dataSorting && i11.dataSorting.enabled || !o10 || (o10.forEach(function(i12, r10) {
              o10[r10] = s10(e11, i12), t10[r10] && (o10[r10].x = t10[r10].x, o10[r10].index = r10);
            }), e11.setData(o10, false));
          }), t10;
        }
        getProcessedData(t10) {
          let e10 = this, { dataTable: i10, isCartesian: s10, options: o10, xAxis: r10 } = e10, a10 = o10.cropThreshold, n10 = t10 || e10.getExtremesFromAll, h10 = r10 == null ? void 0 : r10.logarithmic, l10 = i10.rowCount, d10, c10, p10 = 0, u2, g2, f2, m2 = e10.getColumn("x"), x2 = i10, y2 = false;
          return r10 && (g2 = (u2 = r10.getExtremes()).min, f2 = u2.max, y2 = !!(r10.categories && !r10.names.length), s10 && e10.sorted && !n10 && (!a10 || l10 > a10 || e10.forceCrop) && (m2[l10 - 1] < g2 || m2[0] > f2 ? x2 = new rc() : e10.getColumn(e10.pointValKey || "y").length && (m2[0] < g2 || m2[l10 - 1] > f2) && (x2 = (d10 = this.cropData(i10, g2, f2)).modified, p10 = d10.start, c10 = true))), m2 = x2.getColumn("x") || [], { modified: x2, cropped: c10, cropStart: p10, closestPointRange: rH([h10 ? m2.map(h10.log2lin) : m2], () => e10.requireSorting && !y2 && rN(15, false, e10.chart)) };
        }
        processData(t10) {
          let e10 = this.xAxis, i10 = this.dataTable;
          if (this.isCartesian && !this.isDirty && !e10.isDirty && !this.yAxis.isDirty && !t10) return false;
          let s10 = this.getProcessedData();
          i10.modified = s10.modified, this.cropped = s10.cropped, this.cropStart = s10.cropStart, this.closestPointRange = this.basePointRange = s10.closestPointRange, rX(this, "afterProcessData");
        }
        cropData(t10, e10, i10) {
          let s10 = t10.getColumn("x", true) || [], o10 = s10.length, r10 = {}, a10, n10, h10 = 0, l10 = o10;
          for (a10 = 0; a10 < o10; a10++) if (s10[a10] >= e10) {
            h10 = Math.max(0, a10 - 1);
            break;
          }
          for (n10 = a10; n10 < o10; n10++) if (s10[n10] > i10) {
            l10 = n10 + 1;
            break;
          }
          for (let e11 of this.dataColumnKeys()) {
            let i11 = t10.getColumn(e11, true);
            i11 && (r10[e11] = i11.slice(h10, l10));
          }
          return { modified: new rc({ columns: r10 }), start: h10, end: l10 };
        }
        generatePoints() {
          var _a, _b;
          let t10 = this.options, e10 = this.processedData || t10.data, i10 = this.dataTable.modified, s10 = this.getColumn("x", true), o10 = this.pointClass, r10 = i10.rowCount, a10 = this.cropStart || 0, n10 = this.hasGroupedData, h10 = t10.keys, l10 = [], d10 = t10.dataGrouping && t10.dataGrouping.groupAll ? a10 : 0, c10 = (_a = this.xAxis) == null ? void 0 : _a.categories, p10 = this.pointArrayMap || ["y"], u2 = this.dataColumnKeys(), g2, f2, m2, x2, y2 = this.data, b2;
          if (!y2 && !n10) {
            let t11 = [];
            t11.length = (e10 == null ? void 0 : e10.length) || 0, y2 = this.data = t11;
          }
          for (h10 && n10 && (this.options.keys = false), x2 = 0; x2 < r10; x2++) f2 = a10 + x2, n10 ? ((m2 = new o10(this, i10.getRow(x2, u2) || [])).dataGroup = this.groupMap[d10 + x2], ((_b = m2.dataGroup) == null ? void 0 : _b.options) && (m2.options = m2.dataGroup.options, rW(m2, m2.dataGroup.options), delete m2.dataLabels)) : (m2 = y2[f2], b2 = e10 ? e10[f2] : i10.getRow(x2, p10), m2 || void 0 === b2 || (y2[f2] = m2 = new o10(this, b2, s10[x2]))), m2 && (m2.index = n10 ? d10 + x2 : f2, l10[x2] = m2, m2.category = (c10 == null ? void 0 : c10[m2.x]) ?? m2.x, m2.key = m2.name ?? m2.category);
          if (this.options.keys = h10, y2 && (r10 !== (g2 = y2.length) || n10)) for (x2 = 0; x2 < g2; x2++) x2 !== a10 || n10 || (x2 += r10), y2[x2] && (y2[x2].destroyElements(), y2[x2].plotX = void 0);
          this.data = y2, this.points = l10, rX(this, "afterGeneratePoints");
        }
        getXExtremes(t10) {
          return { min: rO(t10), max: rP(t10) };
        }
        getExtremes(t10, e10) {
          var _a;
          let { xAxis: i10, yAxis: s10 } = this, o10 = e10 || this.getExtremesFromAll || this.options.getExtremesFromAll, r10 = o10 && this.cropped ? this.dataTable : this.dataTable.modified, a10 = r10.rowCount, n10 = t10 || this.stackedYData, h10 = n10 ? [n10] : ((_a = this.keysAffectYAxis || this.pointArrayMap || ["y"]) == null ? void 0 : _a.map((t11) => r10.getColumn(t11, true) || [])) || [], l10 = this.getColumn("x", true), d10 = [], c10 = this.requireSorting && !this.is("column") ? 1 : 0, p10 = !!s10 && s10.positiveValuesOnly, u2 = o10 || this.cropped || !i10, g2, f2, m2, x2 = 0, y2 = 0;
          for (i10 && (x2 = (g2 = i10.getExtremes()).min, y2 = g2.max), m2 = 0; m2 < a10; m2++) if (f2 = l10[m2], u2 || (l10[m2 + c10] || f2) >= x2 && (l10[m2 - c10] || f2) <= y2) for (let t11 of h10) {
            let e11 = t11[m2];
            rU(e11) && (e11 > 0 || !p10) && d10.push(e11);
          }
          let b2 = { activeYData: d10, dataMin: rO(d10), dataMax: rP(d10) };
          return rX(this, "afterGetExtremes", { dataExtremes: b2 }), b2;
        }
        applyExtremes() {
          let t10 = this.getExtremes();
          return this.dataMin = t10.dataMin, this.dataMax = t10.dataMax, t10;
        }
        getFirstValidPoint(t10, e10 = 0, i10 = 1) {
          let s10 = t10.length, o10 = e10;
          for (; o10 >= 0 && o10 < s10; ) {
            if (rB(t10[o10])) return t10[o10];
            o10 += i10;
          }
        }
        translate() {
          var _a;
          this.generatePoints();
          let t10 = this.options, e10 = t10.stacking, i10 = this.xAxis, s10 = this.enabledDataSorting, o10 = this.yAxis, r10 = this.points, a10 = r10.length, n10 = this.pointPlacementToXValue(), h10 = !!n10, l10 = t10.threshold, d10 = t10.startFromThreshold ? l10 : 0, c10, p10, u2, g2, f2 = Number.MAX_VALUE;
          function m2(t11) {
            return rE(t11, -1e9, 1e9);
          }
          for (c10 = 0; c10 < a10; c10++) {
            let t11;
            let a11 = r10[c10], x2 = a11.x, y2, b2, v2 = a11.y, k2 = a11.low, M2 = e10 && ((_a = o10.stacking) == null ? void 0 : _a.stacks[(this.negStacks && v2 < (d10 ? 0 : l10) ? "-" : "") + this.stackKey]);
            p10 = i10.translate(x2, false, false, false, true, n10), a11.plotX = rU(p10) ? rL(m2(p10)) : void 0, e10 && this.visible && M2 && M2[x2] && (g2 = this.getStackIndicator(g2, x2, this.index), !a11.isNull && g2.key && (b2 = (y2 = M2[x2]).points[g2.key]), y2 && rj(b2) && (k2 = b2[0], v2 = b2[1], k2 === d10 && g2.key === M2[x2].base && (k2 = rZ(rU(l10) ? l10 : o10.min)), o10.positiveValuesOnly && rB(k2) && k2 <= 0 && (k2 = void 0), a11.total = a11.stackTotal = rZ(y2.total), a11.percentage = rB(a11.y) && y2.total ? a11.y / y2.total * 100 : void 0, a11.stackY = v2, this.irregularWidths || y2.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a11.yBottom = rB(k2) ? m2(o10.translate(k2, false, true, false, true)) : void 0, this.dataModify && (v2 = this.dataModify.modifyValue(v2, c10)), rU(v2) && void 0 !== a11.plotX && (t11 = rU(t11 = o10.translate(v2, false, true, false, true)) ? m2(t11) : void 0), a11.plotY = t11, a11.isInside = this.isPointInside(a11), a11.clientX = h10 ? rL(i10.translate(x2, false, false, false, true, n10)) : p10, a11.negative = (a11.y || 0) < (l10 || 0), a11.isNull || false === a11.visible || (void 0 !== u2 && (f2 = Math.min(f2, Math.abs(p10 - u2))), u2 = p10), a11.zone = this.zones.length ? a11.getZone() : void 0, !a11.graphic && this.group && s10 && (a11.isNew = true);
          }
          this.closestPointRangePx = f2, rX(this, "afterTranslate");
        }
        getValidPoints(t10, e10, i10) {
          let s10 = this.chart;
          return (t10 || this.points || []).filter(function(t11) {
            let { plotX: o10, plotY: r10 } = t11;
            return !!((i10 || !t11.isNull && rU(r10)) && (!e10 || s10.isInsidePlot(o10, r10, { inverted: s10.inverted }))) && false !== t11.visible;
          });
        }
        getClipBox() {
          let { chart: t10, xAxis: e10, yAxis: i10 } = this, { x: s10, y: o10, width: r10, height: a10 } = r_(t10.clipBox);
          return e10 && e10.len !== t10.plotSizeX && (r10 = e10.len), i10 && i10.len !== t10.plotSizeY && (a10 = i10.len), t10.inverted && !this.invertible && ([r10, a10] = [a10, r10]), { x: s10, y: o10, width: r10, height: a10 };
        }
        getSharedClipKey() {
          return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
        }
        setClip() {
          let { chart: t10, group: e10, markerGroup: i10 } = this, s10 = t10.sharedClips, o10 = t10.renderer, r10 = this.getClipBox(), a10 = this.getSharedClipKey(), n10 = s10[a10];
          n10 ? n10.animate(r10) : s10[a10] = n10 = o10.clipRect(r10), e10 && e10.clip(false === this.options.clip ? void 0 : n10), i10 && i10.clip();
        }
        animate(t10) {
          let { chart: e10, group: i10, markerGroup: s10 } = this, o10 = e10.inverted, r10 = rk(this.options.animation), a10 = [this.getSharedClipKey(), r10.duration, r10.easing, r10.defer].join(","), n10 = e10.sharedClips[a10], h10 = e10.sharedClips[a10 + "m"];
          if (t10 && i10) {
            let t11 = this.getClipBox();
            if (n10) n10.attr("height", t11.height);
            else {
              t11.width = 0, o10 && (t11.x = e10.plotHeight), n10 = e10.renderer.clipRect(t11), e10.sharedClips[a10] = n10;
              let i11 = { x: -99, y: -99, width: o10 ? e10.plotWidth + 199 : 99, height: o10 ? 99 : e10.plotHeight + 199 };
              h10 = e10.renderer.clipRect(i11), e10.sharedClips[a10 + "m"] = h10;
            }
            i10.clip(n10), s10 == null ? void 0 : s10.clip(h10);
          } else if (n10 && !n10.hasClass("highcharts-animating")) {
            let t11 = this.getClipBox(), i11 = r10.step;
            ((s10 == null ? void 0 : s10.element.childNodes.length) || e10.series.length > 1) && (r10.step = function(t12, e11) {
              i11 && i11.apply(e11, arguments), "width" === e11.prop && (h10 == null ? void 0 : h10.element) && h10.attr(o10 ? "height" : "width", t12 + 99);
            }), n10.addClass("highcharts-animating").animate(t11, r10);
          }
        }
        afterAnimate() {
          this.setClip(), r$(this.chart.sharedClips, (t10, e10, i10) => {
            t10 && !this.chart.container.querySelector(`[clip-path="url(#${t10.id})"]`) && (t10.destroy(), delete i10[e10]);
          }), this.finishedAnimating = true, rX(this, "afterAnimate");
        }
        drawPoints(t10 = this.points) {
          let e10, i10, s10, o10, r10, a10, n10;
          let h10 = this.chart, l10 = h10.styledMode, { colorAxis: d10, options: c10 } = this, p10 = c10.marker, u2 = this[this.specialGroup || "markerGroup"], g2 = this.xAxis, f2 = rZ(p10.enabled, !g2 || !!g2.isRadial || null, this.closestPointRangePx >= p10.enabledThreshold * p10.radius);
          if (false !== p10.enabled || this._hasPointMarkers) for (e10 = 0; e10 < t10.length; e10++) if (o10 = (s10 = (i10 = t10[e10]).graphic) ? "animate" : "attr", r10 = i10.marker || {}, a10 = !!i10.marker, (f2 && void 0 === r10.enabled || r10.enabled) && !i10.isNull && false !== i10.visible) {
            let t11 = rZ(r10.symbol, this.symbol, "rect");
            n10 = this.markerAttribs(i10, i10.selected && "select"), this.enabledDataSorting && (i10.startXPos = g2.reversed ? -(n10.width || 0) : g2.width);
            let e11 = false !== i10.isInside;
            if (!s10 && e11 && ((n10.width || 0) > 0 || i10.hasImage) && (i10.graphic = s10 = h10.renderer.symbol(t11, n10.x, n10.y, n10.width, n10.height, a10 ? r10 : p10).add(u2), this.enabledDataSorting && h10.hasRendered && (s10.attr({ x: i10.startXPos }), o10 = "animate")), s10 && "animate" === o10 && s10[e11 ? "show" : "hide"](e11).animate(n10), s10) {
              let t12 = this.pointAttribs(i10, l10 || !i10.selected ? void 0 : "select");
              l10 ? d10 && s10.css({ fill: t12.fill }) : s10[o10](t12);
            }
            s10 && s10.addClass(i10.getClassName(), true);
          } else s10 && (i10.graphic = s10.destroy());
        }
        markerAttribs(t10, e10) {
          let i10 = this.options, s10 = i10.marker, o10 = t10.marker || {}, r10 = o10.symbol || s10.symbol, a10 = {}, n10, h10, l10 = rZ(o10.radius, s10 && s10.radius);
          e10 && (n10 = s10.states[e10], l10 = rZ((h10 = o10.states && o10.states[e10]) && h10.radius, n10 && n10.radius, l10 && l10 + (n10 && n10.radiusPlus || 0))), t10.hasImage = r10 && 0 === r10.indexOf("url"), t10.hasImage && (l10 = 0);
          let d10 = t10.pos();
          return rU(l10) && d10 && (i10.crisp && (d10[0] = rD(d10[0], t10.hasImage ? 0 : "rect" === r10 ? (s10 == null ? void 0 : s10.lineWidth) || 0 : 1)), a10.x = d10[0] - l10, a10.y = d10[1] - l10), l10 && (a10.width = a10.height = 2 * l10), a10;
        }
        pointAttribs(t10, e10) {
          let i10 = this.options.marker, s10 = t10 && t10.options, o10 = s10 && s10.marker || {}, r10 = s10 && s10.color, a10 = t10 && t10.color, n10 = t10 && t10.zone && t10.zone.color, h10, l10, d10 = this.color, c10, p10, u2 = rZ(o10.lineWidth, i10.lineWidth), g2 = 1;
          return d10 = r10 || n10 || a10 || d10, c10 = o10.fillColor || i10.fillColor || d10, p10 = o10.lineColor || i10.lineColor || d10, e10 = e10 || "normal", h10 = i10.states[e10] || {}, u2 = rZ((l10 = o10.states && o10.states[e10] || {}).lineWidth, h10.lineWidth, u2 + rZ(l10.lineWidthPlus, h10.lineWidthPlus, 0)), c10 = l10.fillColor || h10.fillColor || c10, { stroke: p10 = l10.lineColor || h10.lineColor || p10, "stroke-width": u2, fill: c10, opacity: g2 = rZ(l10.opacity, h10.opacity, g2) };
        }
        destroy(t10) {
          let e10, i10, s10;
          let o10 = this, r10 = o10.chart, a10 = /AppleWebKit\/533/.test(rT.navigator.userAgent), n10 = o10.data || [];
          for (rX(o10, "destroy", { keepEventsForUpdate: t10 }), this.removeEvents(t10), (o10.axisTypes || []).forEach(function(t11) {
            (s10 = o10[t11]) && s10.series && (rR(s10.series, o10), s10.isDirty = s10.forceRedraw = true);
          }), o10.legendItem && o10.chart.legend.destroyItem(o10), e10 = n10.length; e10--; ) (i10 = n10[e10]) && i10.destroy && i10.destroy();
          for (let t11 of o10.zones) rI(t11, void 0, true);
          ti.clearTimeout(o10.animationTimeout), r$(o10, function(t11, e11) {
            t11 instanceof e0 && !t11.survive && t11[a10 && "group" === e11 ? "hide" : "destroy"]();
          }), r10.hoverSeries === o10 && (r10.hoverSeries = void 0), rR(r10.series, o10), r10.orderItems("series"), r$(o10, function(e11, i11) {
            t10 && "hcEvents" === i11 || delete o10[i11];
          });
        }
        applyZones() {
          let { area: t10, chart: e10, graph: i10, zones: s10, points: o10, xAxis: r10, yAxis: a10, zoneAxis: n10 } = this, { inverted: h10, renderer: l10 } = e10, d10 = this[`${n10}Axis`], { isXAxis: c10, len: p10 = 0, minPointOffset: u2 = 0 } = d10 || {}, g2 = ((i10 == null ? void 0 : i10.strokeWidth()) || 0) / 2 + 1, f2 = (t11, e11 = 0, i11 = 0) => {
            h10 && (i11 = p10 - i11);
            let { translated: s11 = 0, lineClip: o11 } = t11, r11 = i11 - s11;
            o11 == null ? void 0 : o11.push(["L", e11, Math.abs(r11) < g2 ? i11 - g2 * (r11 <= 0 ? -1 : 1) : s11]);
          };
          if (s10.length && (i10 || t10) && d10 && rU(d10.min)) {
            let e11 = d10.getExtremes().max + u2, g3 = (t11) => {
              t11.forEach((e12, i11) => {
                ("M" === e12[0] || "L" === e12[0]) && (t11[i11] = [e12[0], c10 ? p10 - e12[1] : e12[1], c10 ? e12[2] : p10 - e12[2]]);
              });
            };
            if (s10.forEach((t11) => {
              t11.lineClip = [], t11.translated = rE(d10.toPixels(rZ(t11.value, e11), true) || 0, 0, p10);
            }), i10 && !this.showLine && i10.hide(), t10 && t10.hide(), "y" === n10 && o10.length < r10.len) for (let t11 of o10) {
              let { plotX: e12, plotY: i11, zone: o11 } = t11, r11 = o11 && s10[s10.indexOf(o11) - 1];
              o11 && f2(o11, e12, i11), r11 && f2(r11, e12, i11);
            }
            let m2 = [], x2 = d10.toPixels(d10.getExtremes().min - u2, true);
            s10.forEach((e12) => {
              var _a, _b;
              let s11 = e12.lineClip || [], o11 = Math.round(e12.translated || 0);
              r10.reversed && s11.reverse();
              let { clip: n11, simpleClip: d11 } = e12, p11 = 0, u3 = 0, f3 = r10.len, y2 = a10.len;
              c10 ? (p11 = o11, f3 = x2) : (u3 = o11, y2 = x2);
              let b2 = [["M", p11, u3], ["L", f3, u3], ["L", f3, y2], ["L", p11, y2], ["Z"]], v2 = [b2[0], ...s11, b2[1], b2[2], ...m2, b2[3], b2[4]];
              m2 = s11.reverse(), x2 = o11, h10 && (g3(v2), t10 && g3(b2)), n11 ? (n11.animate({ d: v2 }), d11 == null ? void 0 : d11.animate({ d: b2 })) : (n11 = e12.clip = l10.path(v2), t10 && (d11 = e12.simpleClip = l10.path(b2))), i10 && ((_a = e12.graph) == null ? void 0 : _a.clip(n11)), t10 && ((_b = e12.area) == null ? void 0 : _b.clip(d11));
            });
          } else this.visible && (i10 && i10.show(), t10 && t10.show());
        }
        plotGroup(t10, e10, i10, s10, o10) {
          let r10 = this[t10], a10 = !r10, n10 = { visibility: i10, zIndex: s10 || 0.1 };
          return rB(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (n10.opacity = this.opacity), r10 || (this[t10] = r10 = this.chart.renderer.g().add(o10)), r10.addClass("highcharts-" + e10 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (rB(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r10.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true), r10.attr(n10)[a10 ? "attr" : "animate"](this.getPlotBox(e10)), r10;
        }
        getPlotBox(t10) {
          let e10 = this.xAxis, i10 = this.yAxis, s10 = this.chart, o10 = s10.inverted && !s10.polar && e10 && this.invertible && "series" === t10;
          return s10.inverted && (e10 = i10, i10 = this.xAxis), { translateX: e10 ? e10.left : s10.plotLeft, translateY: i10 ? i10.top : s10.plotTop, rotation: o10 ? 90 : 0, rotationOriginX: o10 ? (e10.len - i10.len) / 2 : 0, rotationOriginY: o10 ? (e10.len + i10.len) / 2 : 0, scaleX: o10 ? -1 : 1, scaleY: 1 };
        }
        removeEvents(t10) {
          let { eventsToUnbind: e10 } = this;
          t10 || rq(this), e10.length && (e10.forEach((t11) => {
            t11();
          }), e10.length = 0);
        }
        render() {
          var _a, _b, _c, _d, _e;
          let t10 = this, { chart: e10, options: i10, hasRendered: s10 } = t10, o10 = rk(i10.animation), r10 = t10.visible ? "inherit" : "hidden", a10 = i10.zIndex, n10 = e10.seriesGroup, h10 = t10.finishedAnimating ? 0 : o10.duration;
          rX(this, "render"), t10.plotGroup("group", "series", r10, a10, n10), t10.markerGroup = t10.plotGroup("markerGroup", "markers", r10, a10, n10), false !== i10.clip && t10.setClip(), h10 && ((_a = t10.animate) == null ? void 0 : _a.call(t10, true)), t10.drawGraph && (t10.drawGraph(), t10.applyZones()), t10.visible && t10.drawPoints(), (_b = t10.drawDataLabels) == null ? void 0 : _b.call(t10), (_c = t10.redrawPoints) == null ? void 0 : _c.call(t10), i10.enableMouseTracking && ((_d = t10.drawTracker) == null ? void 0 : _d.call(t10)), h10 && ((_e = t10.animate) == null ? void 0 : _e.call(t10)), s10 || (h10 && o10.defer && (h10 += o10.defer), t10.animationTimeout = rK(() => {
            t10.afterAnimate();
          }, h10 || 0)), t10.isDirty = false, t10.hasRendered = true, rX(t10, "afterRender");
        }
        redraw() {
          let t10 = this.isDirty || this.isDirtyData;
          this.translate(), this.render(), t10 && delete this.kdTree;
        }
        reserveSpace() {
          return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
        }
        searchPoint(t10, e10) {
          let { xAxis: i10, yAxis: s10 } = this, o10 = this.chart.inverted;
          return this.searchKDTree({ clientX: o10 ? i10.len - t10.chartY + i10.pos : t10.chartX - i10.pos, plotY: o10 ? s10.len - t10.chartX + s10.pos : t10.chartY - s10.pos }, e10, t10);
        }
        buildKDTree(t10) {
          this.buildingKdTree = true;
          let e10 = this, i10 = e10.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
          delete e10.kdTree, rK(function() {
            e10.kdTree = function t11(i11, s10, o10) {
              let r10, a10;
              let n10 = i11 == null ? void 0 : i11.length;
              if (n10) return r10 = e10.kdAxisArray[s10 % o10], i11.sort((t12, e11) => (t12[r10] || 0) - (e11[r10] || 0)), { point: i11[a10 = Math.floor(n10 / 2)], left: t11(i11.slice(0, a10), s10 + 1, o10), right: t11(i11.slice(a10 + 1), s10 + 1, o10) };
            }(e10.getValidPoints(void 0, !e10.directTouch), i10, i10), e10.buildingKdTree = false;
          }, e10.options.kdNow || (t10 == null ? void 0 : t10.type) === "touchstart" ? 0 : 1);
        }
        searchKDTree(t10, e10, i10, s10, o10) {
          let r10 = this, [a10, n10] = this.kdAxisArray, h10 = e10 ? "distX" : "dist", l10 = (r10.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, d10 = !!r10.isBubble, c10 = s10 || ((t11, e11, i11) => [(t11[i11] || 0) < (e11[i11] || 0) ? t11 : e11, false]), p10 = o10 || ((t11, e11) => t11 < e11);
          if (this.kdTree || this.buildingKdTree || this.buildKDTree(i10), this.kdTree) return function t11(e11, i11, s11, o11) {
            var _a;
            let l11 = i11.point, u2 = r10.kdAxisArray[s11 % o11], g2 = l11, f2 = false;
            !function(t12, e12) {
              var _a2;
              let i12 = t12[a10], s12 = e12[a10], o12 = rB(i12) && rB(s12) ? i12 - s12 : null, r11 = t12[n10], h11 = e12[n10], l12 = rB(r11) && rB(h11) ? r11 - h11 : 0, c11 = d10 && ((_a2 = e12.marker) == null ? void 0 : _a2.radius) || 0;
              e12.dist = Math.sqrt((o12 && o12 * o12 || 0) + l12 * l12) - c11, e12.distX = rB(o12) ? Math.abs(o12) - c11 : Number.MAX_VALUE;
            }(e11, l11);
            let m2 = (e11[u2] || 0) - (l11[u2] || 0) + (d10 && ((_a = l11.marker) == null ? void 0 : _a.radius) || 0), x2 = m2 < 0 ? "left" : "right", y2 = m2 < 0 ? "right" : "left";
            return i11[x2] && ([g2, f2] = c10(l11, t11(e11, i11[x2], s11 + 1, o11), h10)), i11[y2] && p10(Math.sqrt(m2 * m2), g2[h10], f2) && (g2 = c10(g2, t11(e11, i11[y2], s11 + 1, o11), h10)[0]), g2;
          }(t10, this.kdTree, l10, l10);
        }
        pointPlacementToXValue() {
          let { options: t10, xAxis: e10 } = this, i10 = t10.pointPlacement;
          return "between" === i10 && (i10 = e10.reversed ? -0.5 : 0.5), rU(i10) ? i10 * (t10.pointRange || e10.pointRange) : 0;
        }
        isPointInside(t10) {
          let { chart: e10, xAxis: i10, yAxis: s10 } = this, { plotX: o10 = -1, plotY: r10 = -1 } = t10;
          return r10 >= 0 && r10 <= (s10 ? s10.len : e10.plotHeight) && o10 >= 0 && o10 <= (i10 ? i10.len : e10.plotWidth);
        }
        drawTracker() {
          var _a;
          let t10 = this, e10 = t10.options, i10 = e10.trackByArea, s10 = [].concat((i10 ? t10.areaPath : t10.graphPath) || []), o10 = t10.chart, r10 = o10.pointer, a10 = o10.renderer, n10 = ((_a = o10.options.tooltip) == null ? void 0 : _a.snap) || 0, h10 = () => {
            e10.enableMouseTracking && o10.hoverSeries !== t10 && t10.onMouseOver();
          }, l10 = "rgba(192,192,192," + (rA ? 1e-4 : 2e-3) + ")", d10 = t10.tracker;
          d10 ? d10.attr({ d: s10 }) : t10.graph && (t10.tracker = d10 = a10.path(s10).attr({ visibility: t10.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(i10 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t10.group), o10.styledMode || d10.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: l10, fill: i10 ? l10 : "none", "stroke-width": t10.graph.strokeWidth() + (i10 ? 0 : 2 * n10) }), [t10.tracker, t10.markerGroup, t10.dataLabelsGroup].forEach((t11) => {
            t11 && (t11.addClass("highcharts-tracker").on("mouseover", h10).on("mouseout", (t12) => {
              r10 == null ? void 0 : r10.onTrackerMouseOut(t12);
            }), e10.cursor && !o10.styledMode && t11.css({ cursor: e10.cursor }), t11.on("touchstart", h10));
          })), rX(this, "afterDrawTracker");
        }
        addPoint(t10, e10, i10, s10, o10) {
          let r10, a10;
          let n10 = this.options, { chart: h10, data: l10, dataTable: d10, xAxis: c10 } = this, p10 = c10 && c10.hasNames && c10.names, u2 = n10.data, g2 = this.getColumn("x");
          e10 = rZ(e10, true);
          let f2 = { series: this };
          this.pointClass.prototype.applyOptions.apply(f2, [t10]);
          let m2 = f2.x;
          if (a10 = g2.length, this.requireSorting && m2 < g2[a10 - 1]) for (r10 = true; a10 && g2[a10 - 1] > m2; ) a10--;
          d10.setRow(f2, a10, true, { addColumns: false }), p10 && f2.name && (p10[m2] = f2.name), u2 == null ? void 0 : u2.splice(a10, 0, t10), (r10 || this.processedData) && (this.data.splice(a10, 0, null), this.processData()), "point" === n10.legendType && this.generatePoints(), i10 && (l10[0] && l10[0].remove ? l10[0].remove(false) : ([l10, u2, ...Object.values(d10.getColumns())].filter(rB).forEach((t11) => {
            t11.shift();
          }), d10.rowCount -= 1, rX(d10, "afterDeleteRows"))), false !== o10 && rX(this, "addPoint", { point: f2 }), this.isDirty = true, this.isDirtyData = true, e10 && h10.redraw(s10);
        }
        removePoint(t10, e10, i10) {
          let s10 = this, { chart: o10, data: r10, points: a10, dataTable: n10 } = s10, h10 = r10[t10], l10 = function() {
            [(a10 == null ? void 0 : a10.length) === r10.length ? a10 : void 0, r10, s10.options.data, ...Object.values(n10.getColumns())].filter(rB).forEach((e11) => {
              e11.splice(t10, 1);
            }), n10.rowCount -= 1, rX(n10, "afterDeleteRows"), h10 == null ? void 0 : h10.destroy(), s10.isDirty = true, s10.isDirtyData = true, e10 && o10.redraw();
          };
          rM(i10, o10), e10 = rZ(e10, true), h10 ? h10.firePointEvent("remove", null, l10) : l10();
        }
        remove(t10, e10, i10, s10) {
          let o10 = this, r10 = o10.chart;
          function a10() {
            o10.destroy(s10), r10.isDirtyLegend = r10.isDirtyBox = true, r10.linkSeries(s10), rZ(t10, true) && r10.redraw(e10);
          }
          false !== i10 ? rX(o10, "remove", null, a10) : a10();
        }
        update(t10, e10) {
          var _a, _b;
          rX(this, "update", { options: t10 = rz(t10, this.userOptions) });
          let i10 = this, s10 = i10.chart, o10 = i10.userOptions, r10 = i10.initialType || i10.type, a10 = s10.options.plotOptions, n10 = rC[r10].prototype, h10 = i10.finishedAnimating && { animation: false }, l10 = {}, d10, c10, p10 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], u2 = t10.type || o10.type || s10.options.chart.type, g2 = !(this.hasDerivedData || u2 && u2 !== this.type || void 0 !== t10.keys || void 0 !== t10.pointStart || void 0 !== t10.pointInterval || void 0 !== t10.relativeXValue || t10.joinBy || t10.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some((t11) => i10.hasOptionChanged(t11)));
          u2 = u2 || r10, g2 ? (p10.push("data", "isDirtyData", "isDirtyCanvas", "points", "dataTable", "processedData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"), false !== t10.visible && p10.push("area", "graph"), i10.parallelArrays.forEach(function(t11) {
            p10.push(t11 + "Data");
          }), t10.data && (t10.dataSorting && rW(i10.options.dataSorting, t10.dataSorting), this.setData(t10.data, false))) : this.dataTable.modified = this.dataTable, t10 = r_(o10, { index: void 0 === o10.index ? i10.index : o10.index, pointStart: ((_a = a10 == null ? void 0 : a10.series) == null ? void 0 : _a.pointStart) ?? o10.pointStart ?? i10.getColumn("x")[0] }, !g2 && { data: i10.options.data }, t10, h10), g2 && t10.data && (t10.data = i10.options.data), (p10 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p10)).forEach(function(t11) {
            p10[t11] = i10[t11], delete i10[t11];
          });
          let f2 = false;
          if (rC[u2]) {
            if (f2 = u2 !== i10.type, i10.remove(false, false, false, true), f2) {
              if (s10.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i10, rC[u2].prototype);
              else {
                let t11 = Object.hasOwnProperty.call(i10, "hcEvents") && i10.hcEvents;
                for (c10 in n10) i10[c10] = void 0;
                rW(i10, rC[u2].prototype), t11 ? i10.hcEvents = t11 : delete i10.hcEvents;
              }
            }
          } else rN(17, true, s10, { missingModuleFor: u2 });
          if (p10.forEach(function(t11) {
            i10[t11] = p10[t11];
          }), i10.init(s10, t10), g2 && this.points) for (let t11 of (false === (d10 = i10.options).visible ? (l10.graphic = 1, l10.dataLabel = 1) : (this.hasMarkerChanged(d10, o10) && (l10.graphic = 1), ((_b = i10.hasDataLabels) == null ? void 0 : _b.call(i10)) || (l10.dataLabel = 1)), this.points)) t11 && t11.series && (t11.resolveColor(), Object.keys(l10).length && t11.destroyElements(l10), false === d10.showInLegend && t11.legendItem && s10.legend.destroyItem(t11));
          i10.initialType = r10, s10.linkSeries(), s10.setSortedData(), f2 && i10.linkedSeries.length && (i10.isDirtyData = true), rX(this, "afterUpdate"), rZ(e10, true) && s10.redraw(!!g2 && void 0);
        }
        setName(t10) {
          this.name = this.options.name = this.userOptions.name = t10, this.chart.isDirtyLegend = true;
        }
        hasOptionChanged(t10) {
          var _a, _b;
          let e10 = this.chart, i10 = this.options[t10], s10 = e10.options.plotOptions, o10 = this.userOptions[t10], r10 = rZ((_a = s10 == null ? void 0 : s10[this.type]) == null ? void 0 : _a[t10], (_b = s10 == null ? void 0 : s10.series) == null ? void 0 : _b[t10]);
          return o10 && !rB(r10) ? i10 !== o10 : i10 !== rZ(r10, i10);
        }
        onMouseOver() {
          let t10 = this.chart, e10 = t10.hoverSeries, i10 = t10.pointer;
          i10 == null ? void 0 : i10.setHoverChartIndex(), e10 && e10 !== this && e10.onMouseOut(), this.options.events.mouseOver && rX(this, "mouseOver"), this.setState("hover"), t10.hoverSeries = this;
        }
        onMouseOut() {
          let t10 = this.options, e10 = this.chart, i10 = e10.tooltip, s10 = e10.hoverPoint;
          e10.hoverSeries = null, s10 && s10.onMouseOut(), this && t10.events.mouseOut && rX(this, "mouseOut"), i10 && !this.stickyTracking && (!i10.shared || this.noSharedTooltip) && i10.hide(), e10.series.forEach(function(t11) {
            t11.setState("", true);
          });
        }
        setState(t10, e10) {
          let i10 = this, s10 = i10.options, o10 = i10.graph, r10 = s10.inactiveOtherPoints, a10 = s10.states, n10 = rZ(a10[t10 || "normal"] && a10[t10 || "normal"].animation, i10.chart.options.chart.animation), h10 = s10.lineWidth, l10 = s10.opacity;
          if (t10 = t10 || "", i10.state !== t10 && ([i10.group, i10.markerGroup, i10.dataLabelsGroup].forEach(function(e11) {
            e11 && (i10.state && e11.removeClass("highcharts-series-" + i10.state), t10 && e11.addClass("highcharts-series-" + t10));
          }), i10.state = t10, !i10.chart.styledMode)) {
            if (a10[t10] && false === a10[t10].enabled) return;
            if (t10 && (h10 = a10[t10].lineWidth || h10 + (a10[t10].lineWidthPlus || 0), l10 = rZ(a10[t10].opacity, l10)), o10 && !o10.dashstyle && rU(h10)) for (let t11 of [o10, ...this.zones.map((t12) => t12.graph)]) t11 == null ? void 0 : t11.animate({ "stroke-width": h10 }, n10);
            r10 || [i10.group, i10.markerGroup, i10.dataLabelsGroup, i10.labelBySeries].forEach(function(t11) {
              t11 && t11.animate({ opacity: l10 }, n10);
            });
          }
          e10 && r10 && i10.points && i10.setAllPointsToState(t10 || void 0);
        }
        setAllPointsToState(t10) {
          this.points.forEach(function(e10) {
            e10.setState && e10.setState(t10);
          });
        }
        setVisible(t10, e10) {
          var _a;
          let i10 = this, s10 = i10.chart, o10 = s10.options.chart.ignoreHiddenSeries, r10 = i10.visible;
          i10.visible = t10 = i10.options.visible = i10.userOptions.visible = void 0 === t10 ? !r10 : t10;
          let a10 = t10 ? "show" : "hide";
          ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach((t11) => {
            var _a2;
            (_a2 = i10[t11]) == null ? void 0 : _a2[a10]();
          }), (s10.hoverSeries === i10 || ((_a = s10.hoverPoint) == null ? void 0 : _a.series) === i10) && i10.onMouseOut(), i10.legendItem && s10.legend.colorizeItem(i10, t10), i10.isDirty = true, i10.options.stacking && s10.series.forEach((t11) => {
            t11.options.stacking && t11.visible && (t11.isDirty = true);
          }), i10.linkedSeries.forEach((e11) => {
            e11.setVisible(t10, false);
          }), o10 && (s10.isDirtyBox = true), rX(i10, a10), false !== e10 && s10.redraw();
        }
        show() {
          this.setVisible(true);
        }
        hide() {
          this.setVisible(false);
        }
        select(t10) {
          this.selected = t10 = this.options.selected = void 0 === t10 ? !this.selected : t10, this.checkbox && (this.checkbox.checked = t10), rX(this, t10 ? "select" : "unselect");
        }
        shouldShowTooltip(t10, e10, i10 = {}) {
          return i10.series = this, i10.visiblePlotOnly = true, this.chart.isInsidePlot(t10, e10, i10);
        }
        drawLegendSymbol(t10, e10) {
          var _a;
          (_a = rf[this.options.legendSymbol || "rectangle"]) == null ? void 0 : _a.call(this, t10, e10);
        }
      }
      rJ.defaultOptions = { lineWidth: 2, allowPointSelect: false, crisp: true, showCheckbox: false, animation: { duration: 1e3 }, enableMouseTracking: true, events: {}, marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, enabled: true, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: true, formatter: function() {
        let { numberFormatter: t10 } = this.series.chart;
        return "number" != typeof this.y ? "" : t10(this.y, -1);
      }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 }, cropThreshold: 300, opacity: 1, pointRange: 0, softThreshold: true, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } }, select: { animation: { duration: 0 } }, inactive: { animation: { duration: 150 }, opacity: 0.2 } }, stickyTracking: true, turboThreshold: 1e3, findNearestPointBy: "x" }, rJ.types = rv.seriesTypes, rJ.registerType = rv.registerSeriesType, rW(rJ.prototype, { axisTypes: ["xAxis", "yAxis"], coll: "series", colorCounter: 0, directTouch: false, invertible: true, isCartesian: true, kdAxisArray: ["clientX", "plotY"], parallelArrays: ["x", "y"], pointClass: oK, requireSorting: true, sorted: true }), rv.series = rJ;
      let rQ = rJ, { animObject: r0, setAnimation: r1 } = t_, { registerEventOptions: r2 } = ss, { composed: r3, marginNames: r5 } = L, { distribute: r6 } = ev, { format: r9 } = eg, { addEvent: r4, createElement: r8, css: r7, defined: at, discardElement: ae, find: ai, fireEvent: as, isNumber: ao, merge: ar, pick: aa, pushUnique: an, relativeLength: ah, stableSort: al, syncTimeout: ad } = ti;
      class ac {
        constructor(t10, e10) {
          this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t10, this.setOptions(e10), e10.enabled && (this.render(), r2(this, e10), r4(this.chart, "endResize", function() {
            this.legend.positionCheckboxes();
          })), r4(this.chart, "render", () => {
            this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
          });
        }
        setOptions(t10) {
          let e10 = aa(t10.padding, 8);
          this.options = t10, this.chart.styledMode || (this.itemStyle = t10.itemStyle, this.itemHiddenStyle = ar(this.itemStyle, t10.itemHiddenStyle)), this.itemMarginTop = t10.itemMarginTop, this.itemMarginBottom = t10.itemMarginBottom, this.padding = e10, this.initialItemY = e10 - 5, this.symbolWidth = aa(t10.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t10.layout && !this.chart.inverted, this.baseline = void 0;
        }
        update(t10, e10) {
          let i10 = this.chart;
          this.setOptions(ar(true, this.options, t10)), "events" in this.options && r2(this, this.options), this.destroy(), i10.isDirtyLegend = i10.isDirtyBox = true, aa(e10, true) && i10.redraw(), as(this, "afterUpdate", { redraw: e10 });
        }
        colorizeItem(t10, e10) {
          var _a;
          let i10 = t10.color, { area: s10, group: o10, label: r10, line: a10, symbol: n10 } = t10.legendItem || {};
          if ((t10 instanceof rQ || t10 instanceof oK) && (t10.color = ((_a = t10.options) == null ? void 0 : _a.legendSymbolColor) || i10), o10 == null ? void 0 : o10[e10 ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
            let { itemHiddenStyle: i11 = {} } = this, o11 = i11.color, { fillColor: h10, fillOpacity: l10, lineColor: d10, marker: c10 } = t10.options, p10 = (t11) => (!e10 && (t11.fill && (t11.fill = o11), t11.stroke && (t11.stroke = o11)), t11);
            r10 == null ? void 0 : r10.css(ar(e10 ? this.itemStyle : i11)), a10 == null ? void 0 : a10.attr(p10({ stroke: d10 || t10.color })), n10 && n10.attr(p10(c10 && n10.isMarker ? t10.pointAttribs() : { fill: t10.color })), s10 == null ? void 0 : s10.attr(p10({ fill: h10 || t10.color, "fill-opacity": h10 ? 1 : l10 ?? 0.75 }));
          }
          t10.color = i10, as(this, "afterColorizeItem", { item: t10, visible: e10 });
        }
        positionItems() {
          this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
        }
        positionItem(t10) {
          let { group: e10, x: i10 = 0, y: s10 = 0 } = t10.legendItem || {}, o10 = this.options, r10 = o10.symbolPadding, a10 = !o10.rtl, n10 = t10.checkbox;
          if (e10 && e10.element) {
            let o11 = { translateX: a10 ? i10 : this.legendWidth - i10 - 2 * r10 - 4, translateY: s10 };
            e10[at(e10.translateY) ? "animate" : "attr"](o11, void 0, () => {
              as(this, "afterPositionItem", { item: t10 });
            });
          }
          n10 && (n10.x = i10, n10.y = s10);
        }
        destroyItem(t10) {
          let e10 = t10.checkbox, i10 = t10.legendItem || {};
          for (let t11 of ["group", "label", "line", "symbol"]) i10[t11] && (i10[t11] = i10[t11].destroy());
          e10 && ae(e10), t10.legendItem = void 0;
        }
        destroy() {
          for (let t10 of this.getAllItems()) this.destroyItem(t10);
          for (let t10 of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[t10] && (this[t10] = this[t10].destroy());
          this.display = null;
        }
        positionCheckboxes() {
          let t10;
          let e10 = this.group && this.group.alignAttr, i10 = this.clipHeight || this.legendHeight, s10 = this.titleHeight;
          e10 && (t10 = e10.translateY, this.allItems.forEach(function(o10) {
            let r10;
            let a10 = o10.checkbox;
            a10 && (r10 = t10 + s10 + a10.y + (this.scrollOffset || 0) + 3, r7(a10, { left: e10.translateX + o10.checkboxOffset + a10.x - 20 + "px", top: r10 + "px", display: this.proximate || r10 > t10 - 6 && r10 < t10 + i10 - 6 ? "" : "none" }));
          }, this));
        }
        renderTitle() {
          let t10 = this.options, e10 = this.padding, i10 = t10.title, s10, o10 = 0;
          i10.text && (this.title || (this.title = this.chart.renderer.label(i10.text, e10 - 3, e10 - 4, void 0, void 0, void 0, t10.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(i10.style), this.title.add(this.group)), i10.width || this.title.css({ width: this.maxLegendWidth + "px" }), o10 = (s10 = this.title.getBBox()).height, this.offsetWidth = s10.width, this.contentGroup.attr({ translateY: o10 })), this.titleHeight = o10;
        }
        setText(t10) {
          let e10 = this.options;
          t10.legendItem.label.attr({ text: e10.labelFormat ? r9(e10.labelFormat, t10, this.chart) : e10.labelFormatter.call(t10) });
        }
        renderItem(t10) {
          let e10 = t10.legendItem = t10.legendItem || {}, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = "horizontal" === o10.layout, a10 = this.symbolWidth, n10 = o10.symbolPadding || 0, h10 = this.itemStyle, l10 = this.itemHiddenStyle, d10 = r10 ? aa(o10.itemDistance, 20) : 0, c10 = !o10.rtl, p10 = !t10.series, u2 = !p10 && t10.series.drawLegendSymbol ? t10.series : t10, g2 = u2.options, f2 = !!this.createCheckboxForItem && g2 && g2.showCheckbox, m2 = o10.useHTML, x2 = t10.options.className, y2 = e10.label, b2 = a10 + n10 + d10 + (f2 ? 20 : 0);
          !y2 && (e10.group = s10.g("legend-item").addClass("highcharts-" + u2.type + "-series highcharts-color-" + t10.colorIndex + (x2 ? " " + x2 : "") + (p10 ? " highcharts-series-" + t10.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), e10.label = y2 = s10.text("", c10 ? a10 + n10 : -n10, this.baseline || 0, m2), i10.styledMode || y2.css(ar(t10.visible ? h10 : l10)), y2.attr({ align: c10 ? "left" : "right", zIndex: 2 }).add(e10.group), !this.baseline && (this.fontMetrics = s10.fontMetrics(y2), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y2.attr("y", this.baseline), this.symbolHeight = aa(o10.symbolHeight, this.fontMetrics.f), o10.squareSymbol && (this.symbolWidth = aa(o10.symbolWidth, Math.max(this.symbolHeight, 16)), b2 = this.symbolWidth + n10 + d10 + (f2 ? 20 : 0), c10 && y2.attr("x", this.symbolWidth + n10))), u2.drawLegendSymbol(this, t10), this.setItemEvents && this.setItemEvents(t10, y2, m2)), f2 && !t10.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t10), this.colorizeItem(t10, t10.visible), (i10.styledMode || !h10.width) && y2.css({ width: (o10.itemWidth || this.widthOption || i10.spacingBox.width) - b2 + "px" }), this.setText(t10);
          let v2 = y2.getBBox(), k2 = this.fontMetrics && this.fontMetrics.h || 0;
          t10.itemWidth = t10.checkboxOffset = o10.itemWidth || e10.labelWidth || v2.width + b2, this.maxItemWidth = Math.max(this.maxItemWidth, t10.itemWidth), this.totalItemWidth += t10.itemWidth, this.itemHeight = t10.itemHeight = Math.round(e10.labelHeight || (v2.height > 1.5 * k2 ? v2.height : k2));
        }
        layoutItem(t10) {
          let e10 = this.options, i10 = this.padding, s10 = "horizontal" === e10.layout, o10 = t10.itemHeight, r10 = this.itemMarginBottom, a10 = this.itemMarginTop, n10 = s10 ? aa(e10.itemDistance, 20) : 0, h10 = this.maxLegendWidth, l10 = e10.alignColumns && this.totalItemWidth > h10 ? this.maxItemWidth : t10.itemWidth, d10 = t10.legendItem || {};
          s10 && this.itemX - i10 + l10 > h10 && (this.itemX = i10, this.lastLineHeight && (this.itemY += a10 + this.lastLineHeight + r10), this.lastLineHeight = 0), this.lastItemY = a10 + this.itemY + r10, this.lastLineHeight = Math.max(o10, this.lastLineHeight), d10.x = this.itemX, d10.y = this.itemY, s10 ? this.itemX += l10 : (this.itemY += a10 + o10 + r10, this.lastLineHeight = o10), this.offsetWidth = this.widthOption || Math.max((s10 ? this.itemX - i10 - (t10.checkbox ? 0 : n10) : l10) + i10, this.offsetWidth);
        }
        getAllItems() {
          let t10 = [];
          return this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.options;
            e10 && aa(i10.showInLegend, !at(i10.linkedTo) && void 0, true) && (t10 = t10.concat((e10.legendItem || {}).labels || ("point" === i10.legendType ? e10.data : e10)));
          }), as(this, "afterGetAllItems", { allItems: t10 }), t10;
        }
        getAlignment() {
          let t10 = this.options;
          return this.proximate ? t10.align.charAt(0) + "tv" : t10.floating ? "" : t10.align.charAt(0) + t10.verticalAlign.charAt(0) + t10.layout.charAt(0);
        }
        adjustMargins(t10, e10) {
          let i10 = this.chart, s10 = this.options, o10 = this.getAlignment();
          o10 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(r10, a10) {
            r10.test(o10) && !at(t10[a10]) && (i10[r5[a10]] = Math.max(i10[r5[a10]], i10.legend[(a10 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][a10] * s10[a10 % 2 ? "x" : "y"] + aa(s10.margin, 12) + e10[a10] + (i10.titleOffset[a10] || 0)));
          });
        }
        proximatePositions() {
          let t10;
          let e10 = this.chart, i10 = [], s10 = "left" === this.options.align;
          for (let o10 of (this.allItems.forEach(function(t11) {
            let o11, r10, a10 = s10, n10, h10;
            t11.yAxis && (t11.xAxis.options.reversed && (a10 = !a10), t11.points && (o11 = ai(a10 ? t11.points : t11.points.slice(0).reverse(), function(t12) {
              return ao(t12.plotY);
            })), r10 = this.itemMarginTop + t11.legendItem.label.getBBox().height + this.itemMarginBottom, h10 = t11.yAxis.top - e10.plotTop, n10 = t11.visible ? (o11 ? o11.plotY : t11.yAxis.height) + (h10 - 0.3 * r10) : h10 + t11.yAxis.height, i10.push({ target: n10, size: r10, item: t11 }));
          }, this), r6(i10, e10.plotHeight))) t10 = o10.item.legendItem || {}, ao(o10.pos) && (t10.y = e10.plotTop - e10.spacing[0] + o10.pos);
        }
        render() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.options, s10 = this.padding, o10 = this.getAllItems(), r10, a10, n10, h10 = this.group, l10, d10 = this.box;
          this.itemX = s10, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = ah(i10.width, t10.spacingBox.width - s10), l10 = t10.spacingBox.width - 2 * s10 - i10.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l10 /= 2), this.maxLegendWidth = this.widthOption || l10, h10 || (this.group = h10 = e10.g("legend").addClass(i10.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = e10.g().attr({ zIndex: 1 }).add(h10), this.scrollGroup = e10.g().add(this.contentGroup)), this.renderTitle(), al(o10, (t11, e11) => (t11.options && t11.options.legendIndex || 0) - (e11.options && e11.options.legendIndex || 0)), i10.reversed && o10.reverse(), this.allItems = o10, this.display = r10 = !!o10.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o10.forEach(this.renderItem, this), o10.forEach(this.layoutItem, this), a10 = (this.widthOption || this.offsetWidth) + s10, n10 = this.lastItemY + this.lastLineHeight + this.titleHeight, n10 = this.handleOverflow(n10) + s10, d10 || (this.box = d10 = e10.rect().addClass("highcharts-legend-box").attr({ r: i10.borderRadius }).add(h10)), t10.styledMode || d10.attr({ stroke: i10.borderColor, "stroke-width": i10.borderWidth || 0, fill: i10.backgroundColor || "none" }).shadow(i10.shadow), a10 > 0 && n10 > 0 && d10[d10.placed ? "animate" : "attr"](d10.crisp.call({}, { x: 0, y: 0, width: a10, height: n10 }, d10.strokeWidth())), h10[r10 ? "show" : "hide"](), t10.styledMode && "none" === h10.getStyle("display") && (a10 = n10 = 0), this.legendWidth = a10, this.legendHeight = n10, r10 && this.align(), this.proximate || this.positionItems(), as(this, "afterRender");
        }
        align(t10 = this.chart.spacingBox) {
          let e10 = this.chart, i10 = this.options, s10 = t10.y;
          /(lth|ct|rth)/.test(this.getAlignment()) && e10.titleOffset[0] > 0 ? s10 += e10.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e10.titleOffset[2] > 0 && (s10 -= e10.titleOffset[2]), s10 !== t10.y && (t10 = ar(t10, { y: s10 })), e10.hasRendered || (this.group.placed = false), this.group.align(ar(i10, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : i10.verticalAlign }), true, t10);
        }
        handleOverflow(t10) {
          let e10 = this, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = o10.y, a10 = "top" === o10.verticalAlign, n10 = this.padding, h10 = o10.maxHeight, l10 = o10.navigation, d10 = aa(l10.animation, true), c10 = l10.arrowSize || 12, p10 = this.pages, u2 = this.allItems, g2 = function(t11) {
            "number" == typeof t11 ? k2.attr({ height: t11 }) : k2 && (e10.clipRect = k2.destroy(), e10.contentGroup.clip()), e10.contentGroup.div && (e10.contentGroup.div.style.clip = t11 ? "rect(" + n10 + "px,9999px," + (n10 + t11) + "px,0)" : "auto");
          }, f2 = function(t11) {
            return e10[t11] = s10.circle(0, 0, 1.3 * c10).translate(c10 / 2, c10 / 2).add(v2), i10.styledMode || e10[t11].attr("fill", "rgba(0,0,0,0.0001)"), e10[t11];
          }, m2, x2, y2, b2 = i10.spacingBox.height + (a10 ? -r10 : r10) - n10, v2 = this.nav, k2 = this.clipRect;
          return "horizontal" !== o10.layout || "middle" === o10.verticalAlign || o10.floating || (b2 /= 2), h10 && (b2 = Math.min(b2, h10)), p10.length = 0, t10 && b2 > 0 && t10 > b2 && false !== l10.enabled ? (this.clipHeight = m2 = Math.max(b2 - 20 - this.titleHeight - n10, 0), this.currentPage = aa(this.currentPage, 1), this.fullHeight = t10, u2.forEach((t11, e11) => {
            let i11 = (y2 = t11.legendItem || {}).y || 0, s11 = Math.round(y2.label.getBBox().height), o11 = p10.length;
            (!o11 || i11 - p10[o11 - 1] > m2 && (x2 || i11) !== p10[o11 - 1]) && (p10.push(x2 || i11), o11++), y2.pageIx = o11 - 1, x2 && ((u2[e11 - 1].legendItem || {}).pageIx = o11 - 1), e11 === u2.length - 1 && i11 + s11 - p10[o11 - 1] > m2 && i11 > p10[o11 - 1] && (p10.push(i11), y2.pageIx = o11), i11 !== x2 && (x2 = i11);
          }), k2 || (k2 = e10.clipRect = s10.clipRect(0, n10 - 2, 9999, 0), e10.contentGroup.clip(k2)), g2(m2), v2 || (this.nav = v2 = s10.g().attr({ zIndex: 1 }).add(this.group), this.up = s10.symbol("triangle", 0, 0, c10, c10).add(v2), f2("upTracker").on("click", function() {
            e10.scroll(-1, d10);
          }), this.pager = s10.text("", 15, 10).addClass("highcharts-legend-navigation"), !i10.styledMode && l10.style && this.pager.css(l10.style), this.pager.add(v2), this.down = s10.symbol("triangle-down", 0, 0, c10, c10).add(v2), f2("downTracker").on("click", function() {
            e10.scroll(1, d10);
          })), e10.scroll(0), t10 = b2) : v2 && (g2(), this.nav = v2.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0), t10;
        }
        scroll(t10, e10) {
          let i10 = this.chart, s10 = this.pages, o10 = s10.length, r10 = this.clipHeight, a10 = this.options.navigation, n10 = this.pager, h10 = this.padding, l10 = this.currentPage + t10;
          l10 > o10 && (l10 = o10), l10 > 0 && (void 0 !== e10 && r1(e10, i10), this.nav.attr({ translateX: h10, translateY: r10 + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function(t11) {
            t11.attr({ class: 1 === l10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
          }), n10.attr({ text: l10 + "/" + o10 }), [this.down, this.downTracker].forEach(function(t11) {
            t11.attr({ x: 18 + this.pager.getBBox().width, class: l10 === o10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
          }, this), i10.styledMode || (this.up.attr({ fill: 1 === l10 ? a10.inactiveColor : a10.activeColor }), this.upTracker.css({ cursor: 1 === l10 ? "default" : "pointer" }), this.down.attr({ fill: l10 === o10 ? a10.inactiveColor : a10.activeColor }), this.downTracker.css({ cursor: l10 === o10 ? "default" : "pointer" })), this.scrollOffset = -s10[l10 - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = l10, this.positionCheckboxes(), ad(() => {
            as(this, "afterScroll", { currentPage: l10 });
          }, r0(aa(e10, i10.renderer.globalAnimation, true)).duration));
        }
        setItemEvents(t10, e10, i10) {
          let s10 = this, o10 = t10.legendItem || {}, r10 = s10.chart.renderer.boxWrapper, a10 = t10 instanceof oK, n10 = t10 instanceof rQ, h10 = "highcharts-legend-" + (a10 ? "point" : "series") + "-active", l10 = s10.chart.styledMode, d10 = i10 ? [e10, o10.symbol] : [o10.group], c10 = (e11) => {
            s10.allItems.forEach((i11) => {
              t10 !== i11 && [i11].concat(i11.linkedSeries || []).forEach((t11) => {
                t11.setState(e11, !a10);
              });
            });
          };
          for (let i11 of d10) i11 && i11.on("mouseover", function() {
            t10.visible && c10("inactive"), t10.setState("hover"), t10.visible && r10.addClass(h10), l10 || e10.css(s10.options.itemHoverStyle);
          }).on("mouseout", function() {
            s10.chart.styledMode || e10.css(ar(t10.visible ? s10.itemStyle : s10.itemHiddenStyle)), c10(""), r10.removeClass(h10), t10.setState();
          }).on("click", function(e11) {
            let i12 = function() {
              t10.setVisible && t10.setVisible(), c10(t10.visible ? "inactive" : "");
            };
            r10.removeClass(h10), as(s10, "itemClick", { browserEvent: e11, legendItem: t10 }, i12), a10 ? t10.firePointEvent("legendItemClick", { browserEvent: e11 }) : n10 && as(t10, "legendItemClick", { browserEvent: e11 });
          });
        }
        createCheckboxForItem(t10) {
          t10.checkbox = r8("input", { type: "checkbox", className: "highcharts-legend-checkbox", checked: t10.selected, defaultChecked: t10.selected }, this.options.itemCheckboxStyle, this.chart.container), r4(t10.checkbox, "click", function(e10) {
            let i10 = e10.target;
            as(t10.series || t10, "checkboxClick", { checked: i10.checked, item: t10 }, function() {
              t10.select();
            });
          });
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          an(r3, "Core.Legend") && r4(e10, "beforeMargins", function() {
            this.legend = new t10(this, this.options.legend);
          });
        };
      }(ac || (ac = {}));
      let ap = ac, { animate: au, animObject: ag, setAnimation: af } = t_, { defaultOptions: am } = tT, { numberFormat: ax } = eg, { registerEventOptions: ay } = ss, { charts: ab, doc: av, marginNames: ak, svg: aM, win: aw } = L, { seriesTypes: aS } = rv, { addEvent: aA, attr: aT, createElement: aC, css: aP, defined: aO, diffObjects: aE, discardElement: aL, erase: aD, error: aB, extend: aI, find: az, fireEvent: aR, getAlignFactor: aN, getStyle: aW, isArray: aG, isNumber: aX, isObject: aH, isString: aF, merge: aY, objectEach: aj, pick: aU, pInt: aV, relativeLength: a_, removeEvent: a$, splat: aZ, syncTimeout: aq, uniqueKey: aK } = ti;
      class aJ {
        static chart(t10, e10, i10) {
          return new aJ(t10, e10, i10);
        }
        constructor(t10, e10, i10) {
          this.sharedClips = {};
          let s10 = [...arguments];
          (aF(t10) || t10.nodeName) && (this.renderTo = s10.shift()), this.init(s10[0], s10[1]);
        }
        setZoomOptions() {
          let t10 = this.options.chart, e10 = t10.zooming;
          this.zooming = { ...e10, type: aU(t10.zoomType, e10.type), key: aU(t10.zoomKey, e10.key), pinchType: aU(t10.pinchType, e10.pinchType), singleTouch: aU(t10.zoomBySingleTouch, e10.singleTouch, false), resetButton: aY(e10.resetButton, t10.resetZoomButton) };
        }
        init(t10, e10) {
          aR(this, "init", { args: arguments }, function() {
            var _a;
            let i10 = aY(am, t10), s10 = i10.chart, o10 = this.renderTo || s10.renderTo;
            this.userOptions = aI({}, t10), (this.renderTo = aF(o10) ? av.getElementById(o10) : o10) || aB(13, true, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e10, this.isResizing = 0, this.options = i10, this.axes = [], this.series = [], this.locale = i10.lang.locale ?? ((_a = this.renderTo.closest("[lang]")) == null ? void 0 : _a.lang), this.time = new tv(aI(i10.time || {}, { locale: this.locale })), i10.time = this.time.options, this.numberFormatter = (s10.numberFormatter || ax).bind(this), this.styledMode = s10.styledMode, this.hasCartesianSeries = s10.showAxes, this.index = ab.length, ab.push(this), L.chartCount++, ay(this, s10), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), aR(this, "afterInit"), this.firstRender();
          });
        }
        initSeries(t10) {
          let e10 = this.options.chart, i10 = t10.type || e10.type, s10 = aS[i10];
          s10 || aB(17, true, this, { missingModuleFor: i10 });
          let o10 = new s10();
          return "function" == typeof o10.init && o10.init(this, t10), o10;
        }
        setSortedData() {
          this.getSeriesOrderByLinks().forEach(function(t10) {
            t10.points || t10.data || !t10.enabledDataSorting || t10.setData(t10.options.data, false);
          });
        }
        getSeriesOrderByLinks() {
          return this.series.concat().sort(function(t10, e10) {
            return t10.linkedSeries.length || e10.linkedSeries.length ? e10.linkedSeries.length - t10.linkedSeries.length : 0;
          });
        }
        orderItems(t10, e10 = 0) {
          let i10 = this[t10], s10 = this.options[t10] = aZ(this.options[t10]).slice(), o10 = this.userOptions[t10] = this.userOptions[t10] ? aZ(this.userOptions[t10]).slice() : [];
          if (this.hasRendered && (s10.splice(e10), o10.splice(e10)), i10) for (let t11 = e10, r10 = i10.length; t11 < r10; ++t11) {
            let e11 = i10[t11];
            e11 && (e11.index = t11, e11 instanceof rQ && (e11.name = e11.getName()), e11.options.isInternal || (s10[t11] = e11.options, o10[t11] = e11.userOptions));
          }
        }
        isInsidePlot(t10, e10, i10 = {}) {
          var _a;
          let { inverted: s10, plotBox: o10, plotLeft: r10, plotTop: a10, scrollablePlotBox: n10 } = this, { scrollLeft: h10 = 0, scrollTop: l10 = 0 } = i10.visiblePlotOnly && ((_a = this.scrollablePlotArea) == null ? void 0 : _a.scrollingContainer) || {}, d10 = i10.series, c10 = i10.visiblePlotOnly && n10 || o10, p10 = i10.inverted ? e10 : t10, u2 = i10.inverted ? t10 : e10, g2 = { x: p10, y: u2, isInsidePlot: true, options: i10 };
          if (!i10.ignoreX) {
            let t11 = d10 && (s10 && !this.polar ? d10.yAxis : d10.xAxis) || { pos: r10, len: 1 / 0 }, e11 = i10.paneCoordinates ? t11.pos + p10 : r10 + p10;
            e11 >= Math.max(h10 + r10, t11.pos) && e11 <= Math.min(h10 + r10 + c10.width, t11.pos + t11.len) || (g2.isInsidePlot = false);
          }
          if (!i10.ignoreY && g2.isInsidePlot) {
            let t11 = !s10 && i10.axis && !i10.axis.isXAxis && i10.axis || d10 && (s10 ? d10.xAxis : d10.yAxis) || { pos: a10, len: 1 / 0 }, e11 = i10.paneCoordinates ? t11.pos + u2 : a10 + u2;
            e11 >= Math.max(l10 + a10, t11.pos) && e11 <= Math.min(l10 + a10 + c10.height, t11.pos + t11.len) || (g2.isInsidePlot = false);
          }
          return aR(this, "afterIsInsidePlot", g2), g2.isInsidePlot;
        }
        redraw(t10) {
          aR(this, "beforeRedraw");
          let e10 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i10 = this.series, s10 = this.pointer, o10 = this.legend, r10 = this.userOptions.legend, a10 = this.renderer, n10 = a10.isHidden(), h10 = [], l10, d10, c10, p10 = this.isDirtyBox, u2 = this.isDirtyLegend, g2;
          for (a10.rootFontSize = a10.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(false), af(!!this.hasRendered && t10, this), n10 && this.temporaryDisplay(), this.layOutTitles(false), c10 = i10.length; c10--; ) if (((g2 = i10[c10]).options.stacking || g2.options.centerInCategory) && (d10 = true, g2.isDirty)) {
            l10 = true;
            break;
          }
          if (l10) for (c10 = i10.length; c10--; ) (g2 = i10[c10]).options.stacking && (g2.isDirty = true);
          i10.forEach(function(t11) {
            t11.isDirty && ("point" === t11.options.legendType ? ("function" == typeof t11.updateTotals && t11.updateTotals(), u2 = true) : r10 && (r10.labelFormatter || r10.labelFormat) && (u2 = true)), t11.isDirtyData && aR(t11, "updatedData");
          }), u2 && o10 && o10.options.enabled && (o10.render(), this.isDirtyLegend = false), d10 && this.getStacks(), e10.forEach(function(t11) {
            t11.updateNames(), t11.setScale();
          }), this.getMargins(), e10.forEach(function(t11) {
            t11.isDirty && (p10 = true);
          }), e10.forEach(function(t11) {
            let e11 = t11.min + "," + t11.max;
            t11.extKey !== e11 && (t11.extKey = e11, h10.push(function() {
              aR(t11, "afterSetExtremes", aI(t11.eventArgs, t11.getExtremes())), delete t11.eventArgs;
            })), (p10 || d10) && t11.redraw();
          }), p10 && this.drawChartBox(), aR(this, "predraw"), i10.forEach(function(t11) {
            (p10 || t11.isDirty) && t11.visible && t11.redraw(), t11.isDirtyData = false;
          }), s10 && s10.reset(true), a10.draw(), aR(this, "redraw"), aR(this, "render"), n10 && this.temporaryDisplay(true), h10.forEach(function(t11) {
            t11.call();
          });
        }
        get(t10) {
          let e10 = this.series;
          function i10(e11) {
            return e11.id === t10 || e11.options && e11.options.id === t10;
          }
          let s10 = az(this.axes, i10) || az(this.series, i10);
          for (let t11 = 0; !s10 && t11 < e10.length; t11++) s10 = az(e10[t11].points || [], i10);
          return s10;
        }
        createAxes() {
          let t10 = this.userOptions;
          for (let e10 of (aR(this, "createAxes"), ["xAxis", "yAxis"])) for (let i10 of t10[e10] = aZ(t10[e10] || {})) new s_(this, i10, e10);
          aR(this, "afterCreateAxes");
        }
        getSelectedPoints() {
          return this.series.reduce((t10, e10) => (e10.getPointsCollection().forEach((e11) => {
            aU(e11.selectedStaging, e11.selected) && t10.push(e11);
          }), t10), []);
        }
        getSelectedSeries() {
          return this.series.filter((t10) => t10.selected);
        }
        setTitle(t10, e10, i10) {
          this.applyDescription("title", t10), this.applyDescription("subtitle", e10), this.applyDescription("caption", void 0), this.layOutTitles(i10);
        }
        applyDescription(t10, e10) {
          var _a;
          let i10 = this, s10 = this.options[t10] = aY(this.options[t10], e10), o10 = this[t10];
          o10 && e10 && (this[t10] = o10 = o10.destroy()), s10 && !o10 && ((o10 = this.renderer.text(s10.text, 0, 0, s10.useHTML).attr({ align: s10.align, class: "highcharts-" + t10, zIndex: s10.zIndex || 4 }).css({ textOverflow: "ellipsis", whiteSpace: "nowrap" }).add()).update = function(e11, s11) {
            i10.applyDescription(t10, e11), i10.layOutTitles(s11);
          }, this.styledMode || o10.css(aI("title" === t10 ? { fontSize: this.options.isStock ? "1em" : "1.2em" } : {}, s10.style)), o10.textPxLength = o10.getBBox().width, o10.css({ whiteSpace: (_a = s10.style) == null ? void 0 : _a.whiteSpace }), this[t10] = o10);
        }
        layOutTitles(t10 = true) {
          var _a, _b, _c, _d;
          let e10 = [0, 0, 0], { options: i10, renderer: s10, spacingBox: o10 } = this;
          ["title", "subtitle", "caption"].forEach((t11) => {
            var _a2;
            let i11 = this[t11], r11 = this.options[t11], a10 = aY(o10), n10 = (i11 == null ? void 0 : i11.textPxLength) || 0;
            if (i11 && r11) {
              aR(this, "layOutTitle", { alignTo: a10, key: t11, textPxLength: n10 });
              let o11 = s10.fontMetrics(i11), h10 = o11.b, l10 = o11.h, d10 = r11.verticalAlign || "top", c10 = "top" === d10, p10 = c10 && r11.minScale || 1, u2 = "title" === t11 ? c10 ? -3 : 0 : c10 ? e10[0] + 2 : 0, g2 = Math.min(a10.width / n10, 1), f2 = Math.max(p10, g2), m2 = aY({ y: "bottom" === d10 ? h10 : u2 + h10 }, { align: "title" === t11 ? g2 < p10 ? "left" : "center" : (_a2 = this.title) == null ? void 0 : _a2.alignValue }, r11), x2 = r11.width || (g2 > p10 ? this.chartWidth : a10.width) / f2;
              i11.alignValue !== m2.align && (i11.placed = false);
              let y2 = Math.round(i11.css({ width: `${x2}px` }).getBBox(r11.useHTML).height);
              if (m2.height = y2, i11.align(m2, false, a10).attr({ align: m2.align, scaleX: f2, scaleY: f2, "transform-origin": `${a10.x + n10 * f2 * aN(m2.align)} ${l10}` }), !r11.floating) {
                let t12 = y2 * (y2 < 1.2 * l10 ? 1 : f2);
                "top" === d10 ? e10[0] = Math.ceil(e10[0] + t12) : "bottom" === d10 && (e10[2] = Math.ceil(e10[2] + t12));
              }
            }
          }, this), e10[0] && "top" === (((_a = i10.title) == null ? void 0 : _a.verticalAlign) || "top") && (e10[0] += ((_b = i10.title) == null ? void 0 : _b.margin) || 0), e10[2] && ((_c = i10.caption) == null ? void 0 : _c.verticalAlign) === "bottom" && (e10[2] += ((_d = i10.caption) == null ? void 0 : _d.margin) || 0);
          let r10 = !this.titleOffset || this.titleOffset.join(",") !== e10.join(",");
          this.titleOffset = e10, aR(this, "afterLayOutTitles"), !this.isDirtyBox && r10 && (this.isDirtyBox = this.isDirtyLegend = r10, this.hasRendered && t10 && this.isDirtyBox && this.redraw());
        }
        getContainerBox() {
          let t10 = [].map.call(this.renderTo.children, (t11) => {
            if (t11 !== this.container) {
              let e11 = t11.style.display;
              return t11.style.display = "none", [t11, e11];
            }
          }), e10 = { width: aW(this.renderTo, "width", true) || 0, height: aW(this.renderTo, "height", true) || 0 };
          return t10.filter(Boolean).forEach(([t11, e11]) => {
            t11.style.display = e11;
          }), e10;
        }
        getChartSize() {
          var _a;
          let t10 = this.options.chart, e10 = t10.width, i10 = t10.height, s10 = this.getContainerBox(), o10 = s10.height <= 1 || !((_a = this.renderTo.parentElement) == null ? void 0 : _a.style.height) && "100%" === this.renderTo.style.height;
          this.chartWidth = Math.max(0, e10 || s10.width || 600), this.chartHeight = Math.max(0, a_(i10, this.chartWidth) || (o10 ? 400 : s10.height)), this.containerBox = s10;
        }
        temporaryDisplay(t10) {
          let e10 = this.renderTo, i10;
          if (t10) for (; e10 && e10.style; ) e10.hcOrigStyle && (aP(e10, e10.hcOrigStyle), delete e10.hcOrigStyle), e10.hcOrigDetached && (av.body.removeChild(e10), e10.hcOrigDetached = false), e10 = e10.parentNode;
          else for (; e10 && e10.style && (av.body.contains(e10) || e10.parentNode || (e10.hcOrigDetached = true, av.body.appendChild(e10)), ("none" === aW(e10, "display", false) || e10.hcOricDetached) && (e10.hcOrigStyle = { display: e10.style.display, height: e10.style.height, overflow: e10.style.overflow }, i10 = { display: "block", overflow: "hidden" }, e10 !== this.renderTo && (i10.height = 0), aP(e10, i10), e10.offsetWidth || e10.style.setProperty("display", "block", "important")), (e10 = e10.parentNode) !== av.body); ) ;
        }
        setClassName(t10) {
          this.container.className = "highcharts-container " + (t10 || "");
        }
        getContainer() {
          var _a;
          let t10;
          let e10 = this.options, i10 = e10.chart, s10 = "data-highcharts-chart", o10 = aK(), r10 = this.renderTo, a10 = aV(aT(r10, s10));
          aX(a10) && ab[a10] && ab[a10].hasRendered && ab[a10].destroy(), aT(r10, s10, this.index), r10.innerHTML = t4.emptyHTML, i10.skipClone || r10.offsetWidth || this.temporaryDisplay(), this.getChartSize();
          let n10 = this.chartHeight, h10 = this.chartWidth;
          aP(r10, { overflow: "hidden" }), this.styledMode || (t10 = aI({ position: "relative", overflow: "hidden", width: h10 + "px", height: n10 + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)", userSelect: "none", "touch-action": "manipulation", outline: "none", padding: "0px" }, i10.style || {}));
          let l10 = aC("div", { id: o10 }, t10, r10);
          this.container = l10, this.getChartSize(), h10 === this.chartWidth || (h10 = this.chartWidth, this.styledMode || aP(l10, { width: aU((_a = i10.style) == null ? void 0 : _a.width, h10 + "px") })), this.containerBox = this.getContainerBox(), this._cursor = l10.style.cursor;
          let d10 = i10.renderer || !aM ? ef.getRendererType(i10.renderer) : i_;
          if (this.renderer = new d10(l10, h10, n10, void 0, i10.forExport, e10.exporting && e10.exporting.allowHTML, this.styledMode), af(void 0, this), this.setClassName(i10.className), this.styledMode) for (let t11 in e10.defs) this.renderer.definition(e10.defs[t11]);
          else this.renderer.setStyle(i10.style);
          this.renderer.chartIndex = this.index, aR(this, "afterGetContainer");
        }
        getMargins(t10) {
          let { spacing: e10, margin: i10, titleOffset: s10 } = this;
          this.resetMargins(), s10[0] && !aO(i10[0]) && (this.plotTop = Math.max(this.plotTop, s10[0] + e10[0])), s10[2] && !aO(i10[2]) && (this.marginBottom = Math.max(this.marginBottom, s10[2] + e10[2])), this.legend && this.legend.display && this.legend.adjustMargins(i10, e10), aR(this, "getMargins"), t10 || this.getAxisMargins();
        }
        getAxisMargins() {
          let t10 = this, e10 = t10.axisOffset = [0, 0, 0, 0], i10 = t10.colorAxis, s10 = t10.margin, o10 = function(t11) {
            t11.forEach(function(t12) {
              t12.visible && t12.getOffset();
            });
          };
          t10.hasCartesianSeries ? o10(t10.axes) : i10 && i10.length && o10(i10), ak.forEach(function(i11, o11) {
            aO(s10[o11]) || (t10[i11] += e10[o11]);
          }), t10.setChartSize();
        }
        getOptions() {
          return aE(this.userOptions, am);
        }
        reflow(t10) {
          var _a;
          let e10 = this, i10 = e10.containerBox, s10 = e10.getContainerBox();
          (_a = e10.pointer) == null ? true : delete _a.chartPosition, !e10.isPrinting && !e10.isResizing && i10 && s10.width && ((s10.width !== i10.width || s10.height !== i10.height) && (ti.clearTimeout(e10.reflowTimeout), e10.reflowTimeout = aq(function() {
            e10.container && e10.setSize(void 0, void 0, false);
          }, t10 ? 100 : 0)), e10.containerBox = s10);
        }
        setReflow() {
          let t10 = this, e10 = (e11) => {
            var _a;
            ((_a = t10.options) == null ? void 0 : _a.chart.reflow) && t10.hasLoaded && t10.reflow(e11);
          };
          if ("function" == typeof ResizeObserver) new ResizeObserver(e10).observe(t10.renderTo);
          else {
            let t11 = aA(aw, "resize", e10);
            aA(this, "destroy", t11);
          }
        }
        setSize(t10, e10, i10) {
          let s10 = this, o10 = s10.renderer;
          s10.isResizing += 1, af(i10, s10);
          let r10 = o10.globalAnimation;
          s10.oldChartHeight = s10.chartHeight, s10.oldChartWidth = s10.chartWidth, void 0 !== t10 && (s10.options.chart.width = t10), void 0 !== e10 && (s10.options.chart.height = e10), s10.getChartSize();
          let { chartWidth: a10, chartHeight: n10, scrollablePixelsX: h10 = 0, scrollablePixelsY: l10 = 0 } = s10;
          (s10.isDirtyBox || a10 !== s10.oldChartWidth || n10 !== s10.oldChartHeight) && (s10.styledMode || (r10 ? au : aP)(s10.container, { width: `${a10 + h10}px`, height: `${n10 + l10}px` }, r10), s10.setChartSize(true), o10.setSize(a10, n10, r10), s10.axes.forEach(function(t11) {
            t11.isDirty = true, t11.setScale();
          }), s10.isDirtyLegend = true, s10.isDirtyBox = true, s10.layOutTitles(), s10.getMargins(), s10.redraw(r10), s10.oldChartHeight = void 0, aR(s10, "resize"), setTimeout(() => {
            s10 && aR(s10, "endResize");
          }, ag(r10).duration)), s10.isResizing -= 1;
        }
        setChartSize(t10) {
          let e10, i10, s10, o10;
          let { chartHeight: r10, chartWidth: a10, inverted: n10, spacing: h10, renderer: l10 } = this, d10 = this.clipOffset, c10 = Math[n10 ? "floor" : "round"];
          this.plotLeft = e10 = Math.round(this.plotLeft), this.plotTop = i10 = Math.round(this.plotTop), this.plotWidth = s10 = Math.max(0, Math.round(a10 - e10 - this.marginRight)), this.plotHeight = o10 = Math.max(0, Math.round(r10 - i10 - this.marginBottom)), this.plotSizeX = n10 ? o10 : s10, this.plotSizeY = n10 ? s10 : o10, this.spacingBox = l10.spacingBox = { x: h10[3], y: h10[0], width: a10 - h10[3] - h10[1], height: r10 - h10[0] - h10[2] }, this.plotBox = l10.plotBox = { x: e10, y: i10, width: s10, height: o10 }, d10 && (this.clipBox = { x: c10(d10[3]), y: c10(d10[0]), width: c10(this.plotSizeX - d10[1] - d10[3]), height: c10(this.plotSizeY - d10[0] - d10[2]) }), t10 || (this.axes.forEach(function(t11) {
            t11.setAxisSize(), t11.setAxisTranslation();
          }), l10.alignElements()), aR(this, "afterSetChartSize", { skipAxes: t10 });
        }
        resetMargins() {
          aR(this, "resetMargins");
          let t10 = this, e10 = t10.options.chart, i10 = e10.plotBorderWidth || 0, s10 = i10 / 2;
          ["margin", "spacing"].forEach(function(i11) {
            let s11 = e10[i11], o10 = aH(s11) ? s11 : [s11, s11, s11, s11];
            ["Top", "Right", "Bottom", "Left"].forEach(function(s12, r10) {
              t10[i11][r10] = aU(e10[i11 + s12], o10[r10]);
            });
          }), ak.forEach(function(e11, i11) {
            t10[e11] = aU(t10.margin[i11], t10.spacing[i11]);
          }), t10.axisOffset = [0, 0, 0, 0], t10.clipOffset = [s10, s10, s10, s10], t10.plotBorderWidth = i10;
        }
        drawChartBox() {
          let t10 = this.options.chart, e10 = this.renderer, i10 = this.chartWidth, s10 = this.chartHeight, o10 = this.styledMode, r10 = this.plotBGImage, a10 = t10.backgroundColor, n10 = t10.plotBackgroundColor, h10 = t10.plotBackgroundImage, l10 = this.plotLeft, d10 = this.plotTop, c10 = this.plotWidth, p10 = this.plotHeight, u2 = this.plotBox, g2 = this.clipRect, f2 = this.clipBox, m2 = this.chartBackground, x2 = this.plotBackground, y2 = this.plotBorder, b2, v2, k2, M2 = "animate";
          m2 || (this.chartBackground = m2 = e10.rect().addClass("highcharts-background").add(), M2 = "attr"), o10 ? b2 = v2 = m2.strokeWidth() : (v2 = (b2 = t10.borderWidth || 0) + (t10.shadow ? 8 : 0), k2 = { fill: a10 || "none" }, (b2 || m2["stroke-width"]) && (k2.stroke = t10.borderColor, k2["stroke-width"] = b2), m2.attr(k2).shadow(t10.shadow)), m2[M2]({ x: v2 / 2, y: v2 / 2, width: i10 - v2 - b2 % 2, height: s10 - v2 - b2 % 2, r: t10.borderRadius }), M2 = "animate", x2 || (M2 = "attr", this.plotBackground = x2 = e10.rect().addClass("highcharts-plot-background").add()), x2[M2](u2), !o10 && (x2.attr({ fill: n10 || "none" }).shadow(t10.plotShadow), h10 && (r10 ? (h10 !== r10.attr("href") && r10.attr("href", h10), r10.animate(u2)) : this.plotBGImage = e10.image(h10, l10, d10, c10, p10).add())), g2 ? g2.animate({ width: f2.width, height: f2.height }) : this.clipRect = e10.clipRect(f2), M2 = "animate", y2 || (M2 = "attr", this.plotBorder = y2 = e10.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add()), o10 || y2.attr({ stroke: t10.plotBorderColor, "stroke-width": t10.plotBorderWidth || 0, fill: "none" }), y2[M2](y2.crisp({ x: l10, y: d10, width: c10, height: p10 }, -y2.strokeWidth())), this.isDirtyBox = false, aR(this, "afterDrawChartBox");
        }
        propFromSeries() {
          let t10, e10, i10;
          let s10 = this, o10 = s10.options.chart, r10 = s10.options.series;
          ["inverted", "angular", "polar"].forEach(function(a10) {
            for (e10 = aS[o10.type], i10 = o10[a10] || e10 && e10.prototype[a10], t10 = r10 && r10.length; !i10 && t10--; ) (e10 = aS[r10[t10].type]) && e10.prototype[a10] && (i10 = true);
            s10[a10] = i10;
          });
        }
        linkSeries(t10) {
          let e10 = this, i10 = e10.series;
          i10.forEach(function(t11) {
            t11.linkedSeries.length = 0;
          }), i10.forEach(function(t11) {
            let { linkedTo: i11 } = t11.options;
            if (aF(i11)) {
              let s10;
              (s10 = ":previous" === i11 ? e10.series[t11.index - 1] : e10.get(i11)) && s10.linkedParent !== t11 && (s10.linkedSeries.push(t11), t11.linkedParent = s10, s10.enabledDataSorting && t11.setDataSortingOptions(), t11.visible = aU(t11.options.visible, s10.options.visible, t11.visible));
            }
          }), aR(this, "afterLinkSeries", { isUpdating: t10 });
        }
        renderSeries() {
          this.series.forEach(function(t10) {
            t10.translate(), t10.render();
          });
        }
        render() {
          var _a;
          let t10 = this.axes, e10 = this.colorAxis, i10 = this.renderer, s10 = this.options.chart.axisLayoutRuns || 2, o10 = (t11) => {
            t11.forEach((t12) => {
              t12.visible && t12.render();
            });
          }, r10 = 0, a10 = true, n10, h10 = 0;
          for (let e11 of (this.setTitle(), aR(this, "beforeMargins"), (_a = this.getStacks) == null ? void 0 : _a.call(this), this.getMargins(true), this.setChartSize(), t10)) {
            let { options: t11 } = e11, { labels: i11 } = t11;
            if (this.hasCartesianSeries && e11.horiz && e11.visible && i11.enabled && e11.series.length && "colorAxis" !== e11.coll && !this.polar) {
              r10 = t11.tickLength, e11.createGroups();
              let s11 = new sm(e11, 0, "", true), o11 = s11.createLabel("x", i11);
              if (s11.destroy(), o11 && aU(i11.reserveSpace, !aX(t11.crossing)) && (r10 = o11.getBBox().height + i11.distance + Math.max(t11.offset || 0, 0)), r10) {
                o11 == null ? void 0 : o11.destroy();
                break;
              }
            }
          }
          for (this.plotHeight = Math.max(this.plotHeight - r10, 0); (a10 || n10 || s10 > 1) && h10 < s10; ) {
            let e11 = this.plotWidth, i11 = this.plotHeight;
            for (let e12 of t10) 0 === h10 ? e12.setScale() : (e12.horiz && a10 || !e12.horiz && n10) && e12.setTickInterval(true);
            0 === h10 ? this.getAxisMargins() : this.getMargins(), a10 = e11 / this.plotWidth > (h10 ? 1 : 1.1), n10 = i11 / this.plotHeight > (h10 ? 1 : 1.05), h10++;
          }
          this.drawChartBox(), this.hasCartesianSeries ? o10(t10) : e10 && e10.length && o10(e10), this.seriesGroup || (this.seriesGroup = i10.g("series-group").attr({ zIndex: 3 }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = true;
        }
        addCredits(t10) {
          let e10 = this, i10 = aY(true, this.options.credits, t10);
          i10.enabled && !this.credits && (this.credits = this.renderer.text(i10.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
            i10.href && (aw.location.href = i10.href);
          }).attr({ align: i10.position.align, zIndex: 8 }), e10.styledMode || this.credits.css(i10.style), this.credits.add().align(i10.position), this.credits.update = function(t11) {
            e10.credits = e10.credits.destroy(), e10.addCredits(t11);
          });
        }
        destroy() {
          let t10;
          let e10 = this, i10 = e10.axes, s10 = e10.series, o10 = e10.container, r10 = o10 && o10.parentNode;
          for (aR(e10, "destroy"), e10.renderer.forExport ? aD(ab, e10) : ab[e10.index] = void 0, L.chartCount--, e10.renderTo.removeAttribute("data-highcharts-chart"), a$(e10), t10 = i10.length; t10--; ) i10[t10] = i10[t10].destroy();
          for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t10 = s10.length; t10--; ) s10[t10] = s10[t10].destroy();
          ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function(t11) {
            let i11 = e10[t11];
            i11 && i11.destroy && (e10[t11] = i11.destroy());
          }), o10 && (o10.innerHTML = t4.emptyHTML, a$(o10), r10 && aL(o10)), aj(e10, function(t11, i11) {
            delete e10[i11];
          });
        }
        firstRender() {
          var _a;
          let t10 = this, e10 = t10.options;
          t10.getContainer(), t10.resetMargins(), t10.setChartSize(), t10.propFromSeries(), t10.createAxes();
          let i10 = aG(e10.series) ? e10.series : [];
          e10.series = [], i10.forEach(function(e11) {
            t10.initSeries(e11);
          }), t10.linkSeries(), t10.setSortedData(), aR(t10, "beforeRender"), t10.render(), (_a = t10.pointer) == null ? void 0 : _a.getChartPosition(), t10.renderer.imgCount || t10.hasLoaded || t10.onload(), t10.temporaryDisplay(true);
        }
        onload() {
          this.callbacks.concat([this.callback]).forEach(function(t10) {
            t10 && void 0 !== this.index && t10.apply(this, [this]);
          }, this), aR(this, "load"), aR(this, "render"), aO(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = true;
        }
        warnIfA11yModuleNotLoaded() {
          let { options: t10, title: e10 } = this;
          !t10 || this.accessibility || (this.renderer.boxWrapper.attr({ role: "img", "aria-label": (e10 && e10.element.textContent || "").replace(/</g, "&lt;") }), t10.accessibility && false === t10.accessibility.enabled || aB('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this));
        }
        addSeries(t10, e10, i10) {
          let s10;
          let o10 = this;
          return t10 && (e10 = aU(e10, true), aR(o10, "addSeries", { options: t10 }, function() {
            s10 = o10.initSeries(t10), o10.isDirtyLegend = true, o10.linkSeries(), s10.enabledDataSorting && s10.setData(t10.data, false), aR(o10, "afterAddSeries", { series: s10 }), e10 && o10.redraw(i10);
          })), s10;
        }
        addAxis(t10, e10, i10, s10) {
          return this.createAxis(e10 ? "xAxis" : "yAxis", { axis: t10, redraw: i10, animation: s10 });
        }
        addColorAxis(t10, e10, i10) {
          return this.createAxis("colorAxis", { axis: t10, redraw: e10, animation: i10 });
        }
        createAxis(t10, e10) {
          let i10 = new s_(this, e10.axis, t10);
          return aU(e10.redraw, true) && this.redraw(e10.animation), i10;
        }
        showLoading(t10) {
          let e10 = this, i10 = e10.options, s10 = i10.loading, o10 = function() {
            r10 && aP(r10, { left: e10.plotLeft + "px", top: e10.plotTop + "px", width: e10.plotWidth + "px", height: e10.plotHeight + "px" });
          }, r10 = e10.loadingDiv, a10 = e10.loadingSpan;
          r10 || (e10.loadingDiv = r10 = aC("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, e10.container)), a10 || (e10.loadingSpan = a10 = aC("span", { className: "highcharts-loading-inner" }, null, r10), aA(e10, "redraw", o10)), r10.className = "highcharts-loading", t4.setElementHTML(a10, aU(t10, i10.lang.loading, "")), e10.styledMode || (aP(r10, aI(s10.style, { zIndex: 10 })), aP(a10, s10.labelStyle), e10.loadingShown || (aP(r10, { opacity: 0, display: "" }), au(r10, { opacity: s10.style.opacity || 0.5 }, { duration: s10.showDuration || 0 }))), e10.loadingShown = true, o10();
        }
        hideLoading() {
          let t10 = this.options, e10 = this.loadingDiv;
          e10 && (e10.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || au(e10, { opacity: 0 }, { duration: t10.loading.hideDuration || 100, complete: function() {
            aP(e10, { display: "none" });
          } })), this.loadingShown = false;
        }
        update(t10, e10, i10, s10) {
          let o10, r10, a10;
          let n10 = this, h10 = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle", caption: "setCaption" }, l10 = t10.isResponsiveOptions, d10 = [];
          aR(n10, "update", { options: t10 }), l10 || n10.setResponsive(false, true), t10 = aE(t10, n10.options), n10.userOptions = aY(n10.userOptions, t10);
          let c10 = t10.chart;
          c10 && (aY(true, n10.options.chart, c10), this.setZoomOptions(), "className" in c10 && n10.setClassName(c10.className), ("inverted" in c10 || "polar" in c10 || "type" in c10) && (n10.propFromSeries(), o10 = true), "alignTicks" in c10 && (o10 = true), "events" in c10 && ay(this, c10), aj(c10, function(t11, e11) {
            -1 !== n10.propsRequireUpdateSeries.indexOf("chart." + e11) && (r10 = true), -1 !== n10.propsRequireDirtyBox.indexOf(e11) && (n10.isDirtyBox = true), -1 === n10.propsRequireReflow.indexOf(e11) || (n10.isDirtyBox = true, l10 || (a10 = true));
          }), !n10.styledMode && c10.style && n10.renderer.setStyle(n10.options.chart.style || {})), !n10.styledMode && t10.colors && (this.options.colors = t10.colors), aj(t10, function(e11, i11) {
            n10[i11] && "function" == typeof n10[i11].update ? n10[i11].update(e11, false) : "function" == typeof n10[h10[i11]] ? n10[h10[i11]](e11) : "colors" !== i11 && -1 === n10.collectionsWithUpdate.indexOf(i11) && aY(true, n10.options[i11], t10[i11]), "chart" !== i11 && -1 !== n10.propsRequireUpdateSeries.indexOf(i11) && (r10 = true);
          }), this.collectionsWithUpdate.forEach(function(e11) {
            t10[e11] && (aZ(t10[e11]).forEach(function(t11, s11) {
              let o11;
              let r11 = aO(t11.id);
              r11 && (o11 = n10.get(t11.id)), !o11 && n10[e11] && (o11 = n10[e11][aU(t11.index, s11)]) && (r11 && aO(o11.options.id) || o11.options.isInternal) && (o11 = void 0), o11 && o11.coll === e11 && (o11.update(t11, false), i10 && (o11.touched = true)), !o11 && i10 && n10.collectionsWithInit[e11] && (n10.collectionsWithInit[e11][0].apply(n10, [t11].concat(n10.collectionsWithInit[e11][1] || []).concat([false])).touched = true);
            }), i10 && n10[e11].forEach(function(t11) {
              t11.touched || t11.options.isInternal ? delete t11.touched : d10.push(t11);
            }));
          }), d10.forEach(function(t11) {
            t11.chart && t11.remove && t11.remove(false);
          }), o10 && n10.axes.forEach(function(t11) {
            t11.update({}, false);
          }), r10 && n10.getSeriesOrderByLinks().forEach(function(t11) {
            t11.chart && t11.update({}, false);
          }, this);
          let p10 = c10 && c10.width, u2 = c10 && (aF(c10.height) ? a_(c10.height, p10 || n10.chartWidth) : c10.height);
          a10 || aX(p10) && p10 !== n10.chartWidth || aX(u2) && u2 !== n10.chartHeight ? n10.setSize(p10, u2, s10) : aU(e10, true) && n10.redraw(s10), aR(n10, "afterUpdate", { options: t10, redraw: e10, animation: s10 });
        }
        setSubtitle(t10, e10) {
          this.applyDescription("subtitle", t10), this.layOutTitles(e10);
        }
        setCaption(t10, e10) {
          this.applyDescription("caption", t10), this.layOutTitles(e10);
        }
        showResetZoom() {
          let t10 = this, e10 = am.lang, i10 = t10.zooming.resetButton, s10 = i10.theme, o10 = "chart" === i10.relativeTo || "spacingBox" === i10.relativeTo ? null : "plotBox";
          function r10() {
            t10.zoomOut();
          }
          aR(this, "beforeShowResetZoom", null, function() {
            t10.resetZoomButton = t10.renderer.button(e10.resetZoom, null, null, r10, s10).attr({ align: i10.position.align, title: e10.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(i10.position, false, o10);
          }), aR(this, "afterShowResetZoom");
        }
        zoomOut() {
          aR(this, "selection", { resetSelection: true }, () => this.transform({ reset: true, trigger: "zoom" }));
        }
        pan(t10, e10) {
          let i10 = this, s10 = "object" == typeof e10 ? e10 : { enabled: e10, type: "x" }, o10 = s10.type, r10 = o10 && i10[{ x: "xAxis", xy: "axes", y: "yAxis" }[o10]].filter((t11) => t11.options.panningEnabled && !t11.options.isInternal), a10 = i10.options.chart;
          (a10 == null ? void 0 : a10.panning) && (a10.panning = s10), aR(this, "pan", { originalEvent: t10 }, () => {
            i10.transform({ axes: r10, event: t10, to: { x: t10.chartX - (i10.mouseDownX || 0), y: t10.chartY - (i10.mouseDownY || 0) }, trigger: "pan" }), aP(i10.container, { cursor: "move" });
          });
        }
        transform(t10) {
          var _a;
          let { axes: e10 = this.axes, event: i10, from: s10 = {}, reset: o10, selection: r10, to: a10 = {}, trigger: n10 } = t10, { inverted: h10, time: l10 } = this, d10 = false, c10, p10;
          for (let t11 of ((_a = this.hoverPoints) == null ? void 0 : _a.forEach((t12) => t12.setState()), e10)) {
            let { horiz: e11, len: u2, minPointOffset: g2 = 0, options: f2, reversed: m2 } = t11, x2 = e11 ? "width" : "height", y2 = e11 ? "x" : "y", b2 = aU(a10[x2], t11.len), v2 = aU(s10[x2], t11.len), k2 = 10 > Math.abs(b2) ? 1 : b2 / v2, M2 = (s10[y2] || 0) + v2 / 2 - t11.pos, w2 = M2 - ((a10[y2] ?? t11.pos) + b2 / 2 - t11.pos) / k2, S2 = m2 && !h10 || !m2 && h10 ? -1 : 1;
            if (!o10 && (M2 < 0 || M2 > t11.len)) continue;
            let A2 = t11.toValue(w2, true) + (r10 || t11.isOrdinal ? 0 : g2 * S2), T2 = t11.toValue(w2 + u2 / k2, true) - (r10 || t11.isOrdinal ? 0 : g2 * S2 || 0), C2 = t11.allExtremes;
            if (A2 > T2 && ([A2, T2] = [T2, A2]), 1 === k2 && !o10 && "yAxis" === t11.coll && !C2) {
              for (let e12 of t11.series) {
                let t12 = e12.getExtremes(e12.getProcessedData(true).modified.getColumn("y") || [], true);
                C2 ?? (C2 = { dataMin: Number.MAX_VALUE, dataMax: -Number.MAX_VALUE }), aX(t12.dataMin) && aX(t12.dataMax) && (C2.dataMin = Math.min(t12.dataMin, C2.dataMin), C2.dataMax = Math.max(t12.dataMax, C2.dataMax));
              }
              t11.allExtremes = C2;
            }
            let { dataMin: P2, dataMax: O2, min: E2, max: L2 } = aI(t11.getExtremes(), C2 || {}), D2 = l10.parse(f2.min), B2 = l10.parse(f2.max), I2 = P2 ?? D2, z2 = O2 ?? B2, R2 = T2 - A2, N2 = t11.categories ? 0 : Math.min(R2, z2 - I2), W2 = I2 - N2 * (aO(D2) ? 0 : f2.minPadding), G2 = z2 + N2 * (aO(B2) ? 0 : f2.maxPadding), X2 = t11.allowZoomOutside || 1 === k2 || "zoom" !== n10 && k2 > 1, H2 = Math.min(D2 ?? W2, W2, X2 ? E2 : W2), F2 = Math.max(B2 ?? G2, G2, X2 ? L2 : G2);
            (!t11.isOrdinal || t11.options.overscroll || 1 !== k2 || o10) && (A2 < H2 && (A2 = H2, k2 >= 1 && (T2 = A2 + R2)), T2 > F2 && (T2 = F2, k2 >= 1 && (A2 = T2 - R2)), (o10 || t11.series.length && (A2 !== E2 || T2 !== L2) && A2 >= H2 && T2 <= F2) && (r10 ? r10[t11.coll].push({ axis: t11, min: A2, max: T2 }) : (t11.isPanning = "zoom" !== n10, t11.isPanning && (p10 = true), t11.setExtremes(o10 ? void 0 : A2, o10 ? void 0 : T2, false, false, { move: w2, trigger: n10, scale: k2 }), !o10 && (A2 > H2 || T2 < F2) && "mousewheel" !== n10 && (c10 = true)), d10 = true), i10 && (this[e11 ? "mouseDownX" : "mouseDownY"] = i10[e11 ? "chartX" : "chartY"]));
          }
          return d10 && (r10 ? aR(this, "selection", r10, () => {
            delete t10.selection, t10.trigger = "zoom", this.transform(t10);
          }) : (!c10 || p10 || this.resetZoomButton ? !c10 && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw("zoom" === n10 && (this.options.chart.animation ?? this.pointCount < 100)))), d10;
        }
      }
      aI(aJ.prototype, { callbacks: [], collectionsWithInit: { xAxis: [aJ.prototype.addAxis, [true]], yAxis: [aJ.prototype.addAxis, [false]], series: [aJ.prototype.addSeries] }, collectionsWithUpdate: ["xAxis", "yAxis", "series"], propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"], propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"], propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"] });
      let aQ = aJ, { stop: a0 } = t_, { composed: a1 } = L, { addEvent: a2, createElement: a3, css: a5, defined: a6, erase: a9, merge: a4, pushUnique: a8 } = ti;
      function a7() {
        let t10 = this.scrollablePlotArea;
        (this.scrollablePixelsX || this.scrollablePixelsY) && !t10 && (this.scrollablePlotArea = t10 = new ne(this)), t10 == null ? void 0 : t10.applyFixed();
      }
      function nt() {
        this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = true);
      }
      class ne {
        static compose(t10, e10, i10) {
          a8(a1, this.compose) && (a2(t10, "afterInit", nt), a2(e10, "afterSetChartSize", (t11) => this.afterSetSize(t11.target, t11)), a2(e10, "render", a7), a2(i10, "show", nt));
        }
        static afterSetSize(t10, e10) {
          let i10, s10, o10;
          let { minWidth: r10, minHeight: a10 } = t10.options.chart.scrollablePlotArea || {}, { clipBox: n10, plotBox: h10, inverted: l10, renderer: d10 } = t10;
          if (!d10.forExport && (r10 ? (t10.scrollablePixelsX = i10 = Math.max(0, r10 - t10.chartWidth), i10 && (t10.scrollablePlotBox = a4(t10.plotBox), h10.width = t10.plotWidth += i10, n10[l10 ? "height" : "width"] += i10, o10 = true)) : a10 && (t10.scrollablePixelsY = s10 = Math.max(0, a10 - t10.chartHeight), a6(s10) && (t10.scrollablePlotBox = a4(t10.plotBox), h10.height = t10.plotHeight += s10, n10[l10 ? "width" : "height"] += s10, o10 = false)), a6(o10) && !e10.skipAxes)) for (let e11 of t10.axes) (e11.horiz === o10 || t10.hasParallelCoordinates && "yAxis" === e11.coll) && (e11.setAxisSize(), e11.setAxisTranslation());
        }
        constructor(t10) {
          var _a;
          let e10;
          let i10 = t10.options.chart, s10 = ef.getRendererType(), o10 = i10.scrollablePlotArea || {}, r10 = this.moveFixedElements.bind(this), a10 = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" };
          t10.scrollablePixelsX && (a10.overflowX = "auto"), t10.scrollablePixelsY && (a10.overflowY = "auto"), this.chart = t10;
          let n10 = this.parentDiv = a3("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, t10.renderTo), h10 = this.scrollingContainer = a3("div", { className: "highcharts-scrolling" }, a10, n10), l10 = this.innerContainer = a3("div", { className: "highcharts-inner-container" }, void 0, h10), d10 = this.fixedDiv = a3("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (((_a = i10.style) == null ? void 0 : _a.zIndex) || 0) + 2, top: 0 }, void 0, true), c10 = this.fixedRenderer = new s10(d10, t10.chartWidth, t10.chartHeight, i10.style);
          this.mask = c10.path().attr({ fill: i10.backgroundColor || "#fff", "fill-opacity": o10.opacity ?? 0.85, zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), h10.parentNode.insertBefore(d10, h10), a5(t10.renderTo, { overflow: "visible" }), a2(t10, "afterShowResetZoom", r10), a2(t10, "afterApplyDrilldown", r10), a2(t10, "afterLayOutTitles", r10), a2(h10, "scroll", () => {
            let { pointer: i11, hoverPoint: s11 } = t10;
            i11 && (delete i11.chartPosition, s11 && (e10 = s11), i11.runPointActions(void 0, e10, true));
          }), l10.appendChild(t10.container);
        }
        applyFixed() {
          var _a;
          let { chart: t10, fixedRenderer: e10, isDirty: i10, scrollingContainer: s10 } = this, { axisOffset: o10, chartWidth: r10, chartHeight: a10, container: n10, plotHeight: h10, plotLeft: l10, plotTop: d10, plotWidth: c10, scrollablePixelsX: p10 = 0, scrollablePixelsY: u2 = 0 } = t10, { scrollPositionX: g2 = 0, scrollPositionY: f2 = 0 } = t10.options.chart.scrollablePlotArea || {}, m2 = r10 + p10, x2 = a10 + u2;
          e10.setSize(r10, a10), (i10 ?? true) && (this.isDirty = false, this.moveFixedElements()), a0(t10.container), a5(n10, { width: `${m2}px`, height: `${x2}px` }), t10.renderer.boxWrapper.attr({ width: m2, height: x2, viewBox: [0, 0, m2, x2].join(" ") }), (_a = t10.chartBackground) == null ? void 0 : _a.attr({ width: m2, height: x2 }), a5(s10, { width: `${r10}px`, height: `${a10}px` }), a6(i10) || (s10.scrollLeft = p10 * g2, s10.scrollTop = u2 * f2);
          let y2 = d10 - o10[0] - 1, b2 = l10 - o10[3] - 1, v2 = d10 + h10 + o10[2] + 1, k2 = l10 + c10 + o10[1] + 1, M2 = l10 + c10 - p10, w2 = d10 + h10 - u2, S2 = [["M", 0, 0]];
          p10 ? S2 = [["M", 0, y2], ["L", l10 - 1, y2], ["L", l10 - 1, v2], ["L", 0, v2], ["Z"], ["M", M2, y2], ["L", r10, y2], ["L", r10, v2], ["L", M2, v2], ["Z"]] : u2 && (S2 = [["M", b2, 0], ["L", b2, d10 - 1], ["L", k2, d10 - 1], ["L", k2, 0], ["Z"], ["M", b2, w2], ["L", b2, a10], ["L", k2, a10], ["L", k2, w2], ["Z"]]), "adjustHeight" !== t10.redrawTrigger && this.mask.attr({ d: S2 });
        }
        moveFixedElements() {
          let t10;
          let { container: e10, inverted: i10, scrollablePixelsX: s10, scrollablePixelsY: o10 } = this.chart, r10 = this.fixedRenderer, a10 = ne.fixedSelectors;
          if (s10 && !i10 ? t10 = ".highcharts-yaxis" : s10 && i10 ? t10 = ".highcharts-xaxis" : o10 && !i10 ? t10 = ".highcharts-xaxis" : o10 && i10 && (t10 = ".highcharts-yaxis"), t10 && !(this.chart.hasParallelCoordinates && ".highcharts-yaxis" === t10)) for (let e11 of [`${t10}:not(.highcharts-radial-axis)`, `${t10}-labels:not(.highcharts-radial-axis-labels)`]) a8(a10, e11);
          else for (let t11 of [".highcharts-xaxis", ".highcharts-yaxis"]) for (let e11 of [`${t11}:not(.highcharts-radial-axis)`, `${t11}-labels:not(.highcharts-radial-axis-labels)`]) a9(a10, e11);
          for (let t11 of a10) [].forEach.call(e10.querySelectorAll(t11), (t12) => {
            (t12.namespaceURI === r10.SVG_NS ? r10.box : r10.box.parentNode).appendChild(t12), t12.style.pointerEvents = "auto";
          });
        }
      }
      ne.fixedSelectors = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-drillup-button", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-range-selector-group", ".highcharts-reset-zoom", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"];
      let { format: ni } = eg, { series: ns } = rv, { destroyObjectProperties: no, fireEvent: nr, getAlignFactor: na, isNumber: nn, pick: nh } = ti, nl = class {
        constructor(t10, e10, i10, s10, o10) {
          let r10 = t10.chart.inverted, a10 = t10.reversed;
          this.axis = t10;
          let n10 = this.isNegative = !!i10 != !!a10;
          this.options = e10 = e10 || {}, this.x = s10, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = false, this.stack = o10, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = { align: e10.align || (r10 ? n10 ? "left" : "right" : "center"), verticalAlign: e10.verticalAlign || (r10 ? "middle" : n10 ? "bottom" : "top"), y: e10.y, x: e10.x }, this.textAlign = e10.textAlign || (r10 ? n10 ? "right" : "left" : "center");
        }
        destroy() {
          no(this, this.axis);
        }
        render(t10) {
          let e10 = this.axis.chart, i10 = this.options, s10 = i10.format, o10 = s10 ? ni(s10, this, e10) : i10.formatter.call(this);
          if (this.label) this.label.attr({ text: o10, visibility: "hidden" });
          else {
            this.label = e10.renderer.label(o10, null, void 0, i10.shape, void 0, void 0, i10.useHTML, false, "stack-labels");
            let s11 = { r: i10.borderRadius || 0, text: o10, padding: nh(i10.padding, 5), visibility: "hidden" };
            e10.styledMode || (s11.fill = i10.backgroundColor, s11.stroke = i10.borderColor, s11["stroke-width"] = i10.borderWidth, this.label.css(i10.style || {})), this.label.attr(s11), this.label.added || this.label.add(t10);
          }
          this.label.labelrank = e10.plotSizeY, nr(this, "afterRender");
        }
        setOffset(t10, e10, i10, s10, o10, r10) {
          let { alignOptions: a10, axis: n10, label: h10, options: l10, textAlign: d10 } = this, c10 = n10.chart, p10 = this.getStackBox({ xOffset: t10, width: e10, boxBottom: i10, boxTop: s10, defaultX: o10, xAxis: r10 }), { verticalAlign: u2 } = a10;
          if (h10 && p10) {
            let t11 = h10.getBBox(void 0, 0), e11 = h10.padding, i11 = "justify" === nh(l10.overflow, "justify"), s11;
            a10.x = l10.x || 0, a10.y = l10.y || 0;
            let { x: o11, y: r11 } = this.adjustStackPosition({ labelBox: t11, verticalAlign: u2, textAlign: d10 });
            p10.x -= o11, p10.y -= r11, h10.align(a10, false, p10), (s11 = c10.isInsidePlot(h10.alignAttr.x + a10.x + o11, h10.alignAttr.y + a10.y + r11)) || (i11 = false), i11 && ns.prototype.justifyDataLabel.call(n10, h10, a10, h10.alignAttr, t11, p10), h10.attr({ x: h10.alignAttr.x, y: h10.alignAttr.y, rotation: l10.rotation, rotationOriginX: t11.width * na(l10.textAlign || "center"), rotationOriginY: t11.height / 2 }), nh(!i11 && l10.crop, true) && (s11 = nn(h10.x) && nn(h10.y) && c10.isInsidePlot(h10.x - e11 + (h10.width || 0), h10.y) && c10.isInsidePlot(h10.x + e11, h10.y)), h10[s11 ? "show" : "hide"]();
          }
          nr(this, "afterSetOffset", { xOffset: t10, width: e10 });
        }
        adjustStackPosition({ labelBox: t10, verticalAlign: e10, textAlign: i10 }) {
          return { x: t10.width / 2 + t10.width / 2 * (2 * na(i10) - 1), y: t10.height / 2 * 2 * (1 - na(e10)) };
        }
        getStackBox(t10) {
          let e10 = this.axis, i10 = e10.chart, { boxTop: s10, defaultX: o10, xOffset: r10, width: a10, boxBottom: n10 } = t10, h10 = e10.stacking.usePercentage ? 100 : nh(s10, this.total, 0), l10 = e10.toPixels(h10), d10 = t10.xAxis || i10.xAxis[0], c10 = nh(o10, d10.translate(this.x)) + r10, p10 = Math.abs(l10 - e10.toPixels(n10 || nn(e10.min) && e10.logarithmic && e10.logarithmic.lin2log(e10.min) || 0)), u2 = i10.inverted, g2 = this.isNegative;
          return u2 ? { x: (g2 ? l10 : l10 - p10) - i10.plotLeft, y: d10.height - c10 - a10 + d10.top - i10.plotTop, width: p10, height: a10 } : { x: c10 + d10.transB - i10.plotLeft, y: (g2 ? l10 - p10 : l10) - i10.plotTop, width: a10, height: p10 };
        }
      }, { getDeferredAnimation: nd } = t_, { series: { prototype: nc } } = rv, { addEvent: np, correctFloat: nu, defined: ng, destroyObjectProperties: nf, fireEvent: nm, isNumber: nx, objectEach: ny, pick: nb } = ti;
      function nv() {
        let t10 = this.inverted;
        this.axes.forEach((t11) => {
          t11.stacking && t11.stacking.stacks && t11.hasVisibleSeries && (t11.stacking.oldStacks = t11.stacking.stacks);
        }), this.series.forEach((e10) => {
          let i10 = e10.xAxis && e10.xAxis.options || {};
          e10.options.stacking && e10.reserveSpace() && (e10.stackKey = [e10.type, nb(e10.options.stack, ""), t10 ? i10.top : i10.left, t10 ? i10.height : i10.width].join(","));
        });
      }
      function nk() {
        var _a;
        let t10 = this.stacking;
        if (t10) {
          let e10 = t10.stacks;
          ny(e10, (t11, i10) => {
            nf(t11), delete e10[i10];
          }), (_a = t10.stackTotalGroup) == null ? void 0 : _a.destroy();
        }
      }
      function nM() {
        this.stacking || (this.stacking = new nP(this));
      }
      function nw(t10, e10, i10, s10) {
        return !ng(t10) || t10.x !== e10 || s10 && t10.stackKey !== s10 ? t10 = { x: e10, index: 0, key: s10, stackKey: s10 } : t10.index++, t10.key = [i10, e10, t10.index].join(","), t10;
      }
      function nS() {
        let t10;
        let e10 = this, i10 = e10.yAxis, s10 = e10.stackKey || "", o10 = i10.stacking.stacks, r10 = e10.getColumn("x", true), a10 = e10.options.stacking, n10 = e10[a10 + "Stacker"];
        n10 && [s10, "-" + s10].forEach((i11) => {
          var _a;
          let s11 = r10.length, a11, h10, l10;
          for (; s11--; ) a11 = r10[s11], t10 = e10.getStackIndicator(t10, a11, e10.index, i11), h10 = (_a = o10[i11]) == null ? void 0 : _a[a11], (l10 = h10 == null ? void 0 : h10.points[t10.key || ""]) && n10.call(e10, l10, h10, s11);
        });
      }
      function nA(t10, e10, i10) {
        let s10 = e10.total ? 100 / e10.total : 0;
        t10[0] = nu(t10[0] * s10), t10[1] = nu(t10[1] * s10), this.stackedYData[i10] = t10[1];
      }
      function nT(t10) {
        (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && this.chart.series.length > 1 ? nc.setStackedPoints.call(this, t10, "group") : t10.stacking.resetStacks());
      }
      function nC(t10, e10) {
        var _a, _b;
        let i10, s10, o10, r10, a10, n10, h10;
        let l10 = e10 || this.options.stacking;
        if (!l10 || !this.reserveSpace() || ({ group: "xAxis" }[l10] || "yAxis") !== t10.coll) return;
        let d10 = this.getColumn("x", true), c10 = this.getColumn(this.pointValKey || "y", true), p10 = [], u2 = c10.length, g2 = this.options, f2 = g2.threshold || 0, m2 = g2.startFromThreshold ? f2 : 0, x2 = g2.stack, y2 = e10 ? `${this.type},${l10}` : this.stackKey || "", b2 = "-" + y2, v2 = this.negStacks, k2 = t10.stacking, M2 = k2.stacks, w2 = k2.oldStacks;
        for (k2.stacksTouched += 1, h10 = 0; h10 < u2; h10++) {
          let e11 = d10[h10] || 0, u3 = c10[h10], g3 = nx(u3) && u3 || 0;
          n10 = (i10 = this.getStackIndicator(i10, e11, this.index)).key || "", M2[a10 = (s10 = v2 && g3 < (m2 ? 0 : f2)) ? b2 : y2] || (M2[a10] = {}), M2[a10][e11] || (((_a = w2[a10]) == null ? void 0 : _a[e11]) ? (M2[a10][e11] = w2[a10][e11], M2[a10][e11].total = null) : M2[a10][e11] = new nl(t10, t10.options.stackLabels, !!s10, e11, x2)), o10 = M2[a10][e11], null !== u3 ? (o10.points[n10] = o10.points[this.index] = [nb(o10.cumulative, m2)], ng(o10.cumulative) || (o10.base = n10), o10.touched = k2.stacksTouched, i10.index > 0 && false === this.singleStacks && (o10.points[n10][0] = o10.points[this.index + "," + e11 + ",0"][0])) : (delete o10.points[n10], delete o10.points[this.index]);
          let S2 = o10.total || 0;
          "percent" === l10 ? (r10 = s10 ? y2 : b2, S2 = v2 && ((_b = M2[r10]) == null ? void 0 : _b[e11]) ? (r10 = M2[r10][e11]).total = Math.max(r10.total || 0, S2) + Math.abs(g3) : nu(S2 + Math.abs(g3))) : "group" === l10 ? nx(u3) && S2++ : S2 = nu(S2 + g3), "group" === l10 ? o10.cumulative = (S2 || 1) - 1 : o10.cumulative = nu(nb(o10.cumulative, m2) + g3), o10.total = S2, null !== u3 && (o10.points[n10].push(o10.cumulative), p10[h10] = o10.cumulative, o10.hasValidPoints = true);
        }
        "percent" === l10 && (k2.usePercentage = true), "group" !== l10 && (this.stackedYData = p10), k2.oldStacks = {};
      }
      class nP {
        constructor(t10) {
          this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t10;
        }
        buildStacks() {
          let t10, e10;
          let i10 = this.axis, s10 = i10.series, o10 = "xAxis" === i10.coll, r10 = i10.options.reversedStacks, a10 = s10.length;
          for (this.resetStacks(), this.usePercentage = false, e10 = a10; e10--; ) t10 = s10[r10 ? e10 : a10 - e10 - 1], o10 && t10.setGroupedPoints(i10), t10.setStackedPoints(i10);
          if (!o10) for (e10 = 0; e10 < a10; e10++) s10[e10].modifyStacks();
          nm(i10, "afterBuildStacks");
        }
        cleanStacks() {
          this.oldStacks && (this.stacks = this.oldStacks, ny(this.stacks, (t10) => {
            ny(t10, (t11) => {
              t11.cumulative = t11.total;
            });
          }));
        }
        resetStacks() {
          ny(this.stacks, (t10) => {
            ny(t10, (e10, i10) => {
              nx(e10.touched) && e10.touched < this.stacksTouched ? (e10.destroy(), delete t10[i10]) : (e10.total = null, e10.cumulative = null);
            });
          });
        }
        renderStackTotals() {
          var _a;
          let t10 = this.axis, e10 = t10.chart, i10 = e10.renderer, s10 = this.stacks, o10 = nd(e10, ((_a = t10.options.stackLabels) == null ? void 0 : _a.animation) || false), r10 = this.stackTotalGroup = this.stackTotalGroup || i10.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add();
          r10.translate(e10.plotLeft, e10.plotTop), ny(s10, (t11) => {
            ny(t11, (t12) => {
              t12.render(r10);
            });
          }), r10.animate({ opacity: 1 }, o10);
        }
      }
      (m || (m = {})).compose = function(t10, e10, i10) {
        let s10 = e10.prototype, o10 = i10.prototype;
        s10.getStacks || (np(t10, "init", nM), np(t10, "destroy", nk), s10.getStacks = nv, o10.getStackIndicator = nw, o10.modifyStacks = nS, o10.percentStacker = nA, o10.setGroupedPoints = nT, o10.setStackedPoints = nC);
      };
      let nO = m, { defined: nE, merge: nL, isObject: nD } = ti;
      class nB extends rQ {
        drawGraph() {
          let t10 = this.options, e10 = (this.gappedPath || this.getGraphPath).call(this), i10 = this.chart.styledMode;
          [this, ...this.zones].forEach((s10, o10) => {
            let r10, a10 = s10.graph, n10 = a10 ? "animate" : "attr", h10 = s10.dashStyle || t10.dashStyle;
            a10 ? (a10.endX = this.preventGraphAnimation ? null : e10.xMap, a10.animate({ d: e10 })) : e10.length && (s10.graph = a10 = this.chart.renderer.path(e10).addClass("highcharts-graph" + (o10 ? ` highcharts-zone-graph-${o10 - 1} ` : " ") + (o10 && s10.className || "")).attr({ zIndex: 1 }).add(this.group)), a10 && !i10 && (r10 = { stroke: !o10 && t10.lineColor || s10.color || this.color || "#cccccc", "stroke-width": t10.lineWidth || 0, fill: this.fillGraph && this.color || "none" }, h10 ? r10.dashstyle = h10 : "square" !== t10.linecap && (r10["stroke-linecap"] = r10["stroke-linejoin"] = "round"), a10[n10](r10).shadow(t10.shadow && nL({ filterUnits: "userSpaceOnUse" }, nD(t10.shadow) ? t10.shadow : {}))), a10 && (a10.startX = e10.xMap, a10.isArea = e10.isArea);
          });
        }
        getGraphPath(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = [], a10 = [], n10, h10 = o10.step, l10 = (t10 = t10 || s10.points).reversed;
          return l10 && t10.reverse(), (h10 = { right: 1, center: 2 }[h10] || h10 && 3) && l10 && (h10 = 4 - h10), (t10 = this.getValidPoints(t10, false, !(o10.connectNulls && !e10 && !i10))).forEach(function(l11, d10) {
            let c10;
            let p10 = l11.plotX, u2 = l11.plotY, g2 = t10[d10 - 1], f2 = l11.isNull || "number" != typeof u2;
            (l11.leftCliff || g2 && g2.rightCliff) && !i10 && (n10 = true), f2 && !nE(e10) && d10 > 0 ? n10 = !o10.connectNulls : f2 && !e10 ? n10 = true : (0 === d10 || n10 ? c10 = [["M", l11.plotX, l11.plotY]] : s10.getPointSpline ? c10 = [s10.getPointSpline(t10, l11, d10)] : h10 ? (c10 = 1 === h10 ? [["L", g2.plotX, u2]] : 2 === h10 ? [["L", (g2.plotX + p10) / 2, g2.plotY], ["L", (g2.plotX + p10) / 2, u2]] : [["L", p10, g2.plotY]]).push(["L", p10, u2]) : c10 = [["L", p10, u2]], a10.push(l11.x), h10 && (a10.push(l11.x), 2 === h10 && a10.push(l11.x)), r10.push.apply(r10, c10), n10 = false);
          }), r10.xMap = a10, s10.graphPath = r10, r10;
        }
      }
      nB.defaultOptions = nL(rQ.defaultOptions, { legendSymbol: "lineMarker" }), rv.registerSeriesType("line", nB);
      let { seriesTypes: { line: nI } } = rv, { extend: nz, merge: nR, objectEach: nN, pick: nW } = ti;
      class nG extends nI {
        drawGraph() {
          this.areaPath = [], super.drawGraph.apply(this);
          let { areaPath: t10, options: e10 } = this;
          [this, ...this.zones].forEach((i10, s10) => {
            let o10 = {}, r10 = i10.fillColor || e10.fillColor, a10 = i10.area, n10 = a10 ? "animate" : "attr";
            a10 ? (a10.endX = this.preventGraphAnimation ? null : t10.xMap, a10.animate({ d: t10 })) : (o10.zIndex = 0, (a10 = i10.area = this.chart.renderer.path(t10).addClass("highcharts-area" + (s10 ? ` highcharts-zone-area-${s10 - 1} ` : " ") + (s10 && i10.className || "")).add(this.group)).isArea = true), this.chart.styledMode || (o10.fill = r10 || i10.color || this.color, o10["fill-opacity"] = r10 ? 1 : e10.fillOpacity ?? 0.75, a10.css({ pointerEvents: this.stickyTracking ? "none" : "auto" })), a10[n10](o10), a10.startX = t10.xMap, a10.shiftUnit = e10.step ? 2 : 1;
          });
        }
        getGraphPath(t10) {
          let e10, i10, s10;
          let o10 = nI.prototype.getGraphPath, r10 = this.options, a10 = r10.stacking, n10 = this.yAxis, h10 = [], l10 = [], d10 = this.index, c10 = n10.stacking.stacks[this.stackKey], p10 = r10.threshold, u2 = Math.round(n10.getThreshold(r10.threshold)), g2 = nW(r10.connectNulls, "percent" === a10), f2 = function(i11, s11, o11) {
            let r11 = t10[i11], g3 = a10 && c10[r11.x].points[d10], f3 = r11[o11 + "Null"] || 0, m3 = r11[o11 + "Cliff"] || 0, x3, y3, b3 = true;
            m3 || f3 ? (x3 = (f3 ? g3[0] : g3[1]) + m3, y3 = g3[0] + m3, b3 = !!f3) : !a10 && t10[s11] && t10[s11].isNull && (x3 = y3 = p10), void 0 !== x3 && (l10.push({ plotX: e10, plotY: null === x3 ? u2 : n10.getThreshold(x3), isNull: b3, isCliff: true }), h10.push({ plotX: e10, plotY: null === y3 ? u2 : n10.getThreshold(y3), doCurve: false }));
          };
          t10 = t10 || this.points, a10 && (t10 = this.getStackPoints(t10));
          for (let o11 = 0, r11 = t10.length; o11 < r11; ++o11) a10 || (t10[o11].leftCliff = t10[o11].rightCliff = t10[o11].leftNull = t10[o11].rightNull = void 0), i10 = t10[o11].isNull, e10 = nW(t10[o11].rectPlotX, t10[o11].plotX), s10 = a10 ? nW(t10[o11].yBottom, u2) : u2, i10 && !g2 || (g2 || f2(o11, o11 - 1, "left"), i10 && !a10 && g2 || (l10.push(t10[o11]), h10.push({ x: o11, plotX: e10, plotY: s10 })), g2 || f2(o11, o11 + 1, "right"));
          let m2 = o10.call(this, l10, true, true);
          h10.reversed = true;
          let x2 = o10.call(this, h10, true, true), y2 = x2[0];
          y2 && "M" === y2[0] && (x2[0] = ["L", y2[1], y2[2]]);
          let b2 = m2.concat(x2);
          b2.length && b2.push(["Z"]);
          let v2 = o10.call(this, l10, false, g2);
          return this.chart.series.length > 1 && a10 && l10.some((t11) => t11.isCliff) && (b2.hasStackedCliffs = v2.hasStackedCliffs = true), b2.xMap = m2.xMap, this.areaPath = b2, v2;
        }
        getStackPoints(t10) {
          let e10 = this, i10 = [], s10 = [], o10 = this.xAxis, r10 = this.yAxis, a10 = r10.stacking.stacks[this.stackKey], n10 = {}, h10 = r10.series, l10 = h10.length, d10 = r10.options.reversedStacks ? 1 : -1, c10 = h10.indexOf(e10);
          if (t10 = t10 || this.points, this.options.stacking) {
            for (let e11 = 0; e11 < t10.length; e11++) t10[e11].leftNull = t10[e11].rightNull = void 0, n10[t10[e11].x] = t10[e11];
            nN(a10, function(t11, e11) {
              null !== t11.total && s10.push(e11);
            }), s10.sort(function(t11, e11) {
              return t11 - e11;
            });
            let p10 = h10.map((t11) => t11.visible);
            s10.forEach(function(t11, u2) {
              let g2 = 0, f2, m2;
              if (n10[t11] && !n10[t11].isNull) i10.push(n10[t11]), [-1, 1].forEach(function(i11) {
                let o11 = 1 === i11 ? "rightNull" : "leftNull", r11 = a10[s10[u2 + i11]], g3 = 0;
                if (r11) {
                  let i12 = c10;
                  for (; i12 >= 0 && i12 < l10; ) {
                    let s11 = h10[i12].index;
                    !(f2 = r11.points[s11]) && (s11 === e10.index ? n10[t11][o11] = true : p10[i12] && (m2 = a10[t11].points[s11]) && (g3 -= m2[1] - m2[0])), i12 += d10;
                  }
                }
                n10[t11][1 === i11 ? "rightCliff" : "leftCliff"] = g3;
              });
              else {
                let e11 = c10;
                for (; e11 >= 0 && e11 < l10; ) {
                  let i11 = h10[e11].index;
                  if (f2 = a10[t11].points[i11]) {
                    g2 = f2[1];
                    break;
                  }
                  e11 += d10;
                }
                g2 = nW(g2, 0), g2 = r10.translate(g2, 0, 1, 0, 1), i10.push({ isNull: true, plotX: o10.translate(t11, 0, 0, 0, 1), x: t11, plotY: g2, yBottom: g2 });
              }
            });
          }
          return i10;
        }
      }
      nG.defaultOptions = nR(nI.defaultOptions, { threshold: 0, legendSymbol: "areaMarker" }), nz(nG.prototype, { singleStacks: false }), rv.registerSeriesType("area", nG);
      let { line: nX } = rv.seriesTypes, { merge: nH, pick: nF } = ti;
      class nY extends nX {
        getPointSpline(t10, e10, i10) {
          let s10, o10, r10, a10;
          let n10 = e10.plotX || 0, h10 = e10.plotY || 0, l10 = t10[i10 - 1], d10 = t10[i10 + 1];
          function c10(t11) {
            return t11 && !t11.isNull && false !== t11.doCurve && !e10.isCliff;
          }
          if (c10(l10) && c10(d10)) {
            let t11 = l10.plotX || 0, i11 = l10.plotY || 0, c11 = d10.plotX || 0, p11 = d10.plotY || 0, u2 = 0;
            s10 = (1.5 * n10 + t11) / 2.5, o10 = (1.5 * h10 + i11) / 2.5, r10 = (1.5 * n10 + c11) / 2.5, a10 = (1.5 * h10 + p11) / 2.5, r10 !== s10 && (u2 = (a10 - o10) * (r10 - n10) / (r10 - s10) + h10 - a10), o10 += u2, a10 += u2, o10 > i11 && o10 > h10 ? (o10 = Math.max(i11, h10), a10 = 2 * h10 - o10) : o10 < i11 && o10 < h10 && (o10 = Math.min(i11, h10), a10 = 2 * h10 - o10), a10 > p11 && a10 > h10 ? (a10 = Math.max(p11, h10), o10 = 2 * h10 - a10) : a10 < p11 && a10 < h10 && (a10 = Math.min(p11, h10), o10 = 2 * h10 - a10), e10.rightContX = r10, e10.rightContY = a10, e10.controlPoints = { low: [s10, o10], high: [r10, a10] };
          }
          let p10 = ["C", nF(l10.rightContX, l10.plotX, 0), nF(l10.rightContY, l10.plotY, 0), nF(s10, n10, 0), nF(o10, h10, 0), n10, h10];
          return l10.rightContX = l10.rightContY = void 0, p10;
        }
      }
      nY.defaultOptions = nH(nX.defaultOptions), rv.registerSeriesType("spline", nY);
      let nj = nY, { area: nU, area: { prototype: nV } } = rv.seriesTypes, { extend: n_, merge: n$ } = ti;
      class nZ extends nj {
      }
      nZ.defaultOptions = n$(nj.defaultOptions, nU.defaultOptions), n_(nZ.prototype, { getGraphPath: nV.getGraphPath, getStackPoints: nV.getStackPoints, drawGraph: nV.drawGraph }), rv.registerSeriesType("areaspline", nZ);
      let { animObject: nq } = t_, { parse: nK } = tL, { noop: nJ } = L, { clamp: nQ, crisp: n0, defined: n1, extend: n2, fireEvent: n3, isArray: n5, isNumber: n6, merge: n9, pick: n4, objectEach: n8 } = ti;
      class n7 extends rQ {
        animate(t10) {
          let e10, i10;
          let s10 = this, o10 = this.yAxis, r10 = o10.pos, a10 = o10.reversed, n10 = s10.options, { clipOffset: h10, inverted: l10 } = this.chart, d10 = {}, c10 = l10 ? "translateX" : "translateY";
          t10 && h10 ? (d10.scaleY = 1e-3, i10 = nQ(o10.toPixels(n10.threshold || 0), r10, r10 + o10.len), l10 ? (i10 += a10 ? -Math.floor(h10[0]) : Math.ceil(h10[2]), d10.translateX = i10 - o10.len) : (i10 += a10 ? Math.ceil(h10[0]) : -Math.floor(h10[2]), d10.translateY = i10), s10.clipBox && s10.setClip(), s10.group.attr(d10)) : (e10 = Number(s10.group.attr(c10)), s10.group.animate({ scaleY: 1 }, n2(nq(s10.options.animation), { step: function(t11, i11) {
            s10.group && (d10[c10] = e10 + i11.pos * (r10 - e10), s10.group.attr(d10));
          } })));
        }
        init(t10, e10) {
          super.init.apply(this, arguments);
          let i10 = this;
          (t10 = i10.chart).hasRendered && t10.series.forEach(function(t11) {
            t11.type === i10.type && (t11.isDirty = true);
          });
        }
        getColumnMetrics() {
          var _a, _b;
          let t10 = this, e10 = t10.options, i10 = t10.xAxis, s10 = t10.yAxis, o10 = i10.options.reversedStacks, r10 = i10.reversed && !o10 || !i10.reversed && o10, a10 = {}, n10, h10 = 0;
          false === e10.grouping ? h10 = 1 : t10.chart.series.forEach(function(e11) {
            let i11;
            let o11 = e11.yAxis, r11 = e11.options;
            e11.type === t10.type && e11.reserveSpace() && s10.len === o11.len && s10.pos === o11.pos && (r11.stacking && "group" !== r11.stacking ? (void 0 === a10[n10 = e11.stackKey] && (a10[n10] = h10++), i11 = a10[n10]) : false !== r11.grouping && (i11 = h10++), e11.columnIndex = i11);
          });
          let l10 = Math.min(Math.abs(i10.transA) * (!((_a = i10.brokenAxis) == null ? void 0 : _a.hasBreaks) && ((_b = i10.ordinal) == null ? void 0 : _b.slope) || e10.pointRange || i10.closestPointRange || i10.tickInterval || 1), i10.len), d10 = l10 * e10.groupPadding, c10 = (l10 - 2 * d10) / (h10 || 1), p10 = Math.min(e10.maxPointWidth || i10.len, n4(e10.pointWidth, c10 * (1 - 2 * e10.pointPadding))), u2 = (t10.columnIndex || 0) + (r10 ? 1 : 0);
          return t10.columnMetrics = { width: p10, offset: (c10 - p10) / 2 + (d10 + u2 * c10 - l10 / 2) * (r10 ? -1 : 1), paddedWidth: c10, columnCount: h10 }, t10.columnMetrics;
        }
        crispCol(t10, e10, i10, s10) {
          let o10 = this.borderWidth, r10 = this.chart.inverted;
          return s10 = n0(e10 + s10, o10, r10) - (e10 = n0(e10, o10, r10)), this.options.crisp && (i10 = n0(t10 + i10, o10) - (t10 = n0(t10, o10))), { x: t10, y: e10, width: i10, height: s10 };
        }
        adjustForMissingColumns(t10, e10, i10, s10) {
          var _a;
          if (!i10.isNull && s10.columnCount > 1) {
            let o10 = this.xAxis.series.filter((t11) => t11.visible).map((t11) => t11.index), r10 = 0, a10 = 0;
            n8((_a = this.xAxis.stacking) == null ? void 0 : _a.stacks, (t11) => {
              var _a2;
              let e11 = "number" == typeof i10.x ? (_a2 = t11[i10.x.toString()]) == null ? void 0 : _a2.points : void 0, s11 = e11 == null ? void 0 : e11[this.index], n11 = {};
              if (e11 && n5(s11)) {
                let t12 = this.index, i11 = Object.keys(e11).filter((t13) => !t13.match(",") && e11[t13] && e11[t13].length > 1).map(parseFloat).filter((t13) => -1 !== o10.indexOf(t13)).filter((e12) => {
                  let i12 = this.chart.series[e12].options, s12 = i12.stacking && i12.stack;
                  if (n1(s12)) {
                    if (n6(n11[s12])) return t12 === e12 && (t12 = n11[s12]), false;
                    n11[s12] = e12;
                  }
                  return true;
                }).sort((t13, e12) => e12 - t13);
                r10 = i11.indexOf(t12), a10 = i11.length;
              }
            }), r10 = this.xAxis.reversed ? a10 - 1 - r10 : r10;
            let n10 = (a10 - 1) * s10.paddedWidth + e10;
            t10 = (i10.plotX || 0) + n10 / 2 - e10 - r10 * s10.paddedWidth;
          }
          return t10;
        }
        translate() {
          let t10 = this, e10 = t10.chart, i10 = t10.options, s10 = t10.dense = t10.closestPointRange * t10.xAxis.transA < 2, o10 = t10.borderWidth = n4(i10.borderWidth, s10 ? 0 : 1), r10 = t10.xAxis, a10 = t10.yAxis, n10 = i10.threshold, h10 = n4(i10.minPointLength, 5), l10 = t10.getColumnMetrics(), d10 = l10.width, c10 = t10.pointXOffset = l10.offset, p10 = t10.dataMin, u2 = t10.dataMax, g2 = t10.translatedThreshold = a10.getThreshold(n10), f2 = t10.barW = Math.max(d10, 1 + 2 * o10);
          i10.pointPadding && i10.crisp && (f2 = Math.ceil(f2)), rQ.prototype.translate.apply(t10), t10.points.forEach(function(s11) {
            let o11 = n4(s11.yBottom, g2), m2 = 999 + Math.abs(o11), x2 = s11.plotX || 0, y2 = nQ(s11.plotY, -m2, a10.len + m2), b2, v2 = Math.min(y2, o11), k2 = Math.max(y2, o11) - v2, M2 = d10, w2 = x2 + c10, S2 = f2;
            h10 && Math.abs(k2) < h10 && (k2 = h10, b2 = !a10.reversed && !s11.negative || a10.reversed && s11.negative, n6(n10) && n6(u2) && s11.y === n10 && u2 <= n10 && (a10.min || 0) < n10 && (p10 !== u2 || (a10.max || 0) <= n10) && (b2 = !b2, s11.negative = !s11.negative), v2 = Math.abs(v2 - g2) > h10 ? o11 - h10 : g2 - (b2 ? h10 : 0)), n1(s11.options.pointWidth) && (w2 -= Math.round(((M2 = S2 = Math.ceil(s11.options.pointWidth)) - d10) / 2)), i10.centerInCategory && (w2 = t10.adjustForMissingColumns(w2, M2, s11, l10)), s11.barX = w2, s11.pointWidth = M2, s11.tooltipPos = e10.inverted ? [nQ(a10.len + a10.pos - e10.plotLeft - y2, a10.pos - e10.plotLeft, a10.len + a10.pos - e10.plotLeft), r10.len + r10.pos - e10.plotTop - w2 - S2 / 2, k2] : [r10.left - e10.plotLeft + w2 + S2 / 2, nQ(y2 + a10.pos - e10.plotTop, a10.pos - e10.plotTop, a10.len + a10.pos - e10.plotTop), k2], s11.shapeType = t10.pointClass.prototype.shapeType || "roundedRect", s11.shapeArgs = t10.crispCol(w2, s11.isNull ? g2 : v2, S2, s11.isNull ? 0 : k2);
          }), n3(this, "afterColumnTranslate");
        }
        drawGraph() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        }
        pointAttribs(t10, e10) {
          let i10 = this.options, s10 = this.pointAttrToOptions || {}, o10 = s10.stroke || "borderColor", r10 = s10["stroke-width"] || "borderWidth", a10, n10, h10, l10 = t10 && t10.color || this.color, d10 = t10 && t10[o10] || i10[o10] || l10, c10 = t10 && t10.options.dashStyle || i10.dashStyle, p10 = t10 && t10[r10] || i10[r10] || this[r10] || 0, u2 = n4(t10 && t10.opacity, i10.opacity, 1);
          t10 && this.zones.length && (n10 = t10.getZone(), l10 = t10.options.color || n10 && (n10.color || t10.nonZonedColor) || this.color, n10 && (d10 = n10.borderColor || d10, c10 = n10.dashStyle || c10, p10 = n10.borderWidth || p10)), e10 && t10 && (h10 = (a10 = n9(i10.states[e10], t10.options.states && t10.options.states[e10] || {})).brightness, l10 = a10.color || void 0 !== h10 && nK(l10).brighten(a10.brightness).get() || l10, d10 = a10[o10] || d10, p10 = a10[r10] || p10, c10 = a10.dashStyle || c10, u2 = n4(a10.opacity, u2));
          let g2 = { fill: l10, stroke: d10, "stroke-width": p10, opacity: u2 };
          return c10 && (g2.dashstyle = c10), g2;
        }
        drawPoints(t10 = this.points) {
          let e10;
          let i10 = this, s10 = this.chart, o10 = i10.options, r10 = s10.renderer, a10 = o10.animationLimit || 250;
          t10.forEach(function(t11) {
            let n10 = t11.plotY, h10 = t11.graphic, l10 = !!h10, d10 = h10 && s10.pointCount < a10 ? "animate" : "attr";
            n6(n10) && null !== t11.y ? (e10 = t11.shapeArgs, h10 && t11.hasNewShapeType() && (h10 = h10.destroy()), i10.enabledDataSorting && (t11.startXPos = i10.xAxis.reversed ? -(e10 && e10.width || 0) : i10.xAxis.width), !h10 && (t11.graphic = h10 = r10[t11.shapeType](e10).add(t11.group || i10.group), h10 && i10.enabledDataSorting && s10.hasRendered && s10.pointCount < a10 && (h10.attr({ x: t11.startXPos }), l10 = true, d10 = "animate")), h10 && l10 && h10[d10](n9(e10)), s10.styledMode || h10[d10](i10.pointAttribs(t11, t11.selected && "select")).shadow(false !== t11.allowShadow && o10.shadow), h10 && (h10.addClass(t11.getClassName(), true), h10.attr({ visibility: t11.visible ? "inherit" : "hidden" }))) : h10 && (t11.graphic = h10.destroy());
          });
        }
        drawTracker(t10 = this.points) {
          let e10;
          let i10 = this, s10 = i10.chart, o10 = s10.pointer, r10 = function(t11) {
            o10 == null ? void 0 : o10.normalize(t11);
            let e11 = o10 == null ? void 0 : o10.getPointFromEvent(t11), r11 = !s10.scrollablePlotArea || s10.isInsidePlot(t11.chartX - s10.plotLeft, t11.chartY - s10.plotTop, { visiblePlotOnly: true });
            o10 && e11 && i10.options.enableMouseTracking && r11 && (o10.isDirectTouch = true, e11.onMouseOver(t11));
          };
          t10.forEach(function(t11) {
            e10 = n5(t11.dataLabels) ? t11.dataLabels : t11.dataLabel ? [t11.dataLabel] : [], t11.graphic && (t11.graphic.element.point = t11), e10.forEach(function(e11) {
              (e11.div || e11.element).point = t11;
            });
          }), i10._hasTracking || (i10.trackerGroups.forEach(function(t11) {
            i10[t11] && (i10[t11].addClass("highcharts-tracker").on("mouseover", r10).on("mouseout", function(t12) {
              o10 == null ? void 0 : o10.onTrackerMouseOut(t12);
            }).on("touchstart", r10), !s10.styledMode && i10.options.cursor && i10[t11].css({ cursor: i10.options.cursor }));
          }), i10._hasTracking = true), n3(this, "afterDrawTracker");
        }
        remove() {
          let t10 = this, e10 = t10.chart;
          e10.hasRendered && e10.series.forEach(function(e11) {
            e11.type === t10.type && (e11.isDirty = true);
          }), rQ.prototype.remove.apply(t10, arguments);
        }
      }
      n7.defaultOptions = n9(rQ.defaultOptions, { borderRadius: 3, centerInCategory: false, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: false, brightness: 0.1 }, select: { color: "#cccccc", borderColor: "#000000" } }, dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 }, startFromThreshold: true, stickyTracking: false, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" }), n2(n7.prototype, { directTouch: true, getSymbol: nJ, negStacks: true, trackerGroups: ["group", "dataLabelsGroup"] }), rv.registerSeriesType("column", n7);
      let ht = n7, { getDeferredAnimation: he } = t_, { format: hi } = eg, { defined: hs, extend: ho, fireEvent: hr, getAlignFactor: ha, isArray: hn, isString: hh, merge: hl, objectEach: hd, pick: hc, pInt: hp, splat: hu } = ti;
      !function(t10) {
        function e10() {
          return h10(this).some((t11) => t11 == null ? void 0 : t11.enabled);
        }
        function i10(t11, e11, i11, s11, o11) {
          var _a;
          let { chart: r11, enabledDataSorting: a11 } = this, n11 = this.isCartesian && r11.inverted, h11 = t11.plotX, l11 = t11.plotY, d10 = i11.rotation || 0, c10 = hs(h11) && hs(l11) && r11.isInsidePlot(h11, Math.round(l11), { inverted: n11, paneCoordinates: true, series: this }), p10 = 0 === d10 && "justify" === hc(i11.overflow, a11 ? "none" : "justify"), u2 = this.visible && false !== t11.visible && hs(h11) && (t11.series.forceDL || a11 && !p10 || c10 || hc(i11.inside, !!this.options.stacking) && s11 && r11.isInsidePlot(h11, n11 ? s11.x + 1 : s11.y + s11.height - 1, { inverted: n11, paneCoordinates: true, series: this })), g2 = t11.pos();
          if (u2 && g2) {
            var f2;
            let h12 = e11.getBBox(), l12 = e11.getBBox(void 0, 0);
            if (s11 = ho({ x: g2[0], y: Math.round(g2[1]), width: 0, height: 0 }, s11 || {}), "plotEdges" === i11.alignTo && this.isCartesian && (s11[n11 ? "x" : "y"] = 0, s11[n11 ? "width" : "height"] = ((_a = this.yAxis) == null ? void 0 : _a.len) || 0), ho(i11, { width: h12.width, height: h12.height }), f2 = s11, a11 && this.xAxis && !p10 && this.setDataLabelStartPos(t11, e11, o11, c10, f2), e11.align(hl(i11, { width: l12.width, height: l12.height }), false, s11, false), e11.alignAttr.x += ha(i11.align) * (l12.width - h12.width), e11.alignAttr.y += ha(i11.verticalAlign) * (l12.height - h12.height), e11[e11.placed ? "animate" : "attr"]({ "text-align": e11.alignAttr["text-align"] || "center", x: e11.alignAttr.x + (h12.width - l12.width) / 2, y: e11.alignAttr.y + (h12.height - l12.height) / 2, rotationOriginX: (e11.width || 0) / 2, rotationOriginY: (e11.height || 0) / 2 }), p10 && s11.height >= 0) this.justifyDataLabel(e11, i11, e11.alignAttr, h12, s11, o11);
            else if (hc(i11.crop, true)) {
              let { x: t12, y: i12 } = e11.alignAttr;
              u2 = r11.isInsidePlot(t12, i12, { paneCoordinates: true, series: this }) && r11.isInsidePlot(t12 + h12.width - 1, i12 + h12.height - 1, { paneCoordinates: true, series: this });
            }
            i11.shape && !d10 && e11[o11 ? "attr" : "animate"]({ anchorX: g2[0], anchorY: g2[1] });
          }
          o11 && a11 && (e11.placed = false), u2 || a11 && !p10 ? (e11.show(), e11.placed = true) : (e11.hide(), e11.placed = false);
        }
        function s10() {
          return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
        }
        function o10(t11) {
          let e11 = this.hasRendered || 0, i11 = this.initDataLabelsGroup().attr({ opacity: +e11 });
          return !e11 && i11 && (this.visible && i11.show(), this.options.animation ? i11.animate({ opacity: 1 }, t11) : i11.attr({ opacity: 1 })), i11;
        }
        function r10(t11) {
          var _a;
          let e11;
          t11 = t11 || this.points;
          let i11 = this, s11 = i11.chart, o11 = i11.options, r11 = s11.renderer, { backgroundColor: a11, plotBackgroundColor: l11 } = s11.options.chart, d10 = r11.getContrast(hh(l11) && l11 || hh(a11) && a11 || "#000000"), c10 = h10(i11), { animation: p10, defer: u2 } = c10[0], g2 = u2 ? he(s11, p10, i11) : { defer: 0, duration: 0 };
          hr(this, "drawDataLabels"), ((_a = i11.hasDataLabels) == null ? void 0 : _a.call(i11)) && (e11 = this.initDataLabels(g2), t11.forEach((t12) => {
            var _a2, _b;
            let a12 = t12.dataLabels || [];
            hu(n10(c10, t12.dlOptions || ((_a2 = t12.options) == null ? void 0 : _a2.dataLabels))).forEach((n11, h12) => {
              let l12 = n11.enabled && (t12.visible || t12.dataLabelOnHidden) && (!t12.isNull || t12.dataLabelOnNull) && function(t13, e12) {
                let i12 = e12.filter;
                if (i12) {
                  let e13 = i12.operator, s12 = t13[i12.property], o12 = i12.value;
                  return ">" === e13 && s12 > o12 || "<" === e13 && s12 < o12 || ">=" === e13 && s12 >= o12 || "<=" === e13 && s12 <= o12 || "==" === e13 && s12 == o12 || "===" === e13 && s12 === o12 || "!=" === e13 && s12 != o12 || "!==" === e13 && s12 !== o12;
                }
                return true;
              }(t12, n11), { backgroundColor: c11, borderColor: p11, distance: u3, style: g3 = {} } = n11, f2, m2, x2, y2 = {}, b2 = a12[h12], v2 = !b2, k2;
              l12 && (m2 = hs(f2 = hc(n11[t12.formatPrefix + "Format"], n11.format)) ? hi(f2, t12, s11) : (n11[t12.formatPrefix + "Formatter"] || n11.formatter).call(t12, n11), x2 = n11.rotation, !s11.styledMode && (g3.color = hc(n11.color, g3.color, hh(i11.color) ? i11.color : void 0, "#000000"), "contrast" === g3.color ? ("none" !== c11 && (k2 = c11), t12.contrastColor = r11.getContrast("auto" !== k2 && k2 || t12.color || i11.color), g3.color = k2 || !hs(u3) && n11.inside || 0 > hp(u3 || 0) || o11.stacking ? t12.contrastColor : d10) : delete t12.contrastColor, o11.cursor && (g3.cursor = o11.cursor)), y2 = { r: n11.borderRadius || 0, rotation: x2, padding: n11.padding, zIndex: 1 }, s11.styledMode || (y2.fill = "auto" === c11 ? t12.color : c11, y2.stroke = "auto" === p11 ? t12.color : p11, y2["stroke-width"] = n11.borderWidth), hd(y2, (t13, e12) => {
                void 0 === t13 && delete y2[e12];
              })), !b2 || l12 && hs(m2) && !!b2.div == !!n11.useHTML && (b2.rotation && n11.rotation || b2.rotation === n11.rotation) || (b2 = void 0, v2 = true), l12 && hs(m2) && (b2 ? y2.text = m2 : (b2 = r11.label(m2, 0, 0, n11.shape, void 0, void 0, n11.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + t12.colorIndex + " " + (n11.className || "") + (n11.useHTML ? " highcharts-tracker" : "")), b2 && (b2.options = n11, b2.attr(y2), s11.styledMode ? g3.width && b2.css({ width: g3.width, textOverflow: g3.textOverflow, whiteSpace: g3.whiteSpace }) : b2.css(g3).shadow(n11.shadow), hr(b2, "beforeAddingDataLabel", { labelOptions: n11, point: t12 }), b2.added || b2.add(e11), i11.alignDataLabel(t12, b2, n11, void 0, v2), b2.isActive = true, a12[h12] && a12[h12] !== b2 && a12[h12].destroy(), a12[h12] = b2));
            });
            let h11 = a12.length;
            for (; h11--; ) a12[h11] && a12[h11].isActive ? a12[h11].isActive = false : ((_b = a12[h11]) == null ? void 0 : _b.destroy(), a12.splice(h11, 1));
            t12.dataLabel = a12[0], t12.dataLabels = a12;
          })), hr(this, "afterDrawDataLabels");
        }
        function a10(t11, e11, i11, s11, o11, r11) {
          let a11 = this.chart, n11 = e11.align, h11 = e11.verticalAlign, l11 = t11.box ? 0 : t11.padding || 0, d10 = a11.inverted ? this.yAxis : this.xAxis, c10 = d10 ? d10.left - a11.plotLeft : 0, p10 = a11.inverted ? this.xAxis : this.yAxis, u2 = p10 ? p10.top - a11.plotTop : 0, { x: g2 = 0, y: f2 = 0 } = e11, m2, x2;
          return (m2 = (i11.x || 0) + l11 + c10) < 0 && ("right" === n11 && g2 >= 0 ? (e11.align = "left", e11.inside = true) : g2 -= m2, x2 = true), (m2 = (i11.x || 0) + s11.width - l11 + c10) > a11.plotWidth && ("left" === n11 && g2 <= 0 ? (e11.align = "right", e11.inside = true) : g2 += a11.plotWidth - m2, x2 = true), (m2 = i11.y + l11 + u2) < 0 && ("bottom" === h11 && f2 >= 0 ? (e11.verticalAlign = "top", e11.inside = true) : f2 -= m2, x2 = true), (m2 = (i11.y || 0) + s11.height - l11 + u2) > a11.plotHeight && ("top" === h11 && f2 <= 0 ? (e11.verticalAlign = "bottom", e11.inside = true) : f2 += a11.plotHeight - m2, x2 = true), x2 && (e11.x = g2, e11.y = f2, t11.placed = !r11, t11.align(e11, void 0, o11)), x2;
        }
        function n10(t11, e11) {
          let i11 = [], s11;
          if (hn(t11) && !hn(e11)) i11 = t11.map(function(t12) {
            return hl(t12, e11);
          });
          else if (hn(e11) && !hn(t11)) i11 = e11.map(function(e12) {
            return hl(t11, e12);
          });
          else if (hn(t11) || hn(e11)) {
            if (hn(t11) && hn(e11)) for (s11 = Math.max(t11.length, e11.length); s11--; ) i11[s11] = hl(t11[s11], e11[s11]);
          } else i11 = hl(t11, e11);
          return i11;
        }
        function h10(t11) {
          var _a, _b;
          let e11 = t11.chart.options.plotOptions;
          return hu(n10(n10((_a = e11 == null ? void 0 : e11.series) == null ? void 0 : _a.dataLabels, (_b = e11 == null ? void 0 : e11[t11.type]) == null ? void 0 : _b.dataLabels), t11.options.dataLabels));
        }
        function l10(t11, e11, i11, s11, o11) {
          let r11 = this.chart, a11 = r11.inverted, n11 = this.xAxis, h11 = n11.reversed, l11 = ((a11 ? e11.height : e11.width) || 0) / 2, d10 = t11.pointWidth, c10 = d10 ? d10 / 2 : 0;
          e11.startXPos = a11 ? o11.x : h11 ? -l11 - c10 : n11.width - l11 + c10, e11.startYPos = a11 ? h11 ? this.yAxis.height - l11 + c10 : -l11 - c10 : o11.y, s11 ? "hidden" === e11.visibility && (e11.show(), e11.attr({ opacity: 0 }).animate({ opacity: 1 })) : e11.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, e11.hide), r11.hasRendered && (i11 && e11.attr({ x: e11.startXPos, y: e11.startYPos }), e11.placed = true);
        }
        t10.compose = function(t11) {
          let n11 = t11.prototype;
          n11.initDataLabels || (n11.initDataLabels = o10, n11.initDataLabelsGroup = s10, n11.alignDataLabel = i10, n11.drawDataLabels = r10, n11.justifyDataLabel = a10, n11.setDataLabelStartPos = l10, n11.hasDataLabels = e10);
        };
      }(x || (x = {}));
      let hg = x, { composed: hf } = L, { series: hm } = rv, { merge: hx, pick: hy, pushUnique: hb } = ti;
      !function(t10) {
        function e10(t11, e11, i10, s10, o10) {
          let r10 = this.chart.inverted, a10 = t11.series, n10 = (a10.xAxis ? a10.xAxis.len : this.chart.plotSizeX) || 0, h10 = (a10.yAxis ? a10.yAxis.len : this.chart.plotSizeY) || 0, l10 = t11.dlBox || t11.shapeArgs, d10 = hy(t11.below, t11.plotY > hy(this.translatedThreshold, h10)), c10 = hy(i10.inside, !!this.options.stacking);
          if (l10) {
            if (s10 = hx(l10), !("allow" === i10.overflow && false === i10.crop)) {
              s10.y < 0 && (s10.height += s10.y, s10.y = 0);
              let t12 = s10.y + s10.height - h10;
              t12 > 0 && t12 < s10.height - 1 && (s10.height -= t12);
            }
            r10 && (s10 = { x: h10 - s10.y - s10.height, y: n10 - s10.x - s10.width, width: s10.height, height: s10.width }), c10 || (r10 ? (s10.x += d10 ? 0 : s10.width, s10.width = 0) : (s10.y += d10 ? s10.height : 0, s10.height = 0));
          }
          i10.align = hy(i10.align, !r10 || c10 ? "center" : d10 ? "right" : "left"), i10.verticalAlign = hy(i10.verticalAlign, r10 || c10 ? "middle" : d10 ? "top" : "bottom"), hm.prototype.alignDataLabel.call(this, t11, e11, i10, s10, o10), i10.inside && t11.contrastColor && e11.css({ color: t11.contrastColor });
        }
        t10.compose = function(t11) {
          hg.compose(hm), hb(hf, "ColumnDataLabel") && (t11.prototype.alignDataLabel = e10);
        };
      }(y || (y = {}));
      let hv = y, { extend: hk, merge: hM } = ti;
      class hw extends ht {
      }
      hw.defaultOptions = hM(ht.defaultOptions, {}), hk(hw.prototype, { inverted: true }), rv.registerSeriesType("bar", hw);
      let { column: hS, line: hA } = rv.seriesTypes, { addEvent: hT, extend: hC, merge: hP } = ti;
      class hO extends hA {
        applyJitter() {
          let t10 = this, e10 = this.options.jitter, i10 = this.points.length;
          e10 && this.points.forEach(function(s10, o10) {
            ["x", "y"].forEach(function(r10, a10) {
              if (e10[r10] && !s10.isNull) {
                let n10 = `plot${r10.toUpperCase()}`, h10 = t10[`${r10}Axis`], l10 = e10[r10] * h10.transA;
                if (h10 && !h10.logarithmic) {
                  let t11 = Math.max(0, (s10[n10] || 0) - l10), e11 = Math.min(h10.len, (s10[n10] || 0) + l10);
                  s10[n10] = t11 + (e11 - t11) * function(t12) {
                    let e12 = 1e4 * Math.sin(t12);
                    return e12 - Math.floor(e12);
                  }(o10 + a10 * i10), "x" === r10 && (s10.clientX = s10.plotX);
                }
              }
            });
          });
        }
        drawGraph() {
          this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
        }
      }
      hO.defaultOptions = hP(hA.defaultOptions, { lineWidth: 0, findNearestPointBy: "xy", jitter: { x: 0, y: 0 }, marker: { enabled: true }, tooltip: { headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } }), hC(hO.prototype, { drawTracker: hS.prototype.drawTracker, sorted: false, requireSorting: false, noSharedTooltip: true, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"] }), hT(hO, "afterTranslate", function() {
        this.applyJitter();
      }), rv.registerSeriesType("scatter", hO);
      let { deg2rad: hE } = L, { fireEvent: hL, isNumber: hD, pick: hB, relativeLength: hI } = ti;
      !function(t10) {
        t10.getCenter = function() {
          let t11 = this.options, e10 = this.chart, i10 = 2 * (t11.slicedOffset || 0), s10 = e10.plotWidth - 2 * i10, o10 = e10.plotHeight - 2 * i10, r10 = t11.center, a10 = Math.min(s10, o10), n10 = t11.thickness, h10, l10 = t11.size, d10 = t11.innerSize || 0, c10, p10;
          "string" == typeof l10 && (l10 = parseFloat(l10)), "string" == typeof d10 && (d10 = parseFloat(d10));
          let u2 = [hB(r10 == null ? void 0 : r10[0], "50%"), hB(r10 == null ? void 0 : r10[1], "50%"), hB(l10 && l10 < 0 ? void 0 : t11.size, "100%"), hB(d10 && d10 < 0 ? void 0 : t11.innerSize || 0, "0%")];
          for (!e10.angular || this instanceof rQ || (u2[3] = 0), c10 = 0; c10 < 4; ++c10) p10 = u2[c10], h10 = c10 < 2 || 2 === c10 && /%$/.test(p10), u2[c10] = hI(p10, [s10, o10, a10, u2[2]][c10]) + (h10 ? i10 : 0);
          return u2[3] > u2[2] && (u2[3] = u2[2]), hD(n10) && 2 * n10 < u2[2] && n10 > 0 && (u2[3] = u2[2] - 2 * n10), hL(this, "afterGetCenter", { positions: u2 }), u2;
        }, t10.getStartAndEndRadians = function(t11, e10) {
          let i10 = hD(t11) ? t11 : 0, s10 = hD(e10) && e10 > i10 && e10 - i10 < 360 ? e10 : i10 + 360;
          return { start: hE * (i10 + -90), end: hE * (s10 + -90) };
        };
      }(b || (b = {}));
      let hz = b, { setAnimation: hR } = t_, { addEvent: hN, defined: hW, extend: hG, isNumber: hX, pick: hH, relativeLength: hF } = ti;
      class hY extends oK {
        getConnectorPath(t10) {
          let e10 = t10.dataLabelPosition, i10 = t10.options || {}, s10 = i10.connectorShape, o10 = this.connectorShapes[s10] || s10;
          return e10 && o10.call(this, { ...e10.computed, alignment: e10.alignment }, e10.connectorPosition, i10) || [];
        }
        getTranslate() {
          return this.sliced && this.slicedTranslation || { translateX: 0, translateY: 0 };
        }
        haloPath(t10) {
          let e10 = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e10.x, e10.y, e10.r + t10, e10.r + t10, { innerR: e10.r - 1, start: e10.start, end: e10.end, borderRadius: e10.borderRadius });
        }
        constructor(t10, e10, i10) {
          super(t10, e10, i10), this.half = 0, this.name ?? (this.name = "Slice");
          let s10 = (t11) => {
            this.slice("select" === t11.type);
          };
          hN(this, "select", s10), hN(this, "unselect", s10);
        }
        isValid() {
          return hX(this.y) && this.y >= 0;
        }
        setVisible(t10, e10 = true) {
          t10 !== this.visible && this.update({ visible: t10 ?? !this.visible }, e10, void 0, false);
        }
        slice(t10, e10, i10) {
          let s10 = this.series;
          hR(i10, s10.chart), e10 = hH(e10, true), this.sliced = this.options.sliced = t10 = hW(t10) ? t10 : !this.sliced, s10.options.data[s10.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
        }
      }
      hG(hY.prototype, { connectorShapes: { fixedOffset: function(t10, e10, i10) {
        let s10 = e10.breakAt, o10 = e10.touchingSliceAt, r10 = i10.softConnector ? ["C", t10.x + ("left" === t10.alignment ? -5 : 5), t10.y, 2 * s10.x - o10.x, 2 * s10.y - o10.y, s10.x, s10.y] : ["L", s10.x, s10.y];
        return [["M", t10.x, t10.y], r10, ["L", o10.x, o10.y]];
      }, straight: function(t10, e10) {
        let i10 = e10.touchingSliceAt;
        return [["M", t10.x, t10.y], ["L", i10.x, i10.y]];
      }, crookedLine: function(t10, e10, i10) {
        let { angle: s10 = this.angle || 0, breakAt: o10, touchingSliceAt: r10 } = e10, { series: a10 } = this, [n10, h10, l10] = a10.center, d10 = l10 / 2, { plotLeft: c10, plotWidth: p10 } = a10.chart, u2 = "left" === t10.alignment, { x: g2, y: f2 } = t10, m2 = o10.x;
        if (i10.crookDistance) {
          let t11 = hF(i10.crookDistance, 1);
          m2 = u2 ? n10 + d10 + (p10 + c10 - n10 - d10) * (1 - t11) : c10 + (n10 - d10) * t11;
        } else m2 = n10 + (h10 - f2) * Math.tan(s10 - Math.PI / 2);
        let x2 = [["M", g2, f2]];
        return (u2 ? m2 <= g2 && m2 >= o10.x : m2 >= g2 && m2 <= o10.x) && x2.push(["L", m2, f2]), x2.push(["L", o10.x, o10.y], ["L", r10.x, r10.y]), x2;
      } } });
      let { getStartAndEndRadians: hj } = hz, { noop: hU } = L, { clamp: hV, extend: h_, fireEvent: h$, merge: hZ, pick: hq } = ti;
      class hK extends rQ {
        animate(t10) {
          let e10 = this, i10 = e10.points, s10 = e10.startAngleRad;
          t10 || i10.forEach(function(t11) {
            let i11 = t11.graphic, o10 = t11.shapeArgs;
            i11 && o10 && (i11.attr({ r: hq(t11.startR, e10.center && e10.center[3] / 2), start: s10, end: s10 }), i11.animate({ r: o10.r, start: o10.start, end: o10.end }, e10.options.animation));
          });
        }
        drawEmpty() {
          let t10, e10;
          let i10 = this.startAngleRad, s10 = this.endAngleRad, o10 = this.options;
          0 === this.total && this.center ? (t10 = this.center[0], e10 = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t10, e10, this.center[1] / 2, 0, i10, s10).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({ d: ir.arc(t10, e10, this.center[2] / 2, 0, { start: i10, end: s10, innerR: this.center[3] / 2 }) }), this.chart.styledMode || this.graph.attr({ "stroke-width": o10.borderWidth, fill: o10.fillColor || "none", stroke: o10.color || "#cccccc" })) : this.graph && (this.graph = this.graph.destroy());
        }
        drawPoints() {
          let t10 = this.chart.renderer;
          this.points.forEach(function(e10) {
            e10.graphic && e10.hasNewShapeType() && (e10.graphic = e10.graphic.destroy()), e10.graphic || (e10.graphic = t10[e10.shapeType](e10.shapeArgs).add(e10.series.group), e10.delayedRendering = true);
          });
        }
        generatePoints() {
          super.generatePoints(), this.updateTotals();
        }
        getX(t10, e10, i10, s10) {
          let o10 = this.center, r10 = this.radii ? this.radii[i10.index] || 0 : o10[2] / 2, a10 = s10.dataLabelPosition, n10 = (a10 == null ? void 0 : a10.distance) || 0, h10 = Math.asin(hV((t10 - o10[1]) / (r10 + n10), -1, 1));
          return o10[0] + Math.cos(h10) * (r10 + n10) * (e10 ? -1 : 1) + (n10 > 0 ? (e10 ? -1 : 1) * (s10.padding || 0) : 0);
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        redrawPoints() {
          let t10, e10, i10, s10;
          let o10 = this, r10 = o10.chart;
          this.drawEmpty(), o10.group && !r10.styledMode && o10.group.shadow(o10.options.shadow), o10.points.forEach(function(a10) {
            let n10 = {};
            e10 = a10.graphic, !a10.isNull && e10 ? (s10 = a10.shapeArgs, t10 = a10.getTranslate(), r10.styledMode || (i10 = o10.pointAttribs(a10, a10.selected && "select")), a10.delayedRendering ? (e10.setRadialReference(o10.center).attr(s10).attr(t10), r10.styledMode || e10.attr(i10).attr({ "stroke-linejoin": "round" }), a10.delayedRendering = false) : (e10.setRadialReference(o10.center), r10.styledMode || hZ(true, n10, i10), hZ(true, n10, s10, t10), e10.animate(n10)), e10.attr({ visibility: a10.visible ? "inherit" : "hidden" }), e10.addClass(a10.getClassName(), true)) : e10 && (a10.graphic = e10.destroy());
          });
        }
        sortByAngle(t10, e10) {
          t10.sort(function(t11, i10) {
            return void 0 !== t11.angle && (i10.angle - t11.angle) * e10;
          });
        }
        translate(t10) {
          h$(this, "translate"), this.generatePoints();
          let e10 = this.options, i10 = e10.slicedOffset, s10 = hj(e10.startAngle, e10.endAngle), o10 = this.startAngleRad = s10.start, r10 = (this.endAngleRad = s10.end) - o10, a10 = this.points, n10 = e10.ignoreHiddenPoint, h10 = a10.length, l10, d10, c10, p10, u2, g2, f2, m2 = 0;
          for (t10 || (this.center = t10 = this.getCenter()), g2 = 0; g2 < h10; g2++) {
            f2 = a10[g2], l10 = o10 + m2 * r10, f2.isValid() && (!n10 || f2.visible) && (m2 += f2.percentage / 100), d10 = o10 + m2 * r10;
            let e11 = { x: t10[0], y: t10[1], r: t10[2] / 2, innerR: t10[3] / 2, start: Math.round(1e3 * l10) / 1e3, end: Math.round(1e3 * d10) / 1e3 };
            f2.shapeType = "arc", f2.shapeArgs = e11, (c10 = (d10 + l10) / 2) > 1.5 * Math.PI ? c10 -= 2 * Math.PI : c10 < -Math.PI / 2 && (c10 += 2 * Math.PI), f2.slicedTranslation = { translateX: Math.round(Math.cos(c10) * i10), translateY: Math.round(Math.sin(c10) * i10) }, p10 = Math.cos(c10) * t10[2] / 2, u2 = Math.sin(c10) * t10[2] / 2, f2.tooltipPos = [t10[0] + 0.7 * p10, t10[1] + 0.7 * u2], f2.half = c10 < -Math.PI / 2 || c10 > Math.PI / 2 ? 1 : 0, f2.angle = c10;
          }
          h$(this, "afterTranslate");
        }
        updateTotals() {
          let t10 = this.points, e10 = t10.length, i10 = this.options.ignoreHiddenPoint, s10, o10, r10 = 0;
          for (s10 = 0; s10 < e10; s10++) (o10 = t10[s10]).isValid() && (!i10 || o10.visible) && (r10 += o10.y);
          for (s10 = 0, this.total = r10; s10 < e10; s10++) (o10 = t10[s10]).percentage = r10 > 0 && (o10.visible || !i10) ? o10.y / r10 * 100 : 0, o10.total = r10;
        }
      }
      hK.defaultOptions = hZ(rQ.defaultOptions, { borderRadius: 3, center: [null, null], clip: false, colorByPoint: true, dataLabels: { connectorPadding: 5, connectorShape: "crookedLine", crookDistance: void 0, distance: 30, enabled: true, formatter: function() {
        return this.isNull ? void 0 : this.name;
      }, softConnector: true, x: 0 }, fillColor: void 0, ignoreHiddenPoint: true, inactiveOtherPoints: true, legendType: "point", marker: null, size: null, showInLegend: false, slicedOffset: 10, stickyTracking: false, tooltip: { followPointer: true }, borderColor: "#ffffff", borderWidth: 1, lineWidth: void 0, states: { hover: { brightness: 0.1 } } }), h_(hK.prototype, { axisTypes: [], directTouch: true, drawGraph: void 0, drawTracker: ht.prototype.drawTracker, getCenter: hz.getCenter, getSymbol: hU, invertible: false, isCartesian: false, noSharedTooltip: true, pointAttribs: ht.prototype.pointAttribs, pointClass: hY, requireSorting: false, searchPoint: hU, trackerGroups: ["group", "dataLabelsGroup"] }), rv.registerSeriesType("pie", hK);
      let { composed: hJ, noop: hQ } = L, { distribute: h0 } = ev, { series: h1 } = rv, { arrayMax: h2, clamp: h3, defined: h5, pick: h6, pushUnique: h9, relativeLength: h4 } = ti;
      !function(t10) {
        let e10 = { radialDistributionY: function(t11, e11) {
          var _a;
          return (((_a = e11.dataLabelPosition) == null ? void 0 : _a.top) || 0) + t11.distributeBox.pos;
        }, radialDistributionX: function(t11, e11, i11, s11, o11) {
          let r11 = o11.dataLabelPosition;
          return t11.getX(i11 < ((r11 == null ? void 0 : r11.top) || 0) + 2 || i11 > ((r11 == null ? void 0 : r11.bottom) || 0) - 2 ? s11 : i11, e11.half, e11, o11);
        }, justify: function(t11, e11, i11, s11) {
          var _a;
          return s11[0] + (t11.half ? -1 : 1) * (i11 + (((_a = e11.dataLabelPosition) == null ? void 0 : _a.distance) || 0));
        }, alignToPlotEdges: function(t11, e11, i11, s11) {
          let o11 = t11.getBBox().width;
          return e11 ? o11 + s11 : i11 - o11 - s11;
        }, alignToConnectors: function(t11, e11, i11, s11) {
          let o11 = 0, r11;
          return t11.forEach(function(t12) {
            (r11 = t12.dataLabel.getBBox().width) > o11 && (o11 = r11);
          }), e11 ? o11 + s11 : i11 - o11 - s11;
        } };
        function i10(t11, e11) {
          let i11 = Math.PI / 2, { start: s11 = 0, end: o11 = 0 } = t11.shapeArgs || {}, r11 = t11.angle || 0;
          e11 > 0 && s11 < i11 && o11 > i11 && r11 > i11 / 2 && r11 < 1.5 * i11 && (r11 = r11 <= i11 ? Math.max(i11 / 2, (s11 + i11) / 2) : Math.min(1.5 * i11, (i11 + o11) / 2));
          let { center: a10, options: n10 } = this, h10 = a10[2] / 2, l10 = Math.cos(r11), d10 = Math.sin(r11), c10 = a10[0] + l10 * h10, p10 = a10[1] + d10 * h10, u2 = Math.min((n10.slicedOffset || 0) + (n10.borderWidth || 0), e11 / 5);
          return { natural: { x: c10 + l10 * e11, y: p10 + d10 * e11 }, computed: {}, alignment: e11 < 0 ? "center" : t11.half ? "right" : "left", connectorPosition: { angle: r11, breakAt: { x: c10 + l10 * u2, y: p10 + d10 * u2 }, touchingSliceAt: { x: c10, y: p10 } }, distance: e11 };
        }
        function s10() {
          var _a;
          let t11 = this, e11 = t11.points, i11 = t11.chart, s11 = i11.plotWidth, o11 = i11.plotHeight, r11 = i11.plotLeft, a10 = Math.round(i11.chartWidth / 3), n10 = t11.center, h10 = n10[2] / 2, l10 = n10[1], d10 = [[], []], c10 = [0, 0, 0, 0], p10 = t11.dataLabelPositioners, u2, g2, f2, m2 = 0;
          t11.visible && ((_a = t11.hasDataLabels) == null ? void 0 : _a.call(t11)) && (e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((t13) => {
              t13.shortened && (t13.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), t13.shortened = false);
            });
          }), h1.prototype.drawDataLabels.apply(t11), e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((e12, i12) => {
              var _a2;
              let s12 = n10[2] / 2, o12 = e12.options, r12 = h4((o12 == null ? void 0 : o12.distance) || 0, s12);
              0 === i12 && d10[t12.half].push(t12), !h5((_a2 = o12 == null ? void 0 : o12.style) == null ? void 0 : _a2.width) && e12.getBBox().width > a10 && (e12.css({ width: Math.round(0.7 * a10) + "px" }), e12.shortened = true), e12.dataLabelPosition = this.getDataLabelPosition(t12, r12), m2 = Math.max(m2, r12);
            });
          }), d10.forEach((e12, a11) => {
            let d11 = e12.length, u3 = [], x2, y2, b2 = 0, v2;
            d11 && (t11.sortByAngle(e12, a11 - 0.5), m2 > 0 && (x2 = Math.max(0, l10 - h10 - m2), y2 = Math.min(l10 + h10 + m2, i11.plotHeight), e12.forEach((t12) => {
              (t12.dataLabels || []).forEach((e13) => {
                var _a2;
                let s12 = e13.dataLabelPosition;
                s12 && s12.distance > 0 && (s12.top = Math.max(0, l10 - h10 - s12.distance), s12.bottom = Math.min(l10 + h10 + s12.distance, i11.plotHeight), b2 = e13.getBBox().height || 21, e13.lineHeight = i11.renderer.fontMetrics(e13.text || e13).h + 2 * e13.padding, t12.distributeBox = { target: (((_a2 = e13.dataLabelPosition) == null ? void 0 : _a2.natural.y) || 0) - s12.top + e13.lineHeight / 2, size: b2, rank: t12.y }, u3.push(t12.distributeBox));
              });
            }), h0(u3, v2 = y2 + b2 - x2, v2 / 5)), e12.forEach((i12) => {
              (i12.dataLabels || []).forEach((l11) => {
                let d12 = l11.options || {}, m3 = i12.distributeBox, x3 = l11.dataLabelPosition, y3 = (x3 == null ? void 0 : x3.natural.y) || 0, b3 = d12.connectorPadding || 0, v3 = l11.lineHeight || 21, k2 = (v3 - l11.getBBox().height) / 2, M2 = 0, w2 = y3, S2 = "inherit";
                if (x3) {
                  if (u3 && h5(m3) && x3.distance > 0 && (void 0 === m3.pos ? S2 = "hidden" : (f2 = m3.size, w2 = p10.radialDistributionY(i12, l11))), d12.justify) M2 = p10.justify(i12, l11, h10, n10);
                  else switch (d12.alignTo) {
                    case "connectors":
                      M2 = p10.alignToConnectors(e12, a11, s11, r11);
                      break;
                    case "plotEdges":
                      M2 = p10.alignToPlotEdges(l11, a11, s11, r11);
                      break;
                    default:
                      M2 = p10.radialDistributionX(t11, i12, w2 - k2, y3, l11);
                  }
                  if (x3.attribs = { visibility: S2, align: x3.alignment }, x3.posAttribs = { x: M2 + (d12.x || 0) + ({ left: b3, right: -b3 }[x3.alignment] || 0), y: w2 + (d12.y || 0) - v3 / 2 }, x3.computed.x = M2, x3.computed.y = w2 - k2, h6(d12.crop, true)) {
                    let t12;
                    M2 - (g2 = l11.getBBox().width) < b3 && 1 === a11 ? (t12 = Math.round(g2 - M2 + b3), c10[3] = Math.max(t12, c10[3])) : M2 + g2 > s11 - b3 && 0 === a11 && (t12 = Math.round(M2 + g2 - s11 + b3), c10[1] = Math.max(t12, c10[1])), w2 - f2 / 2 < 0 ? c10[0] = Math.max(Math.round(-w2 + f2 / 2), c10[0]) : w2 + f2 / 2 > o11 && (c10[2] = Math.max(Math.round(w2 + f2 / 2 - o11), c10[2])), x3.sideOverflow = t12;
                  }
                }
              });
            }));
          }), (0 === h2(c10) || this.verifyDataLabelOverflow(c10)) && (this.placeDataLabels(), this.points.forEach((e12) => {
            (e12.dataLabels || []).forEach((s12) => {
              var _a2;
              let { connectorColor: o12, connectorWidth: r12 = 1 } = s12.options || {}, a11 = s12.dataLabelPosition;
              if (r12) {
                let n11;
                u2 = s12.connector, a11 && a11.distance > 0 ? (n11 = !u2, u2 || (s12.connector = u2 = i11.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e12.colorIndex + (e12.className ? " " + e12.className : "")).add(t11.dataLabelsGroup)), i11.styledMode || u2.attr({ "stroke-width": r12, stroke: o12 || e12.color || "#666666" }), u2[n11 ? "attr" : "animate"]({ d: e12.getConnectorPath(s12) }), u2.attr({ visibility: (_a2 = a11.attribs) == null ? void 0 : _a2.visibility })) : u2 && (s12.connector = u2.destroy());
              }
            });
          })));
        }
        function o10() {
          this.points.forEach((t11) => {
            (t11.dataLabels || []).forEach((t12) => {
              var _a;
              let e11 = t12.dataLabelPosition;
              e11 ? (e11.sideOverflow && (t12.css({ width: Math.max(t12.getBBox().width - e11.sideOverflow, 0) + "px", textOverflow: (((_a = t12.options) == null ? void 0 : _a.style) || {}).textOverflow || "ellipsis" }), t12.shortened = true), t12.attr(e11.attribs), t12[t12.moved ? "animate" : "attr"](e11.posAttribs), t12.moved = true) : t12 && t12.attr({ y: -9999 });
            }), delete t11.distributeBox;
          }, this);
        }
        function r10(t11) {
          let e11 = this.center, i11 = this.options, s11 = i11.center, o11 = i11.minSize || 80, r11 = o11, a10 = null !== i11.size;
          return !a10 && (null !== s11[0] ? r11 = Math.max(e11[2] - Math.max(t11[1], t11[3]), o11) : (r11 = Math.max(e11[2] - t11[1] - t11[3], o11), e11[0] += (t11[3] - t11[1]) / 2), null !== s11[1] ? r11 = h3(r11, o11, e11[2] - Math.max(t11[0], t11[2])) : (r11 = h3(r11, o11, e11[2] - t11[0] - t11[2]), e11[1] += (t11[0] - t11[2]) / 2), r11 < e11[2] ? (e11[2] = r11, e11[3] = Math.min(i11.thickness ? Math.max(0, r11 - 2 * i11.thickness) : Math.max(0, h4(i11.innerSize || 0, r11)), r11), this.translate(e11), this.drawDataLabels && this.drawDataLabels()) : a10 = true), a10;
        }
        t10.compose = function(t11) {
          if (hg.compose(h1), h9(hJ, "PieDataLabel")) {
            let a10 = t11.prototype;
            a10.dataLabelPositioners = e10, a10.alignDataLabel = hQ, a10.drawDataLabels = s10, a10.getDataLabelPosition = i10, a10.placeDataLabels = o10, a10.verifyDataLabelOverflow = r10;
          }
        };
      }(v || (v = {}));
      let h8 = v;
      !function(t10) {
        t10.getCenterOfPoints = function(t11) {
          let e10 = t11.reduce((t12, e11) => (t12.x += e11.x, t12.y += e11.y, t12), { x: 0, y: 0 });
          return { x: e10.x / t11.length, y: e10.y / t11.length };
        }, t10.getDistanceBetweenPoints = function(t11, e10) {
          return Math.sqrt(Math.pow(e10.x - t11.x, 2) + Math.pow(e10.y - t11.y, 2));
        }, t10.getAngleBetweenPoints = function(t11, e10) {
          return Math.atan2(e10.x - t11.x, e10.y - t11.y);
        }, t10.pointInPolygon = function({ x: t11, y: e10 }, i10) {
          let s10 = i10.length, o10, r10, a10 = false;
          for (o10 = 0, r10 = s10 - 1; o10 < s10; r10 = o10++) {
            let [s11, n10] = i10[o10], [h10, l10] = i10[r10];
            n10 > e10 != l10 > e10 && t11 < (h10 - s11) * (e10 - n10) / (l10 - n10) + s11 && (a10 = !a10);
          }
          return a10;
        };
      }(k || (k = {}));
      let { pointInPolygon: h7 } = k, { addEvent: lt, fireEvent: le, objectEach: li, pick: ls } = ti;
      function lo(t10) {
        let e10 = t10.length, i10 = (t11, e11) => !(e11.x >= t11.x + t11.width || e11.x + e11.width <= t11.x || e11.y >= t11.y + t11.height || e11.y + e11.height <= t11.y), s10 = (t11, e11) => {
          for (let i11 of t11) if (h7({ x: i11[0], y: i11[1] }, e11)) return true;
          return false;
        }, o10, r10, a10, n10, h10, l10 = false;
        for (let i11 = 0; i11 < e10; i11++) (o10 = t10[i11]) && (o10.oldOpacity = o10.opacity, o10.newOpacity = 1, o10.absoluteBox = function(t11) {
          var _a, _b;
          if (t11 && (!t11.alignAttr || t11.placed)) {
            let e11 = t11.box ? 0 : t11.padding || 0, i12 = t11.alignAttr || { x: t11.attr("x"), y: t11.attr("y") }, s11 = t11.getBBox();
            return t11.width = s11.width, t11.height = s11.height, { x: i12.x + (((_a = t11.parentGroup) == null ? void 0 : _a.translateX) || 0) + e11, y: i12.y + (((_b = t11.parentGroup) == null ? void 0 : _b.translateY) || 0) + e11, width: (t11.width || 0) - 2 * e11, height: (t11.height || 0) - 2 * e11, polygon: s11 == null ? void 0 : s11.polygon };
          }
        }(o10));
        t10.sort((t11, e11) => (e11.labelrank || 0) - (t11.labelrank || 0));
        for (let o11 = 0; o11 < e10; ++o11) {
          n10 = (r10 = t10[o11]) && r10.absoluteBox;
          let l11 = n10 == null ? void 0 : n10.polygon;
          for (let d10 = o11 + 1; d10 < e10; ++d10) {
            h10 = (a10 = t10[d10]) && a10.absoluteBox;
            let e11 = false;
            if (n10 && h10 && r10 !== a10 && 0 !== r10.newOpacity && 0 !== a10.newOpacity && "hidden" !== r10.visibility && "hidden" !== a10.visibility) {
              let t11 = h10.polygon;
              if (l11 && t11 && l11 !== t11 ? s10(l11, t11) && (e11 = true) : i10(n10, h10) && (e11 = true), e11) {
                let t12 = r10.labelrank < a10.labelrank ? r10 : a10, e12 = t12.text;
                t12.newOpacity = 0, (e12 == null ? void 0 : e12.element.querySelector("textPath")) && e12.hide();
              }
            }
          }
        }
        for (let e11 of t10) lr(e11, this) && (l10 = true);
        l10 && le(this, "afterHideAllOverlappingLabels");
      }
      function lr(t10, e10) {
        let i10, s10, o10 = false;
        return t10 && (s10 = t10.newOpacity, t10.oldOpacity !== s10 && (t10.hasClass("highcharts-data-label") ? (t10[s10 ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), i10 = function() {
          e10.styledMode || t10.css({ pointerEvents: s10 ? "auto" : "none" });
        }, o10 = true, t10[t10.isOld ? "animate" : "attr"]({ opacity: s10 }, void 0, i10), le(e10, "afterHideOverlappingLabel")) : t10.attr({ opacity: s10 })), t10.isOld = true), o10;
      }
      function la() {
        var _a;
        let t10 = this, e10 = [];
        for (let i10 of t10.labelCollectors || []) e10 = e10.concat(i10());
        for (let i10 of t10.yAxis || []) i10.stacking && i10.options.stackLabels && !i10.options.stackLabels.allowOverlap && li(i10.stacking.stacks, (t11) => {
          li(t11, (t12) => {
            t12.label && e10.push(t12.label);
          });
        });
        for (let i10 of t10.series || []) if (i10.visible && ((_a = i10.hasDataLabels) == null ? void 0 : _a.call(i10))) {
          let s10 = (i11) => {
            for (let s11 of i11) s11.visible && (s11.dataLabels || []).forEach((i12) => {
              var _a2;
              let o10 = i12.options || {};
              i12.labelrank = ls(o10.labelrank, s11.labelrank, (_a2 = s11.shapeArgs) == null ? void 0 : _a2.height), o10.allowOverlap ?? Number(o10.distance) > 0 ? (i12.oldOpacity = i12.opacity, i12.newOpacity = 1, lr(i12, t10)) : e10.push(i12);
            });
          };
          s10(i10.nodes || []), s10(i10.points);
        }
        this.hideOverlappingLabels(e10);
      }
      let ln = { compose: function(t10) {
        let e10 = t10.prototype;
        e10.hideOverlappingLabels || (e10.hideOverlappingLabels = lo, lt(t10, "render", la));
      } }, { defaultOptions: lh } = tT, { noop: ll } = L, { addEvent: ld, extend: lc, isObject: lp, merge: lu, relativeLength: lg } = ti, lf = { radius: 0, scope: "stack", where: void 0 }, lm = ll, lx = ll;
      function ly(t10, e10, i10, s10, o10 = {}) {
        let r10 = lm(t10, e10, i10, s10, o10), { innerR: a10 = 0, r: n10 = i10, start: h10 = 0, end: l10 = 0 } = o10;
        if (o10.open || !o10.borderRadius) return r10;
        let d10 = l10 - h10, c10 = Math.sin(d10 / 2), p10 = Math.max(Math.min(lg(o10.borderRadius || 0, n10 - a10), (n10 - a10) / 2, n10 * c10 / (1 + c10)), 0), u2 = Math.min(p10, d10 / Math.PI * 2 * a10), g2 = r10.length - 1;
        for (; g2--; ) !function(t11, e11, i11) {
          let s11, o11, r11;
          let a11 = t11[e11], n11 = t11[e11 + 1];
          if ("Z" === n11[0] && (n11 = t11[0]), ("M" === a11[0] || "L" === a11[0]) && "A" === n11[0] ? (s11 = a11, o11 = n11, r11 = true) : "A" === a11[0] && ("M" === n11[0] || "L" === n11[0]) && (s11 = n11, o11 = a11), s11 && o11 && o11.params) {
            let a12 = o11[1], n12 = o11[5], h11 = o11.params, { start: l11, end: d11, cx: c11, cy: p11 } = h11, u3 = n12 ? a12 - i11 : a12 + i11, g3 = u3 ? Math.asin(i11 / u3) : 0, f2 = n12 ? g3 : -g3, m2 = Math.cos(g3) * u3;
            r11 ? (h11.start = l11 + f2, s11[1] = c11 + m2 * Math.cos(l11), s11[2] = p11 + m2 * Math.sin(l11), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c11 + a12 * Math.cos(h11.start), p11 + a12 * Math.sin(h11.start)])) : (h11.end = d11 - f2, o11[6] = c11 + a12 * Math.cos(h11.end), o11[7] = p11 + a12 * Math.sin(h11.end), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c11 + m2 * Math.cos(d11), p11 + m2 * Math.sin(d11)])), o11[4] = Math.abs(h11.end - h11.start) < Math.PI ? 0 : 1;
          }
        }(r10, g2, g2 > 1 ? u2 : p10);
        return r10;
      }
      function lb() {
        var _a, _b;
        if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
          let { options: t10, yAxis: e10 } = this, i10 = "percent" === t10.stacking, s10 = (_b = (_a = lh.plotOptions) == null ? void 0 : _a[this.type]) == null ? void 0 : _b.borderRadius, o10 = lv(t10.borderRadius, lp(s10) ? s10 : {}), r10 = e10.options.reversed;
          for (let s11 of this.points) {
            let { shapeArgs: a10 } = s11;
            if ("roundedRect" === s11.shapeType && a10) {
              let { width: n10 = 0, height: h10 = 0, y: l10 = 0 } = a10, d10 = l10, c10 = h10;
              if ("stack" === o10.scope && s11.stackTotal) {
                let o11 = e10.translate(i10 ? 100 : s11.stackTotal, false, true, false, true), r11 = e10.translate(t10.threshold || 0, false, true, false, true), a11 = this.crispCol(0, Math.min(o11, r11), 0, Math.abs(o11 - r11));
                d10 = a11.y, c10 = a11.height;
              }
              let p10 = (s11.negative ? -1 : 1) * (r10 ? -1 : 1) == -1, u2 = o10.where;
              !u2 && this.is("waterfall") && Math.abs((s11.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (u2 = "all"), u2 || (u2 = "end");
              let g2 = Math.min(lg(o10.radius, n10), n10 / 2, "all" === u2 ? h10 / 2 : 1 / 0) || 0;
              "end" === u2 && (p10 && (d10 -= g2), c10 += g2), lc(a10, { brBoxHeight: c10, brBoxY: d10, r: g2 });
            }
          }
        }
      }
      function lv(t10, e10) {
        return lp(t10) || (t10 = { radius: t10 || 0 }), lu(lf, e10, t10);
      }
      function lk() {
        let t10 = lv(this.options.borderRadius);
        for (let e10 of this.points) {
          let i10 = e10.shapeArgs;
          i10 && (i10.borderRadius = lg(t10.radius, (i10.r || 0) - (i10.innerR || 0)));
        }
      }
      function lM(t10, e10, i10, s10, o10 = {}) {
        let r10 = lx(t10, e10, i10, s10, o10), { r: a10 = 0, brBoxHeight: n10 = s10, brBoxY: h10 = e10 } = o10, l10 = e10 - h10, d10 = h10 + n10 - (e10 + s10), c10 = l10 - a10 > -0.1 ? 0 : a10, p10 = d10 - a10 > -0.1 ? 0 : a10, u2 = Math.max(c10 && l10, 0), g2 = Math.max(p10 && d10, 0), f2 = [t10 + c10, e10], m2 = [t10 + i10 - c10, e10], x2 = [t10 + i10, e10 + c10], y2 = [t10 + i10, e10 + s10 - p10], b2 = [t10 + i10 - p10, e10 + s10], v2 = [t10 + p10, e10 + s10], k2 = [t10, e10 + s10 - p10], M2 = [t10, e10 + c10], w2 = (t11, e11) => Math.sqrt(Math.pow(t11, 2) - Math.pow(e11, 2));
        if (u2) {
          let t11 = w2(c10, c10 - u2);
          f2[0] -= t11, m2[0] += t11, x2[1] = M2[1] = e10 + c10 - u2;
        }
        if (s10 < c10 - u2) {
          let o11 = w2(c10, c10 - u2 - s10);
          x2[0] = y2[0] = t10 + i10 - c10 + o11, b2[0] = Math.min(x2[0], b2[0]), v2[0] = Math.max(y2[0], v2[0]), k2[0] = M2[0] = t10 + c10 - o11, x2[1] = M2[1] = e10 + s10;
        }
        if (g2) {
          let t11 = w2(p10, p10 - g2);
          b2[0] += t11, v2[0] -= t11, y2[1] = k2[1] = e10 + s10 - p10 + g2;
        }
        if (s10 < p10 - g2) {
          let o11 = w2(p10, p10 - g2 - s10);
          x2[0] = y2[0] = t10 + i10 - p10 + o11, m2[0] = Math.min(x2[0], m2[0]), f2[0] = Math.max(y2[0], f2[0]), k2[0] = M2[0] = t10 + p10 - o11, y2[1] = k2[1] = e10;
        }
        return r10.length = 0, r10.push(["M", ...f2], ["L", ...m2], ["A", c10, c10, 0, 0, 1, ...x2], ["L", ...y2], ["A", p10, p10, 0, 0, 1, ...b2], ["L", ...v2], ["A", p10, p10, 0, 0, 1, ...k2], ["L", ...M2], ["A", c10, c10, 0, 0, 1, ...f2], ["Z"]), r10;
      }
      let { diffObjects: lw, extend: lS, find: lA, merge: lT, pick: lC, uniqueKey: lP } = ti;
      !function(t10) {
        function e10(t11, e11) {
          let i11 = t11.condition;
          (i11.callback || function() {
            return this.chartWidth <= lC(i11.maxWidth, Number.MAX_VALUE) && this.chartHeight <= lC(i11.maxHeight, Number.MAX_VALUE) && this.chartWidth >= lC(i11.minWidth, 0) && this.chartHeight >= lC(i11.minHeight, 0);
          }).call(this) && e11.push(t11._id);
        }
        function i10(t11, e11) {
          let i11 = this.options.responsive, s10 = this.currentResponsive, o10 = [], r10;
          !e11 && i11 && i11.rules && i11.rules.forEach((t12) => {
            void 0 === t12._id && (t12._id = lP()), this.matchResponsiveRule(t12, o10);
          }, this);
          let a10 = lT(...o10.map((t12) => lA((i11 || {}).rules || [], (e12) => e12._id === t12)).map((t12) => t12 && t12.chartOptions));
          a10.isResponsiveOptions = true, o10 = o10.toString() || void 0;
          let n10 = s10 && s10.ruleIds;
          o10 === n10 || (s10 && (this.currentResponsive = void 0, this.updatingResponsive = true, this.update(s10.undoOptions, t11, true), this.updatingResponsive = false), o10 ? ((r10 = lw(a10, this.options, true, this.collectionsWithUpdate)).isResponsiveOptions = true, this.currentResponsive = { ruleIds: o10, mergedOptions: a10, undoOptions: r10 }, this.updatingResponsive || this.update(a10, t11, true)) : this.currentResponsive = void 0);
        }
        t10.compose = function(t11) {
          let s10 = t11.prototype;
          return s10.matchResponsiveRule || lS(s10, { matchResponsiveRule: e10, setResponsive: i10 }), t11;
        };
      }(M || (M = {}));
      let lO = M;
      L.AST = t4, L.Axis = s_, L.Chart = aQ, L.Color = tL, L.DataLabel = hg, L.DataTableCore = rc, L.Fx = tR, L.HTMLElement = i9, L.Legend = ap, L.LegendSymbol = rf, L.OverlappingDataLabels = L.OverlappingDataLabels || ln, L.PlotLineOrBand = on, L.Point = oK, L.Pointer = ra, L.RendererRegistry = ef, L.Series = rQ, L.SeriesRegistry = rv, L.StackItem = nl, L.SVGElement = e0, L.SVGRenderer = i_, L.Templating = eg, L.Tick = sm, L.Time = tv, L.Tooltip = oL, L.animate = t_.animate, L.animObject = t_.animObject, L.chart = aQ.chart, L.color = tL.parse, L.dateFormat = eg.dateFormat, L.defaultOptions = tT.defaultOptions, L.distribute = ev.distribute, L.format = eg.format, L.getDeferredAnimation = t_.getDeferredAnimation, L.getOptions = tT.getOptions, L.numberFormat = eg.numberFormat, L.seriesType = rv.seriesType, L.setAnimation = t_.setAnimation, L.setOptions = tT.setOptions, L.stop = t_.stop, L.time = tT.defaultTime, L.timers = tR.timers, { compose: function(t10, e10, i10) {
        let s10 = t10.types.pie;
        if (!e10.symbolCustomAttribs.includes("borderRadius")) {
          let o10 = i10.prototype.symbols;
          ld(t10, "afterColumnTranslate", lb, { order: 9 }), ld(s10, "afterTranslate", lk), e10.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), lm = o10.arc, lx = o10.roundedRect, o10.arc = ly, o10.roundedRect = lM;
        }
      }, optionsToObject: lv }.compose(L.Series, L.SVGElement, L.SVGRenderer), hv.compose(L.Series.types.column), hg.compose(L.Series), sJ.compose(L.Axis), i9.compose(L.SVGRenderer), ap.compose(L.Chart), s2.compose(L.Axis), ln.compose(L.Chart), h8.compose(L.Series.types.pie), on.compose(L.Chart, L.Axis), ra.compose(L.Chart), lO.compose(L.Chart), ne.compose(L.Axis, L.Chart, L.Series), nO.compose(L.Axis, L.Chart, L.Series), oL.compose(L.Pointer), ti.extend(L, ti);
      let { tooltipFormatter: lE } = oK.prototype, { addEvent: lL, arrayMax: lD, arrayMin: lB, correctFloat: lI, defined: lz, isArray: lR, isNumber: lN, isString: lW, pick: lG } = ti;
      !function(t10) {
        function e10(t11, e11, i11) {
          !this.isXAxis && (this.series.forEach(function(i12) {
            "compare" === t11 && "boolean" != typeof e11 ? i12.setCompare(e11, false) : "cumulative" !== t11 || lW(e11) || i12.setCumulative(e11, false);
          }), lG(i11, true) && this.chart.redraw());
        }
        function i10(t11) {
          let e11 = this, { numberFormatter: i11 } = e11.series.chart, s11 = function(s12) {
            t11 = t11.replace("{point." + s12 + "}", (e11[s12] > 0 && "change" === s12 ? "+" : "") + i11(e11[s12], lG(e11.series.tooltipOptions.changeDecimals, 2)));
          };
          return lz(e11.change) && s11("change"), lz(e11.cumulativeSum) && s11("cumulativeSum"), lE.apply(this, [t11]);
        }
        function s10() {
          let t11;
          let e11 = this.options.compare;
          ("percent" === e11 || "value" === e11 || this.options.cumulative) && (t11 = new d10(this), "percent" === e11 || "value" === e11 ? t11.initCompare(e11) : t11.initCumulative()), this.dataModify = t11;
        }
        function o10(t11) {
          let e11 = t11.dataExtremes, i11 = e11.activeYData;
          if (this.dataModify && e11) {
            let t12;
            this.options.compare ? t12 = [this.dataModify.modifyValue(e11.dataMin), this.dataModify.modifyValue(e11.dataMax)] : this.options.cumulative && lR(i11) && i11.length >= 2 && (t12 = d10.getCumulativeExtremes(i11)), t12 && (e11.dataMin = lB(t12), e11.dataMax = lD(t12));
          }
        }
        function r10(t11, e11) {
          this.options.compare = this.userOptions.compare = t11, this.update({}, lG(e11, true)), this.dataModify && ("value" === t11 || "percent" === t11) ? this.dataModify.initCompare(t11) : this.points.forEach((t12) => {
            delete t12.change;
          });
        }
        function a10() {
          let t11 = this.getColumn(this.pointArrayMap && (this.options.pointValKey || this.pointValKey) || "y", true);
          if (this.xAxis && t11.length && this.dataModify) {
            let e11 = this.getColumn("x", true), i11 = this.dataTable.rowCount, s11 = true === this.options.compareStart ? 0 : 1;
            for (let o11 = 0; o11 < i11 - s11; o11++) {
              let i12 = t11[o11];
              if (lN(i12) && 0 !== i12 && e11[o11 + s11] >= (this.xAxis.min || 0)) {
                this.dataModify.compareValue = i12;
                break;
              }
            }
          }
        }
        function n10(t11, e11) {
          this.setModifier("compare", t11, e11);
        }
        function h10(t11, e11) {
          t11 = lG(t11, false), this.options.cumulative = this.userOptions.cumulative = t11, this.update({}, lG(e11, true)), this.dataModify ? this.dataModify.initCumulative() : this.points.forEach((t12) => {
            delete t12.cumulativeSum;
          });
        }
        function l10(t11, e11) {
          this.setModifier("cumulative", t11, e11);
        }
        t10.compose = function(t11, d11, c10) {
          let p10 = d11.prototype, u2 = c10.prototype, g2 = t11.prototype;
          return g2.setCompare || (g2.setCompare = r10, g2.setCumulative = h10, lL(t11, "afterInit", s10), lL(t11, "afterGetExtremes", o10), lL(t11, "afterProcessData", a10)), p10.setCompare || (p10.setCompare = n10, p10.setModifier = e10, p10.setCumulative = l10, u2.tooltipFormatter = i10), t11;
        };
        class d10 {
          constructor(t11) {
            this.series = t11;
          }
          modifyValue() {
            return 0;
          }
          static getCumulativeExtremes(t11) {
            let e11 = 1 / 0, i11 = -1 / 0;
            return t11.reduce((t12, s11) => {
              let o11 = t12 + s11;
              return e11 = Math.min(e11, o11, t12), i11 = Math.max(i11, o11, t12), o11;
            }), [e11, i11];
          }
          initCompare(t11) {
            this.modifyValue = function(e11, i11) {
              null === e11 && (e11 = 0);
              let s11 = this.compareValue;
              if (void 0 !== e11 && void 0 !== s11) {
                if ("value" === t11 ? e11 -= s11 : e11 = e11 / s11 * 100 - (100 === this.series.options.compareBase ? 0 : 100), void 0 !== i11) {
                  let t12 = this.series.points[i11];
                  t12 && (t12.change = e11);
                }
                return e11;
              }
              return 0;
            };
          }
          initCumulative() {
            this.modifyValue = function(t11, e11) {
              if (null === t11 && (t11 = 0), void 0 !== t11 && void 0 !== e11) {
                let i11 = e11 > 0 ? this.series.points[e11 - 1] : null;
                i11 && i11.cumulativeSum && (t11 = lI(i11.cumulativeSum + t11));
                let s11 = this.series.points[e11], o11 = s11.series.options.cumulativeStart, r11 = s11.x <= this.series.xAxis.max && s11.x >= this.series.xAxis.min;
                return s11 && (!o11 || r11 ? s11.cumulativeSum = t11 : s11.cumulativeSum = void 0), t11;
              }
              return 0;
            };
          }
        }
        t10.Additions = d10;
      }(w || (w = {}));
      let lX = w, { isTouchDevice: lH } = L, { addEvent: lF, merge: lY, pick: lj } = ti, lU = [];
      function lV() {
        this.navigator && this.navigator.setBaseSeries(null, false);
      }
      function l_() {
        var _a;
        let t10, e10, i10;
        let s10 = this.legend, o10 = this.navigator;
        if (o10) {
          t10 = s10 && s10.options, e10 = o10.xAxis, i10 = o10.yAxis;
          let { scrollbarHeight: r10, scrollButtonSize: a10 } = o10;
          this.inverted ? (o10.left = o10.opposite ? this.chartWidth - r10 - o10.height : this.spacing[3] + r10, o10.top = this.plotTop + a10) : (o10.left = lj(e10.left, this.plotLeft + a10), o10.top = o10.navigatorOptions.top || this.chartHeight - o10.height - r10 - (((_a = this.scrollbar) == null ? void 0 : _a.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t10 && "bottom" === t10.verticalAlign && "proximate" !== t10.layout && t10.enabled && !t10.floating ? s10.legendHeight + lj(t10.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e10 && i10 && (this.inverted ? e10.options.left = i10.options.left = o10.left : e10.options.top = i10.options.top = o10.top, e10.setAxisSize(), i10.setAxisSize());
        }
      }
      function l$(t10) {
        !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new i(this), lj(t10.redraw, true) && this.redraw(t10.animation));
      }
      function lZ() {
        let t10 = this.options;
        (t10.navigator.enabled || t10.scrollbar.enabled) && (this.scroller = this.navigator = new i(this));
      }
      function lq() {
        let t10 = this.options, e10 = t10.navigator, i10 = t10.rangeSelector;
        if ((e10 && e10.enabled || i10 && i10.enabled) && (!lH && "x" === this.zooming.type || lH && "x" === this.zooming.pinchType)) return false;
      }
      function lK(t10) {
        let e10 = t10.navigator;
        if (e10 && t10.xAxis[0]) {
          let i10 = t10.xAxis[0].getExtremes();
          e10.render(i10.min, i10.max);
        }
      }
      function lJ(t10) {
        let e10 = t10.options.navigator || {}, i10 = t10.options.scrollbar || {};
        !this.navigator && !this.scroller && (e10.enabled || i10.enabled) && (lY(true, this.options.navigator, e10), lY(true, this.options.scrollbar, i10), delete t10.options.navigator, delete t10.options.scrollbar);
      }
      let lQ = { compose: function(t10, e10) {
        if (ti.pushUnique(lU, t10)) {
          let s10 = t10.prototype;
          i = e10, s10.callbacks.push(lK), lF(t10, "afterAddSeries", lV), lF(t10, "afterSetChartSize", l_), lF(t10, "afterUpdate", l$), lF(t10, "beforeRender", lZ), lF(t10, "beforeShowResetZoom", lq), lF(t10, "update", lJ);
        }
      } }, { isTouchDevice: l0 } = L, { addEvent: l1, correctFloat: l2, defined: l3, isNumber: l5, pick: l6 } = ti;
      function l9() {
        this.navigatorAxis || (this.navigatorAxis = new l8(this));
      }
      function l4(t10) {
        let e10;
        let i10 = this.chart, s10 = i10.options, o10 = s10.navigator, r10 = this.navigatorAxis, a10 = i10.zooming.pinchType, n10 = s10.rangeSelector, h10 = i10.zooming.type;
        if (this.isXAxis && ((o10 == null ? void 0 : o10.enabled) || (n10 == null ? void 0 : n10.enabled))) {
          if ("y" === h10 && "zoom" === t10.trigger) e10 = false;
          else if (("zoom" === t10.trigger && "xy" === h10 || l0 && "xy" === a10) && this.options.range) {
            let e11 = r10.previousZoom;
            l3(t10.min) ? r10.previousZoom = [this.min, this.max] : e11 && (t10.min = e11[0], t10.max = e11[1], r10.previousZoom = void 0);
          }
        }
        void 0 !== e10 && t10.preventDefault();
      }
      class l8 {
        static compose(t10) {
          t10.keepProps.includes("navigatorAxis") || (t10.keepProps.push("navigatorAxis"), l1(t10, "init", l9), l1(t10, "setExtremes", l4));
        }
        constructor(t10) {
          this.axis = t10;
        }
        destroy() {
          this.axis = void 0;
        }
        toFixedRange(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = (o10.pointRange || 0) / 2, a10 = l6(i10, o10.translate(t10, true, !o10.horiz)), n10 = l6(s10, o10.translate(e10, true, !o10.horiz));
          return l3(i10) || (a10 = l2(a10 + r10)), l3(s10) || (n10 = l2(n10 - r10)), l5(a10) && l5(n10) || (a10 = n10 = void 0), { min: a10, max: n10 };
        }
      }
      let { parse: l7 } = tL, { seriesTypes: dt } = rv, de = { height: 40, margin: 25, maskInside: true, handles: { width: 7, borderRadius: 0, height: 15, symbols: ["navigator-handle", "navigator-handle"], enabled: true, lineWidth: 1, backgroundColor: "#f2f2f2", borderColor: "#999999" }, maskFill: l7("#667aff").setOpacity(0.3).get(), outlineColor: "#999999", outlineWidth: 1, series: { type: void 0 === dt.areaspline ? "line" : "areaspline", fillOpacity: 0.05, lineWidth: 1, compare: null, sonification: { enabled: false }, dataGrouping: { approximation: "average", enabled: true, groupPixelWidth: 2, firstAnchor: "firstPoint", anchor: "middle", lastAnchor: "lastPoint", units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]] }, dataLabels: { enabled: false, zIndex: 2 }, id: "highcharts-navigator-series", className: "highcharts-navigator-series", lineColor: null, marker: { enabled: false }, threshold: null }, xAxis: { className: "highcharts-navigator-xaxis", tickLength: 0, lineWidth: 0, gridLineColor: "#e6e6e6", id: "navigator-x-axis", gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", style: { color: "#000000", fontSize: "0.7em", opacity: 0.6, textOutline: "2px contrast" }, x: 3, y: -4 }, crosshair: false }, yAxis: { className: "highcharts-navigator-yaxis", gridLineWidth: 0, startOnTick: false, endOnTick: false, minPadding: 0.1, id: "navigator-y-axis", maxPadding: 0.1, labels: { enabled: false }, crosshair: false, title: { text: null }, tickLength: 0, tickWidth: 0 } }, { relativeLength: di } = ti, ds = { "navigator-handle": function(t10, e10, i10, s10, o10 = {}) {
        let r10 = o10.width ? o10.width / 2 : i10, a10 = di(o10.borderRadius || 0, Math.min(2 * r10, s10));
        return [["M", -1.5, (s10 = o10.height || s10) / 2 - 3.5], ["L", -1.5, s10 / 2 + 4.5], ["M", 0.5, s10 / 2 - 3.5], ["L", 0.5, s10 / 2 + 4.5], ...ir.rect(-r10 - 1, 0.5, 2 * r10 + 1, s10, { r: a10 })];
      } }, { defined: dr } = ti, da = { setFixedRange: function(t10) {
        let e10 = this.xAxis[0];
        dr(e10.dataMax) && dr(e10.dataMin) && t10 ? this.fixedRange = Math.min(t10, e10.dataMax - e10.dataMin) : this.fixedRange = t10;
      } }, { setOptions: dn } = tT, { composed: dh } = L, { getRendererType: dl } = ef, { setFixedRange: dd } = da, { addEvent: dc, extend: dp, pushUnique: du } = ti;
      function dg() {
        this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, false);
      }
      let df = { compose: function(t10, e10, i10) {
        l8.compose(e10), du(dh, "Navigator") && (t10.prototype.setFixedRange = dd, dp(dl().prototype.symbols, ds), dc(i10, "afterUpdate", dg), dn({ navigator: de }));
      } }, { composed: dm } = L, { addEvent: dx, defined: dy, pick: db, pushUnique: dv } = ti;
      !function(t10) {
        let e10;
        function i10(t11) {
          let e11 = db(t11.options && t11.options.min, t11.min), i11 = db(t11.options && t11.options.max, t11.max);
          return { axisMin: e11, axisMax: i11, scrollMin: dy(t11.dataMin) ? Math.min(e11, t11.min, t11.dataMin, db(t11.threshold, 1 / 0)) : e11, scrollMax: dy(t11.dataMax) ? Math.max(i11, t11.max, t11.dataMax, db(t11.threshold, -1 / 0)) : i11 };
        }
        function s10() {
          let t11 = this.scrollbar, e11 = t11 && !t11.options.opposite, i11 = this.horiz ? 2 : e11 ? 3 : 1;
          t11 && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i11] += t11.size + (t11.options.margin || 0));
        }
        function o10() {
          let t11 = this;
          t11.options && t11.options.scrollbar && t11.options.scrollbar.enabled && (t11.options.scrollbar.vertical = !t11.horiz, t11.options.startOnTick = t11.options.endOnTick = false, t11.scrollbar = new e10(t11.chart.renderer, t11.options.scrollbar, t11.chart), dx(t11.scrollbar, "changed", function(e11) {
            let s11, o11;
            let { axisMin: r11, axisMax: a10, scrollMin: n10, scrollMax: h10 } = i10(t11), l10 = h10 - n10;
            if (dy(r11) && dy(a10)) {
              if (t11.horiz && !t11.reversed || !t11.horiz && t11.reversed ? (s11 = n10 + l10 * this.to, o11 = n10 + l10 * this.from) : (s11 = n10 + l10 * (1 - this.from), o11 = n10 + l10 * (1 - this.to)), this.shouldUpdateExtremes(e11.DOMType)) {
                let i11 = "mousemove" !== e11.DOMType && "touchmove" !== e11.DOMType && void 0;
                t11.setExtremes(o11, s11, true, i11, e11);
              } else this.setRange(this.from, this.to);
            }
          }));
        }
        function r10() {
          let t11, e11, s11;
          let { scrollMin: o11, scrollMax: r11 } = i10(this), a10 = this.scrollbar, n10 = this.axisTitleMargin + (this.titleOffset || 0), h10 = this.chart.scrollbarsOffsets, l10 = this.options.margin || 0;
          if (a10 && h10) {
            if (this.horiz) this.opposite || (h10[1] += n10), a10.position(this.left, this.top + this.height + 2 + h10[1] - (this.opposite ? l10 : 0), this.width, this.height), this.opposite || (h10[1] += l10), t11 = 1;
            else {
              let e12;
              this.opposite && (h10[0] += n10), e12 = a10.options.opposite ? this.left + this.width + 2 + h10[0] - (this.opposite ? 0 : l10) : this.opposite ? 0 : l10, a10.position(e12, this.top, this.width, this.height), this.opposite && (h10[0] += l10), t11 = 0;
            }
            if (h10[t11] += a10.size + (a10.options.margin || 0), isNaN(o11) || isNaN(r11) || !dy(this.min) || !dy(this.max) || this.dataMin === this.dataMax) a10.setRange(0, 1);
            else if (this.min === this.max) {
              let t12 = this.pointRange / (this.dataMax + 1);
              e11 = t12 * this.min, s11 = t12 * (this.max + 1), a10.setRange(e11, s11);
            } else e11 = (this.min - o11) / (r11 - o11), s11 = (this.max - o11) / (r11 - o11), this.horiz && !this.reversed || !this.horiz && this.reversed ? a10.setRange(e11, s11) : a10.setRange(1 - s11, 1 - e11);
          }
        }
        t10.compose = function(t11, i11) {
          dv(dm, "Axis.Scrollbar") && (e10 = i11, dx(t11, "afterGetOffset", s10), dx(t11, "afterInit", o10), dx(t11, "afterRender", r10));
        };
      }(S || (S = {}));
      let dk = S, dM = { height: 10, barBorderRadius: 5, buttonBorderRadius: 0, buttonsEnabled: false, liveRedraw: void 0, margin: void 0, minWidth: 6, opposite: true, step: 0.2, zIndex: 3, barBackgroundColor: "#cccccc", barBorderWidth: 0, barBorderColor: "#cccccc", buttonArrowColor: "#333333", buttonBackgroundColor: "#e6e6e6", buttonBorderColor: "#cccccc", buttonBorderWidth: 1, rifleColor: "none", trackBackgroundColor: "rgba(255, 255, 255, 0.001)", trackBorderColor: "#cccccc", trackBorderRadius: 5, trackBorderWidth: 1 }, { defaultOptions: dw } = tT, { addEvent: dS, correctFloat: dA, crisp: dT, defined: dC, destroyObjectProperties: dP, fireEvent: dO, merge: dE, pick: dL, removeEvent: dD } = ti;
      class dB {
        static compose(t10) {
          dk.compose(t10, dB);
        }
        static swapXY(t10, e10) {
          return e10 && t10.forEach((t11) => {
            let e11;
            let i10 = t11.length;
            for (let s10 = 0; s10 < i10; s10 += 2) "number" == typeof (e11 = t11[s10 + 1]) && (t11[s10 + 1] = t11[s10 + 2], t11[s10 + 2] = e11);
          }), t10;
        }
        constructor(t10, e10, i10) {
          this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t10, e10, i10);
        }
        addEvents() {
          let t10 = this.options.inverted ? [1, 0] : [0, 1], e10 = this.scrollbarButtons, i10 = this.scrollbarGroup.element, s10 = this.track.element, o10 = this.mouseDownHandler.bind(this), r10 = this.mouseMoveHandler.bind(this), a10 = this.mouseUpHandler.bind(this), n10 = [[e10[t10[0]].element, "click", this.buttonToMinClick.bind(this)], [e10[t10[1]].element, "click", this.buttonToMaxClick.bind(this)], [s10, "click", this.trackClick.bind(this)], [i10, "mousedown", o10], [i10.ownerDocument, "mousemove", r10], [i10.ownerDocument, "mouseup", a10], [i10, "touchstart", o10], [i10.ownerDocument, "touchmove", r10], [i10.ownerDocument, "touchend", a10]];
          n10.forEach(function(t11) {
            dS.apply(null, t11);
          }), this._events = n10;
        }
        buttonToMaxClick(t10) {
          let e10 = (this.to - this.from) * dL(this.options.step, 0.2);
          this.updatePosition(this.from + e10, this.to + e10), dO(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t10 });
        }
        buttonToMinClick(t10) {
          let e10 = dA(this.to - this.from) * dL(this.options.step, 0.2);
          this.updatePosition(dA(this.from - e10), dA(this.to - e10)), dO(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t10 });
        }
        cursorToScrollbarPosition(t10) {
          let e10 = this.options, i10 = e10.minWidth > this.calculatedWidth ? e10.minWidth : 0;
          return { chartX: (t10.chartX - this.x - this.xOffset) / (this.barWidth - i10), chartY: (t10.chartY - this.y - this.yOffset) / (this.barWidth - i10) };
        }
        destroy() {
          let t10 = this, e10 = t10.chart.scroller;
          t10.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function(e11) {
            t10[e11] && t10[e11].destroy && (t10[e11] = t10[e11].destroy());
          }), e10 && t10 === e10.scrollbar && (e10.scrollbar = null, dP(e10.scrollbarButtons));
        }
        drawScrollbarButton(t10) {
          let e10 = this.renderer, i10 = this.scrollbarButtons, s10 = this.options, o10 = this.size, r10 = e10.g().add(this.group);
          if (i10.push(r10), s10.buttonsEnabled) {
            let a10 = e10.rect().addClass("highcharts-scrollbar-button").add(r10);
            this.chart.styledMode || a10.attr({ stroke: s10.buttonBorderColor, "stroke-width": s10.buttonBorderWidth, fill: s10.buttonBackgroundColor }), a10.attr(a10.crisp({ x: -0.5, y: -0.5, width: o10, height: o10, r: s10.buttonBorderRadius }, a10.strokeWidth()));
            let n10 = e10.path(dB.swapXY([["M", o10 / 2 + (t10 ? -1 : 1), o10 / 2 - 3], ["L", o10 / 2 + (t10 ? -1 : 1), o10 / 2 + 3], ["L", o10 / 2 + (t10 ? 2 : -2), o10 / 2]], s10.vertical)).addClass("highcharts-scrollbar-arrow").add(i10[t10]);
            this.chart.styledMode || n10.attr({ fill: s10.buttonArrowColor });
          }
        }
        init(t10, e10, i10) {
          this.scrollbarButtons = [], this.renderer = t10, this.userOptions = e10, this.options = dE(dM, dw.scrollbar, e10), this.options.margin = dL(this.options.margin, 10), this.chart = i10, this.size = dL(this.options.size, this.options.height), e10.enabled && (this.render(), this.addEvents());
        }
        mouseDownHandler(t10) {
          var _a;
          let e10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10, i10 = this.cursorToScrollbarPosition(e10);
          this.chartX = i10.chartX, this.chartY = i10.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = true;
        }
        mouseMoveHandler(t10) {
          var _a;
          let e10;
          let i10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10, s10 = this.options.vertical ? "chartY" : "chartX", o10 = this.initPositions || [];
          this.grabbedCenter && (!t10.touches || 0 !== t10.touches[0][s10]) && (e10 = this.cursorToScrollbarPosition(i10)[s10] - this[s10], this.hasDragged = true, this.updatePosition(o10[0] + e10, o10[1] + e10), this.hasDragged && dO(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t10.type, DOMEvent: t10 }));
        }
        mouseUpHandler(t10) {
          this.hasDragged && dO(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t10.type, DOMEvent: t10 }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
        }
        position(t10, e10, i10, s10) {
          let { buttonsEnabled: o10, margin: r10 = 0, vertical: a10 } = this.options, n10 = this.rendered ? "animate" : "attr", h10 = s10, l10 = 0;
          this.group.show(), this.x = t10, this.y = e10 + this.trackBorderWidth, this.width = i10, this.height = s10, this.xOffset = h10, this.yOffset = l10, a10 ? (this.width = this.yOffset = i10 = l10 = this.size, this.xOffset = h10 = 0, this.yOffset = l10 = o10 ? this.size : 0, this.barWidth = s10 - (o10 ? 2 * i10 : 0), this.x = t10 += r10) : (this.height = s10 = this.size, this.xOffset = h10 = o10 ? this.size : 0, this.barWidth = i10 - (o10 ? 2 * s10 : 0), this.y = this.y + r10), this.group[n10]({ translateX: t10, translateY: this.y }), this.track[n10]({ width: i10, height: s10 }), this.scrollbarButtons[1][n10]({ translateX: a10 ? 0 : i10 - h10, translateY: a10 ? s10 - l10 : 0 });
        }
        removeEvents() {
          this._events.forEach(function(t10) {
            dD.apply(null, t10);
          }), this._events.length = 0;
        }
        render() {
          let t10 = this.renderer, e10 = this.options, i10 = this.size, s10 = this.chart.styledMode, o10 = t10.g("scrollbar").attr({ zIndex: e10.zIndex }).hide().add();
          this.group = o10, this.track = t10.rect().addClass("highcharts-scrollbar-track").attr({ r: e10.trackBorderRadius || 0, height: i10, width: i10 }).add(o10), s10 || this.track.attr({ fill: e10.trackBackgroundColor, stroke: e10.trackBorderColor, "stroke-width": e10.trackBorderWidth });
          let r10 = this.trackBorderWidth = this.track.strokeWidth();
          this.track.attr({ x: -dT(0, r10), y: -dT(0, r10) }), this.scrollbarGroup = t10.g().add(o10), this.scrollbar = t10.rect().addClass("highcharts-scrollbar-thumb").attr({ height: i10 - r10, width: i10 - r10, r: e10.barBorderRadius || 0 }).add(this.scrollbarGroup), this.scrollbarRifles = t10.path(dB.swapXY([["M", -3, i10 / 4], ["L", -3, 2 * i10 / 3], ["M", 0, i10 / 4], ["L", 0, 2 * i10 / 3], ["M", 3, i10 / 4], ["L", 3, 2 * i10 / 3]], e10.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s10 || (this.scrollbar.attr({ fill: e10.barBackgroundColor, stroke: e10.barBorderColor, "stroke-width": e10.barBorderWidth }), this.scrollbarRifles.attr({ stroke: e10.rifleColor, "stroke-width": 1 })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-dT(0, this.scrollbarStrokeWidth), -dT(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);
        }
        setRange(t10, e10) {
          let i10, s10;
          let o10 = this.options, r10 = o10.vertical, a10 = o10.minWidth, n10 = this.barWidth, h10 = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
          if (!dC(n10)) return;
          let l10 = n10 * Math.min(e10, 1);
          i10 = Math.ceil(n10 * (t10 = Math.max(t10, 0))), this.calculatedWidth = s10 = dA(l10 - i10), s10 < a10 && (i10 = (n10 - a10 + s10) * t10, s10 = a10);
          let d10 = Math.floor(i10 + this.xOffset + this.yOffset), c10 = s10 / 2 - 0.5;
          this.from = t10, this.to = e10, r10 ? (this.scrollbarGroup[h10]({ translateY: d10 }), this.scrollbar[h10]({ height: s10 }), this.scrollbarRifles[h10]({ translateY: c10 }), this.scrollbarTop = d10, this.scrollbarLeft = 0) : (this.scrollbarGroup[h10]({ translateX: d10 }), this.scrollbar[h10]({ width: s10 }), this.scrollbarRifles[h10]({ translateX: c10 }), this.scrollbarLeft = d10, this.scrollbarTop = 0), s10 <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), false === o10.showFull && (t10 <= 0 && e10 >= 1 ? this.group.hide() : this.group.show()), this.rendered = true;
        }
        shouldUpdateExtremes(t10) {
          return dL(this.options.liveRedraw, L.svg && !L.isTouchDevice && !this.chart.boosted) || "mouseup" === t10 || "touchend" === t10 || !dC(t10);
        }
        trackClick(t10) {
          var _a;
          let e10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10, i10 = this.to - this.from, s10 = this.y + this.scrollbarTop, o10 = this.x + this.scrollbarLeft;
          this.options.vertical && e10.chartY > s10 || !this.options.vertical && e10.chartX > o10 ? this.updatePosition(this.from + i10, this.to + i10) : this.updatePosition(this.from - i10, this.to - i10), dO(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t10 });
        }
        update(t10) {
          this.destroy(), this.init(this.chart.renderer, dE(true, this.options, t10), this.chart);
        }
        updatePosition(t10, e10) {
          e10 > 1 && (t10 = dA(1 - dA(e10 - t10)), e10 = 1), t10 < 0 && (e10 = dA(e10 - t10), t10 = 0), this.from = t10, this.to = e10;
        }
      }
      dB.defaultOptions = dM, dw.scrollbar = dE(true, dB.defaultOptions, dw.scrollbar);
      let { defaultOptions: dI } = tT, { isTouchDevice: dz } = L, { prototype: { symbols: dR } } = i_, { addEvent: dN, clamp: dW, correctFloat: dG, defined: dX, destroyObjectProperties: dH, erase: dF, extend: dY, find: dj, fireEvent: dU, isArray: dV, isNumber: d_, merge: d$, pick: dZ, removeEvent: dq, splat: dK } = ti;
      function dJ(t10, ...e10) {
        let i10 = [].filter.call(e10, d_);
        if (i10.length) return Math[t10].apply(0, i10);
      }
      class dQ {
        static compose(t10, e10, i10) {
          lQ.compose(t10, dQ), df.compose(t10, e10, i10);
        }
        constructor(t10) {
          this.isDirty = false, this.scrollbarHeight = 0, this.init(t10);
        }
        drawHandle(t10, e10, i10, s10) {
          let o10 = this.navigatorOptions.handles.height;
          this.handles[e10][s10](i10 ? { translateX: Math.round(this.left + this.height / 2), translateY: Math.round(this.top + parseInt(t10, 10) + 0.5 - o10) } : { translateX: Math.round(this.left + parseInt(t10, 10)), translateY: Math.round(this.top + this.height / 2 - o10 / 2 - 1) });
        }
        drawOutline(t10, e10, i10, s10) {
          let o10 = this.navigatorOptions.maskInside, r10 = this.outline.strokeWidth(), a10 = r10 / 2, n10 = r10 % 2 / 2, h10 = this.scrollButtonSize, l10 = this.size, d10 = this.top, c10 = this.height, p10 = d10 - a10, u2 = d10 + c10, g2 = this.left, f2, m2;
          i10 ? (f2 = d10 + e10 + n10, e10 = d10 + t10 + n10, m2 = [["M", g2 + c10, d10 - h10 - n10], ["L", g2 + c10, f2], ["L", g2, f2], ["M", g2, e10], ["L", g2 + c10, e10], ["L", g2 + c10, d10 + l10 + h10]], o10 && m2.push(["M", g2 + c10, f2 - a10], ["L", g2 + c10, e10 + a10])) : (g2 -= h10, t10 += g2 + h10 - n10, e10 += g2 + h10 - n10, m2 = [["M", g2, p10], ["L", t10, p10], ["L", t10, u2], ["M", e10, u2], ["L", e10, p10], ["L", g2 + l10 + 2 * h10, p10]], o10 && m2.push(["M", t10 - a10, p10], ["L", e10 + a10, p10])), this.outline[s10]({ d: m2 });
        }
        drawMasks(t10, e10, i10, s10) {
          let o10, r10, a10, n10;
          let h10 = this.left, l10 = this.top, d10 = this.height;
          i10 ? (a10 = [h10, h10, h10], n10 = [l10, l10 + t10, l10 + e10], r10 = [d10, d10, d10], o10 = [t10, e10 - t10, this.size - e10]) : (a10 = [h10, h10 + t10, h10 + e10], n10 = [l10, l10, l10], r10 = [t10, e10 - t10, this.size - e10], o10 = [d10, d10, d10]), this.shades.forEach((t11, e11) => {
            t11[s10]({ x: a10[e11], y: n10[e11], width: r10[e11], height: o10[e11] });
          });
        }
        renderElements() {
          var _a;
          let t10 = this, e10 = t10.navigatorOptions, i10 = e10.maskInside, s10 = t10.chart, o10 = s10.inverted, r10 = s10.renderer, a10 = { cursor: o10 ? "ns-resize" : "ew-resize" }, n10 = t10.navigatorGroup ?? (t10.navigatorGroup = r10.g("navigator").attr({ zIndex: 8, visibility: "hidden" }).add());
          if ([!i10, i10, !i10].forEach((i11, o11) => {
            let h10 = t10.shades[o11] ?? (t10.shades[o11] = r10.rect().addClass("highcharts-navigator-mask" + (1 === o11 ? "-inside" : "-outside")).add(n10));
            s10.styledMode || (h10.attr({ fill: i11 ? e10.maskFill : "rgba(0,0,0,0)" }), 1 === o11 && h10.css(a10));
          }), t10.outline || (t10.outline = r10.path().addClass("highcharts-navigator-outline").add(n10)), s10.styledMode || t10.outline.attr({ "stroke-width": e10.outlineWidth, stroke: e10.outlineColor }), (_a = e10.handles) == null ? void 0 : _a.enabled) {
            let i11 = e10.handles, { height: o11, width: h10 } = i11;
            [0, 1].forEach((e11) => {
              var _a2;
              let l10 = i11.symbols[e11];
              if (t10.handles[e11] && t10.handles[e11].symbolUrl === l10) {
                if (!t10.handles[e11].isImg && t10.handles[e11].symbolName !== l10) {
                  let i12 = dR[l10].call(dR, -h10 / 2 - 1, 0, h10, o11);
                  t10.handles[e11].attr({ d: i12 }), t10.handles[e11].symbolName = l10;
                }
              } else (_a2 = t10.handles[e11]) == null ? void 0 : _a2.destroy(), t10.handles[e11] = r10.symbol(l10, -h10 / 2 - 1, 0, h10, o11, i11), t10.handles[e11].attr({ zIndex: 7 - e11 }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][e11]).add(n10), t10.addMouseEvents();
              s10.inverted && t10.handles[e11].attr({ rotation: 90, rotationOriginX: Math.floor(-h10 / 2), rotationOriginY: (o11 + h10) / 2 }), s10.styledMode || t10.handles[e11].attr({ fill: i11.backgroundColor, stroke: i11.borderColor, "stroke-width": i11.lineWidth, width: i11.width, height: i11.height, x: -h10 / 2 - 1, y: 0 }).css(a10);
            });
          }
        }
        update(t10, e10 = false) {
          var _a;
          let i10 = this.chart, s10 = i10.options.chart.inverted !== ((_a = i10.scrollbar) == null ? void 0 : _a.options.vertical);
          if (d$(true, i10.options.navigator, t10), this.navigatorOptions = i10.options.navigator || {}, this.setOpposite(), dX(t10.enabled) || s10) return this.destroy(), this.navigatorEnabled = t10.enabled || this.navigatorEnabled, this.init(i10);
          if (this.navigatorEnabled && (this.isDirty = true, false === t10.adaptToUpdatedData && this.baseSeries.forEach((t11) => {
            dq(t11, "updatedData", this.updatedDataHandler);
          }, this), t10.adaptToUpdatedData && this.baseSeries.forEach((t11) => {
            t11.eventsToUnbind.push(dN(t11, "updatedData", this.updatedDataHandler));
          }, this), (t10.series || t10.baseSeries) && this.setBaseSeries(void 0, false), t10.height || t10.xAxis || t10.yAxis)) {
            this.height = t10.height ?? this.height;
            let e11 = this.getXAxisOffsets();
            this.xAxis.update({ ...t10.xAxis, offsets: e11, [i10.inverted ? "width" : "height"]: this.height, [i10.inverted ? "height" : "width"]: void 0 }, false), this.yAxis.update({ ...t10.yAxis, [i10.inverted ? "width" : "height"]: this.height }, false);
          }
          e10 && i10.redraw();
        }
        render(t10, e10, i10, s10) {
          let o10 = this.chart, r10 = this.xAxis, a10 = r10.pointRange || 0, n10 = r10.navigatorAxis.fake ? o10.xAxis[0] : r10, h10 = this.navigatorEnabled, l10 = this.rendered, d10 = o10.inverted, c10 = o10.xAxis[0].minRange, p10 = o10.xAxis[0].options.maxRange, u2 = this.scrollButtonSize, g2, f2, m2, x2 = this.scrollbarHeight, y2, b2;
          if (this.hasDragged && !dX(i10)) return;
          if (this.isDirty && this.renderElements(), t10 = dG(t10 - a10 / 2), e10 = dG(e10 + a10 / 2), !d_(t10) || !d_(e10)) {
            if (!l10) return;
            i10 = 0, s10 = dZ(r10.width, n10.width);
          }
          this.left = dZ(r10.left, o10.plotLeft + u2 + (d10 ? o10.plotWidth : 0));
          let v2 = this.size = y2 = dZ(r10.len, (d10 ? o10.plotHeight : o10.plotWidth) - 2 * u2);
          g2 = d10 ? x2 : y2 + 2 * u2, i10 = dZ(i10, r10.toPixels(t10, true)), s10 = dZ(s10, r10.toPixels(e10, true)), d_(i10) && Math.abs(i10) !== 1 / 0 || (i10 = 0, s10 = g2);
          let k2 = r10.toValue(i10, true), M2 = r10.toValue(s10, true), w2 = Math.abs(dG(M2 - k2));
          w2 < c10 ? this.grabbedLeft ? i10 = r10.toPixels(M2 - c10 - a10, true) : this.grabbedRight && (s10 = r10.toPixels(k2 + c10 + a10, true)) : dX(p10) && dG(w2 - a10) > p10 && (this.grabbedLeft ? i10 = r10.toPixels(M2 - p10 - a10, true) : this.grabbedRight && (s10 = r10.toPixels(k2 + p10 + a10, true))), this.zoomedMax = dW(Math.max(i10, s10), 0, v2), this.zoomedMin = dW(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i10, s10), 0, v2), this.range = this.zoomedMax - this.zoomedMin, v2 = Math.round(this.zoomedMax);
          let S2 = Math.round(this.zoomedMin);
          h10 && (this.navigatorGroup.attr({ visibility: "inherit" }), b2 = l10 && !this.hasDragged ? "animate" : "attr", this.drawMasks(S2, v2, d10, b2), this.drawOutline(S2, v2, d10, b2), this.navigatorOptions.handles.enabled && (this.drawHandle(S2, 0, d10, b2), this.drawHandle(v2, 1, d10, b2))), this.scrollbar && (d10 ? (m2 = this.top - u2, f2 = this.left - x2 + (h10 || !n10.opposite ? 0 : (n10.titleOffset || 0) + n10.axisTitleMargin), x2 = y2 + 2 * u2) : (m2 = this.top + (h10 ? this.height : -x2), f2 = this.left - u2), this.scrollbar.position(f2, m2, g2, x2), this.scrollbar.setRange(this.zoomedMin / (y2 || 1), this.zoomedMax / (y2 || 1))), this.rendered = true, this.isDirty = false, dU(this, "afterRender");
        }
        addMouseEvents() {
          let t10 = this, e10 = t10.chart, i10 = e10.container, s10 = [], o10, r10;
          t10.mouseMoveHandler = o10 = function(e11) {
            t10.onMouseMove(e11);
          }, t10.mouseUpHandler = r10 = function(e11) {
            t10.onMouseUp(e11);
          }, (s10 = t10.getPartsEvents("mousedown")).push(dN(e10.renderTo, "mousemove", o10), dN(i10.ownerDocument, "mouseup", r10), dN(e10.renderTo, "touchmove", o10), dN(i10.ownerDocument, "touchend", r10)), s10.concat(t10.getPartsEvents("touchstart")), t10.eventsToUnbind = s10, t10.series && t10.series[0] && s10.push(dN(t10.series[0].xAxis, "foundExtremes", function() {
            e10.navigator.modifyNavigatorAxisExtremes();
          }));
        }
        getPartsEvents(t10) {
          let e10 = this, i10 = [];
          return ["shades", "handles"].forEach(function(s10) {
            e10[s10].forEach(function(o10, r10) {
              i10.push(dN(o10.element, t10, function(t11) {
                e10[s10 + "Mousedown"](t11, r10);
              }));
            });
          }), i10;
        }
        shadesMousedown(t10, e10) {
          var _a;
          t10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10;
          let i10 = this.chart, s10 = this.xAxis, o10 = this.zoomedMin, r10 = this.size, a10 = this.range, n10 = this.left, h10 = t10.chartX, l10, d10, c10, p10;
          i10.inverted && (h10 = t10.chartY, n10 = this.top), 1 === e10 ? (this.grabbedCenter = h10, this.fixedWidth = a10, this.dragOffset = h10 - o10) : (p10 = h10 - n10 - a10 / 2, 0 === e10 ? p10 = Math.max(0, p10) : 2 === e10 && p10 + a10 >= r10 && (p10 = r10 - a10, this.reversedExtremes ? (p10 -= a10, d10 = this.getUnionExtremes().dataMin) : l10 = this.getUnionExtremes().dataMax), p10 !== o10 && (this.fixedWidth = a10, dX((c10 = s10.navigatorAxis.toFixedRange(p10, p10 + a10, d10, l10)).min) && dU(this, "setRange", { min: Math.min(c10.min, c10.max), max: Math.max(c10.min, c10.max), redraw: true, eventArguments: { trigger: "navigator" } })));
        }
        handlesMousedown(t10, e10) {
          var _a;
          t10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10;
          let i10 = this.chart, s10 = i10.xAxis[0], o10 = this.reversedExtremes;
          0 === e10 ? (this.grabbedLeft = true, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o10 ? s10.min : s10.max) : (this.grabbedRight = true, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o10 ? s10.max : s10.min), i10.setFixedRange(void 0);
        }
        onMouseMove(t10) {
          var _a;
          let e10 = this, i10 = e10.chart, s10 = e10.navigatorSize, o10 = e10.range, r10 = e10.dragOffset, a10 = i10.inverted, n10 = e10.left, h10;
          (!t10.touches || 0 !== t10.touches[0].pageX) && (h10 = (t10 = ((_a = i10.pointer) == null ? void 0 : _a.normalize(t10)) || t10).chartX, a10 && (n10 = e10.top, h10 = t10.chartY), e10.grabbedLeft ? (e10.hasDragged = true, e10.render(0, 0, h10 - n10, e10.otherHandlePos)) : e10.grabbedRight ? (e10.hasDragged = true, e10.render(0, 0, e10.otherHandlePos, h10 - n10)) : e10.grabbedCenter && (e10.hasDragged = true, h10 < r10 ? h10 = r10 : h10 > s10 + r10 - o10 && (h10 = s10 + r10 - o10), e10.render(0, 0, h10 - r10, h10 - r10 + o10)), e10.hasDragged && e10.scrollbar && dZ(e10.scrollbar.options.liveRedraw, !dz && !this.chart.boosted) && (t10.DOMType = t10.type, setTimeout(function() {
            e10.onMouseUp(t10);
          }, 0)));
        }
        onMouseUp(t10) {
          let e10, i10, s10, o10, r10, a10;
          let n10 = this.chart, h10 = this.xAxis, l10 = this.scrollbar, d10 = t10.DOMEvent || t10, c10 = n10.inverted, p10 = this.rendered && !this.hasDragged ? "animate" : "attr";
          (this.hasDragged && (!l10 || !l10.hasDragged) || "scrollbar" === t10.trigger) && (s10 = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o10 = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r10 = this.fixedExtreme), this.zoomedMax === this.size && (r10 = this.reversedExtremes ? s10.dataMin : s10.dataMax), 0 === this.zoomedMin && (o10 = this.reversedExtremes ? s10.dataMax : s10.dataMin), dX((a10 = h10.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o10, r10)).min) && dU(this, "setRange", { min: Math.min(a10.min, a10.max), max: Math.max(a10.min, a10.max), redraw: true, animation: !this.hasDragged && null, eventArguments: { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: d10 } })), "mousemove" !== t10.DOMType && "touchmove" !== t10.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && d_(this.zoomedMin) && d_(this.zoomedMax) && (i10 = Math.round(this.zoomedMin), e10 = Math.round(this.zoomedMax), this.shades && this.drawMasks(i10, e10, c10, p10), this.outline && this.drawOutline(i10, e10, c10, p10), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i10, 0, c10, p10), this.drawHandle(e10, 1, c10, p10)));
        }
        removeEvents() {
          this.eventsToUnbind && (this.eventsToUnbind.forEach(function(t10) {
            t10();
          }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();
        }
        removeBaseSeriesEvents() {
          let t10 = this.baseSeries || [];
          this.navigatorEnabled && t10[0] && (false !== this.navigatorOptions.adaptToUpdatedData && t10.forEach(function(t11) {
            dq(t11, "updatedData", this.updatedDataHandler);
          }, this), t10[0].xAxis && dq(t10[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
        }
        getXAxisOffsets() {
          return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];
        }
        init(t10) {
          var _a;
          let e10 = t10.options, i10 = e10.navigator || {}, s10 = i10.enabled, o10 = e10.scrollbar || {}, r10 = o10.enabled, a10 = s10 && i10.height || 0, n10 = r10 && o10.height || 0, h10 = o10.buttonsEnabled && n10 || 0;
          this.handles = [], this.shades = [], this.chart = t10, this.setBaseSeries(), this.height = a10, this.scrollbarHeight = n10, this.scrollButtonSize = h10, this.scrollbarEnabled = r10, this.navigatorEnabled = s10, this.navigatorOptions = i10, this.scrollbarOptions = o10, this.setOpposite();
          let l10 = this, d10 = l10.baseSeries, c10 = t10.xAxis.length, p10 = t10.yAxis.length, u2 = d10 && d10[0] && d10[0].xAxis || t10.xAxis[0] || { options: {} };
          if (t10.isDirtyBox = true, l10.navigatorEnabled) {
            let e11 = this.getXAxisOffsets();
            l10.xAxis = new s_(t10, d$({ breaks: u2.options.breaks, ordinal: u2.options.ordinal, overscroll: u2.options.overscroll }, i10.xAxis, { type: "datetime", yAxis: (_a = i10.yAxis) == null ? void 0 : _a.id, index: c10, isInternal: true, offset: 0, keepOrdinalPadding: true, startOnTick: false, endOnTick: false, minPadding: u2.options.ordinal ? 0 : u2.options.minPadding, maxPadding: u2.options.ordinal ? 0 : u2.options.maxPadding, zoomEnabled: false }, t10.inverted ? { offsets: e11, width: a10 } : { offsets: e11, height: a10 }), "xAxis"), l10.yAxis = new s_(t10, d$(i10.yAxis, { alignTicks: false, offset: 0, index: p10, isInternal: true, reversed: dZ(i10.yAxis && i10.yAxis.reversed, t10.yAxis[0] && t10.yAxis[0].reversed, false), zoomEnabled: false }, t10.inverted ? { width: a10 } : { height: a10 }), "yAxis"), d10 || i10.series.data ? l10.updateNavigatorSeries(false) : 0 === t10.series.length && (l10.unbindRedraw = dN(t10, "beforeRedraw", function() {
              t10.series.length > 0 && !l10.series && (l10.setBaseSeries(), l10.unbindRedraw());
            })), l10.reversedExtremes = t10.inverted && !l10.xAxis.reversed || !t10.inverted && l10.xAxis.reversed, l10.renderElements(), l10.addMouseEvents();
          } else l10.xAxis = { chart: t10, navigatorAxis: { fake: true }, translate: function(e11, i11) {
            let s11 = t10.xAxis[0], o11 = s11.getExtremes(), r11 = s11.len - 2 * h10, a11 = dJ("min", s11.options.min, o11.dataMin), n11 = dJ("max", s11.options.max, o11.dataMax) - a11;
            return i11 ? e11 * n11 / r11 + a11 : r11 * (e11 - a11) / n11;
          }, toPixels: function(t11) {
            return this.translate(t11);
          }, toValue: function(t11) {
            return this.translate(t11, true);
          } }, l10.xAxis.navigatorAxis.axis = l10.xAxis, l10.xAxis.navigatorAxis.toFixedRange = l8.prototype.toFixedRange.bind(l10.xAxis.navigatorAxis);
          if (t10.options.scrollbar.enabled) {
            let e11 = d$(t10.options.scrollbar, { vertical: t10.inverted });
            !d_(e11.margin) && l10.navigatorEnabled && (e11.margin = t10.inverted ? -3 : 3), t10.scrollbar = l10.scrollbar = new dB(t10.renderer, e11, t10), dN(l10.scrollbar, "changed", function(t11) {
              let e12 = l10.size, i11 = e12 * this.to, s11 = e12 * this.from;
              l10.hasDragged = l10.scrollbar.hasDragged, l10.render(0, 0, s11, i11), this.shouldUpdateExtremes(t11.DOMType) && setTimeout(function() {
                l10.onMouseUp(t11);
              });
            });
          }
          l10.addBaseSeriesEvents(), l10.addChartEvents();
        }
        setOpposite() {
          let t10 = this.navigatorOptions, e10 = this.navigatorEnabled, i10 = this.chart;
          this.opposite = dZ(t10.opposite, !!(!e10 && i10.inverted));
        }
        getUnionExtremes(t10) {
          let e10;
          let i10 = this.chart.xAxis[0], s10 = this.chart.time, o10 = this.xAxis, r10 = o10.options, a10 = i10.options;
          return t10 && null === i10.dataMin || (e10 = { dataMin: dZ(s10.parse(r10 == null ? void 0 : r10.min), dJ("min", s10.parse(a10.min), i10.dataMin, o10.dataMin, o10.min)), dataMax: dZ(s10.parse(r10 == null ? void 0 : r10.max), dJ("max", s10.parse(a10.max), i10.dataMax, o10.dataMax, o10.max)) }), e10;
        }
        setBaseSeries(t10, e10) {
          let i10 = this.chart, s10 = this.baseSeries = [];
          t10 = t10 || i10.options && i10.options.navigator.baseSeries || (i10.series.length ? dj(i10.series, (t11) => !t11.options.isInternal).index : 0), (i10.series || []).forEach((e11, i11) => {
            !e11.options.isInternal && (e11.options.showInNavigator || (i11 === t10 || e11.options.id === t10) && false !== e11.options.showInNavigator) && s10.push(e11);
          }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(true, e10);
        }
        updateNavigatorSeries(t10, e10) {
          var _a, _b;
          let i10 = this, s10 = i10.chart, o10 = i10.baseSeries, r10 = { enableMouseTracking: false, index: null, linkedTo: null, group: "nav", padXAxis: false, xAxis: (_a = this.navigatorOptions.xAxis) == null ? void 0 : _a.id, yAxis: (_b = this.navigatorOptions.yAxis) == null ? void 0 : _b.id, showInLegend: false, stacking: void 0, isInternal: true, states: { inactive: { opacity: 1 } } }, a10 = i10.series = (i10.series || []).filter((t11) => {
            let e11 = t11.baseSeries;
            return !(0 > o10.indexOf(e11)) || (e11 && (dq(e11, "updatedData", i10.updatedDataHandler), delete e11.navigatorSeries), t11.chart && t11.destroy(), false);
          }), n10, h10, l10 = i10.navigatorOptions.series, d10;
          o10 && o10.length && o10.forEach((t11) => {
            var _a2;
            let c10 = t11.navigatorSeries, p10 = dY({ color: t11.color, visible: t11.visible }, dV(l10) ? dI.navigator.series : l10);
            if (c10 && false === i10.navigatorOptions.adaptToUpdatedData) return;
            r10.name = "Navigator " + o10.length, d10 = (n10 = t11.options || {}).navigatorOptions || {}, p10.dataLabels = dK(p10.dataLabels), (h10 = d$(n10, r10, p10, d10)).pointRange = dZ(p10.pointRange, d10.pointRange, dI.plotOptions[h10.type || "line"].pointRange);
            let u2 = d10.data || p10.data;
            i10.hasNavigatorData = i10.hasNavigatorData || !!u2, h10.data = u2 || ((_a2 = n10.data) == null ? void 0 : _a2.slice(0)), c10 && c10.options ? c10.update(h10, e10) : (t11.navigatorSeries = s10.initSeries(h10), s10.setSortedData(), t11.navigatorSeries.baseSeries = t11, a10.push(t11.navigatorSeries));
          }), (l10.data && !(o10 && o10.length) || dV(l10)) && (i10.hasNavigatorData = false, (l10 = dK(l10)).forEach((t11, e11) => {
            r10.name = "Navigator " + (a10.length + 1), (h10 = d$(dI.navigator.series, { color: s10.series[e11] && !s10.series[e11].options.isInternal && s10.series[e11].color || s10.options.colors[e11] || s10.options.colors[0] }, r10, t11)).data = t11.data, h10.data && (i10.hasNavigatorData = true, a10.push(s10.initSeries(h10)));
          })), t10 && this.addBaseSeriesEvents();
        }
        addBaseSeriesEvents() {
          let t10 = this, e10 = t10.baseSeries || [];
          e10[0] && e10[0].xAxis && e10[0].eventsToUnbind.push(dN(e10[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), e10.forEach((i10) => {
            i10.eventsToUnbind.push(dN(i10, "show", function() {
              this.navigatorSeries && this.navigatorSeries.setVisible(true, false);
            })), i10.eventsToUnbind.push(dN(i10, "hide", function() {
              this.navigatorSeries && this.navigatorSeries.setVisible(false, false);
            })), false !== this.navigatorOptions.adaptToUpdatedData && i10.xAxis && i10.eventsToUnbind.push(dN(i10, "updatedData", this.updatedDataHandler)), i10.eventsToUnbind.push(dN(i10, "remove", function() {
              e10 && dF(e10, i10), this.navigatorSeries && t10.series && (dF(t10.series, this.navigatorSeries), dX(this.navigatorSeries.options) && this.navigatorSeries.remove(false), delete this.navigatorSeries);
            }));
          });
        }
        getBaseSeriesMin(t10) {
          return this.baseSeries.reduce(function(t11, e10) {
            return Math.min(t11, e10.getColumn("x")[0] ?? t11);
          }, t10);
        }
        modifyNavigatorAxisExtremes() {
          let t10 = this.xAxis;
          if (void 0 !== t10.getExtremes) {
            let e10 = this.getUnionExtremes(true);
            e10 && (e10.dataMin !== t10.min || e10.dataMax !== t10.max) && (t10.min = e10.dataMin, t10.max = e10.dataMax);
          }
        }
        modifyBaseAxisExtremes() {
          var _a;
          let t10, e10;
          let i10 = this.chart.navigator, s10 = this.getExtremes(), o10 = s10.min, r10 = s10.max, a10 = s10.dataMin, n10 = s10.dataMax, h10 = r10 - o10, l10 = i10.stickToMin, d10 = i10.stickToMax, c10 = dZ((_a = this.ordinal) == null ? void 0 : _a.convertOverscroll(this.options.overscroll), 0), p10 = i10.series && i10.series[0], u2 = !!this.setExtremes;
          !(this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger) && (l10 && (t10 = (e10 = a10) + h10), d10 && (t10 = n10 + c10, l10 || (e10 = Math.max(a10, t10 - h10, i10.getBaseSeriesMin(p10 && p10.xData ? p10.xData[0] : -Number.MAX_VALUE)))), u2 && (l10 || d10) && d_(e10) && (this.min = this.userMin = e10, this.max = this.userMax = t10)), i10.stickToMin = i10.stickToMax = null;
        }
        updatedDataHandler() {
          let t10 = this.chart.navigator, e10 = this.navigatorSeries, i10 = t10.reversedExtremes ? 0 === Math.round(t10.zoomedMin) : Math.round(t10.zoomedMax) >= Math.round(t10.size);
          t10.stickToMax = dZ(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i10), t10.stickToMin = t10.shouldStickToMin(this, t10), e10 && !t10.hasNavigatorData && (e10.options.pointStart = this.getColumn("x")[0], e10.setData(this.options.data, false, null, false));
        }
        shouldStickToMin(t10, e10) {
          let i10 = e10.getBaseSeriesMin(t10.getColumn("x")[0]), s10 = t10.xAxis, o10 = s10.max, r10 = s10.min, a10 = s10.options.range;
          return !!(d_(o10) && d_(r10)) && (a10 && o10 - i10 > 0 ? o10 - i10 < a10 : r10 <= i10);
        }
        addChartEvents() {
          this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(dN(this.chart, "redraw", function() {
            let t10 = this.navigator, e10 = t10 && (t10.baseSeries && t10.baseSeries[0] && t10.baseSeries[0].xAxis || this.xAxis[0]);
            e10 && t10.render(e10.min, e10.max);
          }), dN(this.chart, "getMargins", function() {
            let t10 = this.navigator, e10 = t10.opposite ? "plotTop" : "marginBottom";
            this.inverted && (e10 = t10.opposite ? "marginRight" : "plotLeft"), this[e10] = (this[e10] || 0) + (t10.navigatorEnabled || !this.inverted ? t10.height + t10.scrollbarHeight : 0) + t10.navigatorOptions.margin;
          }), dN(dQ, "setRange", function(t10) {
            this.chart.xAxis[0].setExtremes(t10.min, t10.max, t10.redraw, t10.animation, t10.eventArguments);
          }));
        }
        destroy() {
          this.removeEvents(), this.xAxis && (dF(this.chart.xAxis, this.xAxis), dF(this.chart.axes, this.xAxis)), this.yAxis && (dF(this.chart.yAxis, this.yAxis), dF(this.chart.axes, this.yAxis)), (this.series || []).forEach((t10) => {
            t10.destroy && t10.destroy();
          }), ["series", "xAxis", "yAxis", "shades", "outline", "scrollbarTrack", "scrollbarRifles", "scrollbarGroup", "scrollbar", "navigatorGroup", "rendered"].forEach((t10) => {
            this[t10] && this[t10].destroy && this[t10].destroy(), this[t10] = null;
          }), [this.handles].forEach((t10) => {
            dH(t10);
          }), this.navigatorEnabled = false;
        }
      }
      let { addEvent: d0, correctFloat: d1, css: d2, defined: d3, error: d5, isNumber: d6, pick: d9, timeUnits: d4, isString: d8 } = ti;
      !function(t10) {
        function e10(t11, i11, s11, o11, r11 = [], a11 = 0, n11) {
          let h11 = {}, l11 = this.options.tickPixelInterval, d11 = this.chart.time, c11 = [], p10, u2, g2, f2, m2, x2 = 0, y2 = [], b2 = -Number.MAX_VALUE;
          if (!this.options.ordinal && !this.options.breaks || !r11 || r11.length < 3 || void 0 === i11) return d11.getTimeTicks.apply(d11, arguments);
          let v2 = r11.length;
          for (p10 = 0; p10 < v2; p10++) {
            if (m2 = p10 && r11[p10 - 1] > s11, r11[p10] < i11 && (x2 = p10), p10 === v2 - 1 || r11[p10 + 1] - r11[p10] > 5 * a11 || m2) {
              if (r11[p10] > b2) {
                for (u2 = d11.getTimeTicks(t11, r11[x2], r11[p10], o11); u2.length && u2[0] <= b2; ) u2.shift();
                u2.length && (b2 = u2[u2.length - 1]), c11.push(y2.length), y2 = y2.concat(u2);
              }
              x2 = p10 + 1;
            }
            if (m2) break;
          }
          if (u2) {
            if (f2 = u2.info, n11 && f2.unitRange <= d4.hour) {
              for (x2 = 1, p10 = y2.length - 1; x2 < p10; x2++) d11.dateFormat("%d", y2[x2]) !== d11.dateFormat("%d", y2[x2 - 1]) && (h11[y2[x2]] = "day", g2 = true);
              g2 && (h11[y2[0]] = "day"), f2.higherRanks = h11;
            }
            f2.segmentStarts = c11, y2.info = f2;
          } else d5(12, false, this.chart);
          if (n11 && d3(l11)) {
            let t12 = y2.length, e11 = [], i12 = [], o12, r12, a12, n12, d12, c12 = t12;
            for (; c12--; ) r12 = this.translate(y2[c12]), a12 && (i12[c12] = a12 - r12), e11[c12] = a12 = r12;
            for (i12.sort((t13, e12) => t13 - e12), (n12 = i12[Math.floor(i12.length / 2)]) < 0.6 * l11 && (n12 = null), c12 = y2[t12 - 1] > s11 ? t12 - 1 : t12, a12 = void 0; c12--; ) d12 = Math.abs(a12 - (r12 = e11[c12])), a12 && d12 < 0.8 * l11 && (null === n12 || d12 < 0.8 * n12) ? (h11[y2[c12]] && !h11[y2[c12 + 1]] ? (o12 = c12 + 1, a12 = r12) : o12 = c12, y2.splice(o12, 1)) : a12 = r12;
          }
          return y2;
        }
        function i10(t11) {
          let e11 = this.ordinal.positions;
          if (!e11) return t11;
          let i11 = e11.length - 1, s11;
          return (t11 < 0 ? t11 = e11[0] : t11 > i11 ? t11 = e11[i11] : (i11 = Math.floor(t11), s11 = t11 - i11), void 0 !== s11 && void 0 !== e11[i11]) ? e11[i11] + (s11 ? s11 * (e11[i11 + 1] - e11[i11]) : 0) : t11;
        }
        function s10(t11) {
          let e11 = this.ordinal, i11 = this.old ? this.old.min : this.min, s11 = this.old ? this.old.transA : this.transA, o11 = e11.getExtendedPositions();
          if (o11 == null ? void 0 : o11.length) {
            let r11 = d1((t11 - i11) * s11 + this.minPixelPadding), a11 = d1(e11.getIndexOfPoint(r11, o11)), n11 = d1(a11 % 1);
            if (a11 >= 0 && a11 <= o11.length - 1) {
              let t12 = o11[Math.floor(a11)], e12 = o11[Math.ceil(a11)];
              return o11[Math.floor(a11)] + n11 * (e12 - t12);
            }
          }
          return t11;
        }
        function o10(e11, i11) {
          let s11 = t10.Additions.findIndexOf(e11, i11, true);
          if (e11[s11] === i11) return s11;
          let o11 = (i11 - e11[s11]) / (e11[s11 + 1] - e11[s11]);
          return s11 + o11;
        }
        function r10() {
          this.ordinal || (this.ordinal = new t10.Additions(this));
        }
        function a10() {
          let { eventArgs: t11, options: e11 } = this;
          if (this.isXAxis && d3(e11.overscroll) && 0 !== e11.overscroll && d6(this.max) && d6(this.min) && (this.options.ordinal && !this.ordinal.originalOrdinalRange && this.ordinal.getExtendedPositions(false), this.max === this.dataMax && ((t11 == null ? void 0 : t11.trigger) !== "pan" || this.isInternal) && (t11 == null ? void 0 : t11.trigger) !== "navigator")) {
            let i11 = this.ordinal.convertOverscroll(e11.overscroll);
            this.max += i11, !this.isInternal && d3(this.userMin) && (t11 == null ? void 0 : t11.trigger) !== "mousewheel" && (this.min += i11);
          }
        }
        function n10() {
          this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
        }
        function h10() {
          this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
        }
        function l10(t11) {
          let e11 = this.xAxis[0], i11 = e11.ordinal.convertOverscroll(e11.options.overscroll), s11 = t11.originalEvent.chartX, o11 = this.options.chart.panning, r11 = false;
          if (o11 && "y" !== o11.type && e11.options.ordinal && e11.series.length && (!t11.touches || t11.touches.length <= 1)) {
            let t12, o12;
            let a11 = this.mouseDownX, n11 = e11.getExtremes(), h11 = n11.dataMin, l11 = n11.dataMax, d11 = n11.min, c11 = n11.max, p10 = this.hoverPoints, u2 = e11.closestPointRange || e11.ordinal && e11.ordinal.overscrollPointsRange, g2 = Math.round((a11 - s11) / (e11.translationSlope * (e11.ordinal.slope || u2))), f2 = e11.ordinal.getExtendedPositions(), m2 = { ordinal: { positions: f2, extendedOrdinalPositions: f2 } }, x2 = e11.index2val, y2 = e11.val2lin;
            if (d11 <= h11 && g2 < 0 || c11 + i11 >= l11 && g2 > 0) return;
            m2.ordinal.positions ? Math.abs(g2) > 1 && (p10 && p10.forEach(function(t13) {
              t13.setState();
            }), l11 > (o12 = m2.ordinal.positions)[o12.length - 1] && o12.push(l11), this.setFixedRange(c11 - d11), (t12 = e11.navigatorAxis.toFixedRange(void 0, void 0, x2.apply(m2, [y2.apply(m2, [d11, true]) + g2]), x2.apply(m2, [y2.apply(m2, [c11, true]) + g2]))).min >= Math.min(o12[0], d11) && t12.max <= Math.max(o12[o12.length - 1], c11) + i11 && e11.setExtremes(t12.min, t12.max, true, false, { trigger: "pan" }), this.mouseDownX = s11, d2(this.container, { cursor: "move" })) : r11 = true;
          } else r11 = true;
          r11 || o11 && /y/.test(o11.type) ? i11 && (e11.max = e11.dataMax + i11) : t11.preventDefault();
        }
        function d10() {
          let t11 = this.xAxis;
          t11 && t11.options.ordinal && (delete t11.ordinal.index, delete t11.ordinal.originalOrdinalRange);
        }
        function c10(t11, e11) {
          let i11;
          let s11 = this.ordinal, r11 = s11.positions, a11 = s11.slope, n11;
          if (!r11) return t11;
          let h11 = r11.length;
          if (r11[0] <= t11 && r11[h11 - 1] >= t11) i11 = o10(r11, t11);
          else {
            if (!((n11 = s11.getExtendedPositions && s11.getExtendedPositions()) && n11.length)) return t11;
            let h12 = n11.length;
            a11 || (a11 = (n11[h12 - 1] - n11[0]) / h12);
            let l11 = o10(n11, r11[0]);
            if (t11 >= n11[0] && t11 <= n11[h12 - 1]) i11 = o10(n11, t11) - l11;
            else {
              if (!e11) return t11;
              i11 = t11 < n11[0] ? -l11 - (n11[0] - t11) / a11 : (t11 - n11[h12 - 1]) / a11 + h12 - l11;
            }
          }
          return e11 ? i11 : a11 * (i11 || 0) + s11.offset;
        }
        t10.compose = function(t11, o11, p10) {
          let u2 = t11.prototype;
          return u2.ordinal2lin || (u2.getTimeTicks = e10, u2.index2val = i10, u2.lin2val = s10, u2.val2lin = c10, u2.ordinal2lin = u2.val2lin, d0(t11, "afterInit", r10), d0(t11, "foundExtremes", a10), d0(t11, "afterSetScale", n10), d0(t11, "initialAxisTranslation", h10), d0(p10, "pan", l10), d0(p10, "touchpan", l10), d0(o11, "updatedData", d10)), t11;
        }, t10.Additions = class {
          constructor(t11) {
            this.index = {}, this.axis = t11;
          }
          beforeSetTickPositions() {
            var _a;
            let t11 = this.axis, e11 = t11.ordinal, i11 = t11.getExtremes(), s11 = i11.min, o11 = i11.max, r11 = (_a = t11.brokenAxis) == null ? void 0 : _a.hasBreaks, a11 = t11.options.ordinal, n11, h11, l11, d11, c11, p10, u2, g2 = [], f2 = Number.MAX_VALUE, m2 = false, x2 = false, y2 = false;
            if (a11 || r11) {
              let i12 = 0;
              if (t11.series.forEach(function(t12, e12) {
                let s12 = t12.getColumn("x", true);
                if (h11 = [], e12 > 0 && "highcharts-navigator-series" !== t12.options.id && s12.length > 1 && (x2 = i12 !== s12[1] - s12[0]), i12 = s12[1] - s12[0], t12.boosted && (y2 = t12.boosted), t12.reserveSpace() && (false !== t12.takeOrdinalPosition || r11) && (n11 = (g2 = g2.concat(s12)).length, g2.sort(function(t13, e13) {
                  return t13 - e13;
                }), f2 = Math.min(f2, d9(t12.closestPointRange, f2)), n11)) {
                  for (e12 = 0; e12 < n11 - 1; ) g2[e12] !== g2[e12 + 1] && h11.push(g2[e12 + 1]), e12++;
                  h11[0] !== g2[0] && h11.unshift(g2[0]), g2 = h11;
                }
              }), t11.ordinal.originalOrdinalRange || (t11.ordinal.originalOrdinalRange = (g2.length - 1) * f2), x2 && y2 && (g2.pop(), g2.shift()), (n11 = g2.length) > 2) {
                for (l11 = g2[1] - g2[0], u2 = n11 - 1; u2-- && !m2; ) g2[u2 + 1] - g2[u2] !== l11 && (m2 = true);
                !t11.options.keepOrdinalPadding && (g2[0] - s11 > l11 || o11 - g2[g2.length - 1] > l11) && (m2 = true);
              } else t11.options.overscroll && (2 === n11 ? f2 = g2[1] - g2[0] : 1 === n11 ? (f2 = t11.ordinal.convertOverscroll(t11.options.overscroll), g2 = [g2[0], g2[0] + f2]) : f2 = e11.overscrollPointsRange);
              m2 || t11.forceOrdinal ? (t11.options.overscroll && (e11.overscrollPointsRange = f2, g2 = g2.concat(e11.getOverscrollPositions())), e11.positions = g2, d11 = t11.ordinal2lin(Math.max(s11, g2[0]), true), c11 = Math.max(t11.ordinal2lin(Math.min(o11, g2[g2.length - 1]), true), 1), e11.slope = p10 = (o11 - s11) / (c11 - d11), e11.offset = s11 - d11 * p10) : (e11.overscrollPointsRange = d9(t11.closestPointRange, e11.overscrollPointsRange), e11.positions = t11.ordinal.slope = e11.offset = void 0);
            }
            t11.isOrdinal = a11 && m2, e11.groupIntervalFactor = null;
          }
          static findIndexOf(t11, e11, i11) {
            let s11 = 0, o11 = t11.length - 1, r11;
            for (; s11 < o11; ) t11[r11 = Math.ceil((s11 + o11) / 2)] <= e11 ? s11 = r11 : o11 = r11 - 1;
            return t11[s11] === e11 ? s11 : i11 ? s11 : -1;
          }
          getExtendedPositions(t11 = true) {
            let e11 = this, i11 = e11.axis, s11 = i11.constructor.prototype, o11 = i11.chart, r11 = i11.series.reduce((t12, e12) => {
              let i12 = e12.currentDataGrouping;
              return t12 + (i12 ? i12.count + i12.unitName : "raw");
            }, ""), a11 = t11 ? i11.ordinal.convertOverscroll(i11.options.overscroll) : 0, n11 = i11.getExtremes(), h11, l11, d11 = e11.index;
            return d11 || (d11 = e11.index = {}), !d11[r11] && ((h11 = { series: [], chart: o11, forceOrdinal: false, getExtremes: function() {
              return { min: n11.dataMin, max: n11.dataMax + a11 };
            }, applyGrouping: s11.applyGrouping, getGroupPixelWidth: s11.getGroupPixelWidth, getTimeTicks: s11.getTimeTicks, options: { ordinal: true }, ordinal: { getGroupIntervalFactor: this.getGroupIntervalFactor }, ordinal2lin: s11.ordinal2lin, getIndexOfPoint: s11.getIndexOfPoint, val2lin: s11.val2lin }).ordinal.axis = h11, i11.series.forEach((i12) => {
              var _a, _b, _c;
              l11 = { xAxis: h11, chart: o11, groupPixelWidth: i12.groupPixelWidth, destroyGroupedData: L.noop, getColumn: i12.getColumn, applyGrouping: i12.applyGrouping, getProcessedData: i12.getProcessedData, reserveSpace: i12.reserveSpace, visible: i12.visible };
              let s12 = i12.getColumn("x").concat(t11 ? e11.getOverscrollPositions() : []);
              l11.dataTable = new rc({ columns: { x: s12 } }), l11.options = { ...i12.options, dataGrouping: i12.currentDataGrouping ? { firstAnchor: (_a = i12.options.dataGrouping) == null ? void 0 : _a.firstAnchor, anchor: (_b = i12.options.dataGrouping) == null ? void 0 : _b.anchor, lastAnchor: (_c = i12.options.dataGrouping) == null ? void 0 : _c.firstAnchor, enabled: true, forced: true, approximation: "open", units: [[i12.currentDataGrouping.unitName, [i12.currentDataGrouping.count]]] } : { enabled: false } }, h11.series.push(l11), i12.processData.apply(l11);
            }), h11.applyGrouping({ hasExtremesChanged: true }), (l11 == null ? void 0 : l11.closestPointRange) !== (l11 == null ? void 0 : l11.basePointRange) && l11.currentDataGrouping && (h11.forceOrdinal = true), i11.ordinal.beforeSetTickPositions.apply({ axis: h11 }), !i11.ordinal.originalOrdinalRange && h11.ordinal.originalOrdinalRange && (i11.ordinal.originalOrdinalRange = h11.ordinal.originalOrdinalRange), h11.ordinal.positions && (d11[r11] = h11.ordinal.positions)), d11[r11];
          }
          getGroupIntervalFactor(t11, e11, i11) {
            let s11 = i11.getColumn("x", true), o11 = s11.length, r11 = [], a11, n11, h11 = this.groupIntervalFactor;
            if (!h11) {
              for (n11 = 0; n11 < o11 - 1; n11++) r11[n11] = s11[n11 + 1] - s11[n11];
              r11.sort(function(t12, e12) {
                return t12 - e12;
              }), a11 = r11[Math.floor(o11 / 2)], t11 = Math.max(t11, s11[0]), e11 = Math.min(e11, s11[o11 - 1]), this.groupIntervalFactor = h11 = o11 * a11 / (e11 - t11);
            }
            return h11;
          }
          getIndexOfPoint(t11, e11) {
            let i11 = this.axis, s11 = i11.min, r11 = i11.minPixelPadding;
            return o10(e11, s11) + d1((t11 - r11) / (i11.translationSlope * (this.slope || i11.closestPointRange || this.overscrollPointsRange)));
          }
          getOverscrollPositions() {
            let t11 = this.axis, e11 = this.convertOverscroll(t11.options.overscroll), i11 = this.overscrollPointsRange, s11 = [], o11 = t11.dataMax;
            if (d3(i11)) for (; o11 < t11.dataMax + e11; ) s11.push(o11 += i11);
            return s11;
          }
          postProcessTickInterval(t11) {
            let e11 = this.axis, i11 = this.slope, s11 = e11.closestPointRange;
            return i11 && s11 ? e11.options.breaks ? s11 || t11 : t11 / (i11 / s11) : t11;
          }
          convertOverscroll(t11 = 0) {
            let e11 = this, i11 = e11.axis, s11 = function(t12) {
              return d9(e11.originalOrdinalRange, d3(i11.dataMax) && d3(i11.dataMin) ? i11.dataMax - i11.dataMin : 0) * t12;
            };
            if (d8(t11)) {
              let e12 = parseInt(t11, 10);
              if (/%$/.test(t11)) return s11(e12 / 100);
              if (/px/.test(t11)) {
                let t12 = Math.min(e12, 0.9 * i11.len) / i11.len;
                return s11(t12 / (1 - t12));
              }
              return 0;
            }
            return t11;
          }
        };
      }(A || (A = {}));
      let d7 = A, ct = { lang: { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "", rangeSelectorTo: "→" }, rangeSelector: { allButtonsEnabled: false, buttons: [{ type: "month", count: 1, text: "1m", title: "View 1 month" }, { type: "month", count: 3, text: "3m", title: "View 3 months" }, { type: "month", count: 6, text: "6m", title: "View 6 months" }, { type: "ytd", text: "YTD", title: "View year to date" }, { type: "year", count: 1, text: "1y", title: "View 1 year" }, { type: "all", text: "All", title: "View all" }], buttonSpacing: 5, dropdown: "responsive", enabled: void 0, verticalAlign: "top", buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 }, floating: false, x: 0, y: 0, height: void 0, inputBoxBorderColor: "none", inputBoxHeight: 17, inputBoxWidth: void 0, inputDateFormat: "%[ebY]", inputDateParser: void 0, inputEditDateFormat: "%Y-%m-%d", inputEnabled: true, inputPosition: { align: "right", x: 0, y: 0 }, inputSpacing: 5, selected: void 0, buttonPosition: { align: "left", x: 0, y: 0 }, inputStyle: { color: "#334eff", cursor: "pointer", fontSize: "0.8em" }, labelStyle: { color: "#666666", fontSize: "0.8em" } } }, { defaultOptions: ce } = tT, { composed: ci } = L, { addEvent: cs, defined: co, extend: cr, isNumber: ca, merge: cn, pick: ch, pushUnique: cl } = ti, cd = [];
      function cc() {
        let t10, e10;
        let i10 = this.range, s10 = i10.type, o10 = this.max, r10 = this.chart.time, a10 = function(t11, e11) {
          let i11 = r10.toParts(t11), o11 = i11.slice();
          "year" === s10 ? o11[0] += e11 : o11[1] += e11;
          let a11 = r10.makeTime.apply(r10, o11), n11 = r10.toParts(a11);
          return "month" === s10 && i11[1] === n11[1] && 1 === Math.abs(e11) && (o11[0] = i11[0], o11[1] = i11[1], o11[2] = 0), (a11 = r10.makeTime.apply(r10, o11)) - t11;
        };
        ca(i10) ? (t10 = o10 - i10, e10 = i10) : i10 && (t10 = o10 + a10(o10, -(i10.count || 1)), this.chart && this.chart.setFixedRange(o10 - t10));
        let n10 = ch(this.dataMin, Number.MIN_VALUE);
        return ca(t10) || (t10 = n10), t10 <= n10 && (t10 = n10, void 0 === e10 && (e10 = a10(t10, i10.count)), this.newMax = Math.min(t10 + e10, ch(this.dataMax, Number.MAX_VALUE))), ca(o10) ? !ca(i10) && i10 && i10._offsetMin && (t10 += i10._offsetMin) : t10 = void 0, t10;
      }
      function cp() {
        var _a;
        (_a = this.rangeSelector) == null ? void 0 : _a.redrawElements();
      }
      function cu() {
        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new s(this));
      }
      function cg() {
        let t10 = this.rangeSelector;
        if (t10) {
          ca(t10.deferredYTDClick) && (t10.clickButton(t10.deferredYTDClick), delete t10.deferredYTDClick);
          let e10 = t10.options.verticalAlign;
          t10.options.floating || ("bottom" === e10 ? this.extraBottomMargin = true : "top" !== e10 || (this.extraTopMargin = true));
        }
      }
      function cf() {
        let t10;
        let e10 = this.rangeSelector;
        if (!e10) return;
        let i10 = this.xAxis[0].getExtremes(), s10 = this.legend, o10 = e10 && e10.options.verticalAlign;
        ca(i10.min) && e10.render(i10.min, i10.max), s10.display && "top" === o10 && o10 === s10.options.verticalAlign && (t10 = cn(this.spacingBox), "vertical" === s10.options.layout ? t10.y = this.plotTop : t10.y += e10.getHeight(), s10.group.placed = false, s10.align(t10));
      }
      function cm() {
        for (let t10 = 0, e10 = cd.length; t10 < e10; ++t10) {
          let e11 = cd[t10];
          if (e11[0] === this) {
            e11[1].forEach((t11) => t11()), cd.splice(t10, 1);
            return;
          }
        }
      }
      function cx() {
        var _a;
        let t10 = this.rangeSelector;
        if ((_a = t10 == null ? void 0 : t10.options) == null ? void 0 : _a.enabled) {
          let e10 = t10.getHeight(), i10 = t10.options.verticalAlign;
          t10.options.floating || ("bottom" === i10 ? this.marginBottom += e10 : "middle" === i10 || (this.plotTop += e10));
        }
      }
      function cy(t10) {
        let e10 = t10.options.rangeSelector, i10 = this.extraBottomMargin, o10 = this.extraTopMargin, r10 = this.rangeSelector;
        if (e10 && e10.enabled && !co(r10) && this.options.rangeSelector && (this.options.rangeSelector.enabled = true, this.rangeSelector = r10 = new s(this)), this.extraBottomMargin = false, this.extraTopMargin = false, r10) {
          let t11 = e10 && e10.verticalAlign || r10.options && r10.options.verticalAlign;
          r10.options.floating || ("bottom" === t11 ? this.extraBottomMargin = true : "middle" === t11 || (this.extraTopMargin = true)), (this.extraBottomMargin !== i10 || this.extraTopMargin !== o10) && (this.isDirtyBox = true);
        }
      }
      let cb = { compose: function(t10, e10, i10) {
        if (s = i10, cl(ci, "RangeSelector")) {
          let i11 = e10.prototype;
          t10.prototype.minFromRange = cc, cs(e10, "afterGetContainer", cu), cs(e10, "beforeRender", cg), cs(e10, "destroy", cm), cs(e10, "getMargins", cx), cs(e10, "redraw", cf), cs(e10, "update", cy), cs(e10, "beforeRedraw", cp), i11.callbacks.push(cf), cr(ce, { rangeSelector: ct.rangeSelector }), cr(ce.lang, ct.lang);
        }
      } }, { defaultOptions: cv } = tT, { addEvent: ck, createElement: cM, css: cw, defined: cS, destroyObjectProperties: cA, diffObjects: cT, discardElement: cC, extend: cP, fireEvent: cO, isNumber: cE, isString: cL, merge: cD, objectEach: cB, pick: cI, splat: cz } = ti;
      function cR(t10) {
        let e10 = (e11) => RegExp(`%[[a-zA-Z]*${e11}`).test(t10);
        if (cL(t10) ? -1 !== t10.indexOf("%L") : t10.fractionalSecondDigits) return "text";
        let i10 = cL(t10) ? ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(e10) : t10.dateStyle || t10.day || t10.month || t10.year, s10 = cL(t10) ? ["H", "k", "I", "l", "M", "S"].some(e10) : t10.timeStyle || t10.hour || t10.minute || t10.second;
        return i10 && s10 ? "datetime-local" : i10 ? "date" : s10 ? "time" : "text";
      }
      class cN {
        static compose(t10, e10) {
          cb.compose(t10, e10, cN);
        }
        constructor(t10) {
          this.isDirty = false, this.buttonOptions = cN.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.maxButtonWidth = () => {
            let t11 = 0;
            return this.buttons.forEach((e10) => {
              let i10 = e10.getBBox();
              i10.width > t11 && (t11 = i10.width);
            }), t11;
          }, this.init(t10);
        }
        clickButton(t10, e10) {
          let i10 = this.chart, s10 = this.buttonOptions[t10], o10 = i10.xAxis[0], r10 = i10.scroller && i10.scroller.getUnionExtremes() || o10 || {}, a10 = s10.type, n10 = s10.dataGrouping, h10 = r10.dataMin, l10 = r10.dataMax, d10, c10 = cE(o10 == null ? void 0 : o10.max) ? Math.round(Math.min(o10.max, l10 ?? o10.max)) : void 0, p10, u2 = s10._range, g2, f2, m2, x2 = true;
          if (null !== h10 && null !== l10) {
            if (this.setSelected(t10), n10 && (this.forcedDataGrouping = true, s_.prototype.setDataGrouping.call(o10 || { chart: this.chart }, n10, false), this.frozenStates = s10.preserveDataGrouping), "month" === a10 || "year" === a10) o10 ? (f2 = { range: s10, max: c10, chart: i10, dataMin: h10, dataMax: l10 }, d10 = o10.minFromRange.call(f2), cE(f2.newMax) && (c10 = f2.newMax), x2 = false) : u2 = s10;
            else if (u2) cE(c10) && (c10 = Math.min((d10 = Math.max(c10 - u2, h10)) + u2, l10), x2 = false);
            else if ("ytd" === a10) {
              if (o10) !o10.hasData() || cE(l10) && cE(h10) || (h10 = Number.MAX_VALUE, l10 = -Number.MAX_VALUE, i10.series.forEach((t11) => {
                let e11 = t11.getColumn("x");
                e11.length && (h10 = Math.min(e11[0], h10), l10 = Math.max(e11[e11.length - 1], l10));
              }), e10 = false), cE(l10) && cE(h10) && (d10 = g2 = (m2 = this.getYTDExtremes(l10, h10)).min, c10 = m2.max);
              else {
                this.deferredYTDClick = t10;
                return;
              }
            } else "all" === a10 && o10 && (i10.navigator && i10.navigator.baseSeries[0] && (i10.navigator.baseSeries[0].xAxis.options.range = void 0), d10 = h10, c10 = l10);
            if (x2 && s10._offsetMin && cS(d10) && (d10 += s10._offsetMin), s10._offsetMax && cS(c10) && (c10 += s10._offsetMax), this.dropdown && (this.dropdown.selectedIndex = t10 + 1), o10) cE(d10) && cE(c10) && (o10.setExtremes(d10, c10, cI(e10, true), void 0, { trigger: "rangeSelectorButton", rangeSelectorButton: s10 }), i10.setFixedRange(s10._range));
            else {
              p10 = cz(i10.options.xAxis || {})[0];
              let t11 = ck(i10, "afterCreateAxes", function() {
                let t12 = i10.xAxis[0];
                t12.range = t12.options.range = u2, t12.min = t12.options.min = g2;
              });
              ck(i10, "load", function() {
                let e11 = i10.xAxis[0];
                i10.setFixedRange(s10._range), e11.options.range = p10.range, e11.options.min = p10.min, t11();
              });
            }
            cO(this, "afterBtnClick");
          }
        }
        setSelected(t10) {
          this.selected = this.options.selected = t10;
        }
        init(t10) {
          let e10 = this, i10 = t10.options.rangeSelector, s10 = i10.buttons, o10 = i10.selected, r10 = function() {
            let t11 = e10.minInput, i11 = e10.maxInput;
            t11 && t11.blur && cO(t11, "blur"), i11 && i11.blur && cO(i11, "blur");
          };
          e10.chart = t10, e10.options = i10, e10.buttons = [], e10.buttonOptions = s10, this.eventsToUnbind = [], this.eventsToUnbind.push(ck(t10.container, "mousedown", r10)), this.eventsToUnbind.push(ck(t10, "resize", r10)), s10.forEach(e10.computeButtonRange), void 0 !== o10 && s10[o10] && this.clickButton(o10, false), this.eventsToUnbind.push(ck(t10, "load", function() {
            t10.xAxis && t10.xAxis[0] && ck(t10.xAxis[0], "setExtremes", function(i11) {
              cE(this.max) && cE(this.min) && this.max - this.min !== t10.fixedRange && "rangeSelectorButton" !== i11.trigger && "updatedData" !== i11.trigger && e10.forcedDataGrouping && !e10.frozenStates && this.setDataGrouping(false, false);
            });
          })), this.createElements();
        }
        updateButtonStates() {
          let t10 = this, e10 = this.chart, i10 = this.dropdown, s10 = this.dropdownLabel, o10 = e10.xAxis[0], r10 = Math.round(o10.max - o10.min), a10 = !o10.hasVisibleSeries, n10 = 24 * 36e5, h10 = e10.scroller && e10.scroller.getUnionExtremes() || o10, l10 = h10.dataMin, d10 = h10.dataMax, c10 = t10.getYTDExtremes(d10, l10), p10 = c10.min, u2 = c10.max, g2 = t10.selected, f2 = t10.options.allButtonsEnabled, m2 = Array(t10.buttonOptions.length).fill(0), x2 = cE(g2), y2 = t10.buttons, b2 = false, v2 = null;
          t10.buttonOptions.forEach((e11, i11) => {
            var _a;
            let s11 = e11._range, h11 = e11.type, c11 = e11.count || 1, y3 = e11._offsetMax - e11._offsetMin, k2 = i11 === g2, M2 = s11 > d10 - l10, w2 = s11 < o10.minRange, S2 = false, A2 = s11 === r10;
            if (k2 && M2 && (b2 = true), o10.isOrdinal && ((_a = o10.ordinal) == null ? void 0 : _a.positions) && s11 && r10 < s11) {
              let t11 = o10.ordinal.positions, e12 = d7.Additions.findIndexOf(t11, o10.min, true), i12 = Math.min(d7.Additions.findIndexOf(t11, o10.max, true) + 1, t11.length - 1);
              t11[i12] - t11[e12] > s11 && (A2 = true);
            } else ("month" === h11 || "year" === h11) && r10 + 36e5 >= { month: 28, year: 365 }[h11] * n10 * c11 - y3 && r10 - 36e5 <= { month: 31, year: 366 }[h11] * n10 * c11 + y3 ? A2 = true : "ytd" === h11 ? (A2 = u2 - p10 + y3 === r10, S2 = !k2) : "all" === h11 && (A2 = o10.max - o10.min >= d10 - l10);
            let T2 = !f2 && !(b2 && "all" === h11) && (M2 || w2 || a10), C2 = b2 && "all" === h11 || !S2 && A2 || k2 && t10.frozenStates;
            T2 ? m2[i11] = 3 : C2 && (!x2 || i11 === g2) && (v2 = i11);
          }), null !== v2 ? (m2[v2] = 2, t10.setSelected(v2), this.dropdown && (this.dropdown.selectedIndex = v2 + 1)) : (t10.setSelected(), this.dropdown && (this.dropdown.selectedIndex = -1), s10 && (s10.setState(0), s10.attr({ text: (cv.lang.rangeSelectorZoom || "") + " ▾" })));
          for (let e11 = 0; e11 < m2.length; e11++) {
            let o11 = m2[e11], r11 = y2[e11];
            if (r11.state !== o11 && (r11.setState(o11), i10)) {
              i10.options[e11 + 1].disabled = 3 === o11, 2 === o11 && (s10 && (s10.setState(2), s10.attr({ text: t10.buttonOptions[e11].text + " ▾" })), i10.selectedIndex = e11 + 1);
              let r12 = s10.getBBox();
              cw(i10, { width: `${r12.width}px`, height: `${r12.height}px` });
            }
          }
        }
        computeButtonRange(t10) {
          let e10 = t10.type, i10 = t10.count || 1, s10 = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5 };
          s10[e10] ? t10._range = s10[e10] * i10 : ("month" === e10 || "year" === e10) && (t10._range = 24 * { month: 30, year: 365 }[e10] * 36e5 * i10), t10._offsetMin = cI(t10.offsetMin, 0), t10._offsetMax = cI(t10.offsetMax, 0), t10._range += t10._offsetMax - t10._offsetMin;
        }
        getInputValue(t10) {
          let e10 = "min" === t10 ? this.minInput : this.maxInput, i10 = this.chart.options.rangeSelector, s10 = this.chart.time;
          return e10 ? ("text" === e10.type && i10.inputDateParser || this.defaultInputDateParser)(e10.value, "UTC" === s10.timezone, s10) : 0;
        }
        setInputValue(t10, e10) {
          let i10 = this.options, s10 = this.chart.time, o10 = "min" === t10 ? this.minInput : this.maxInput, r10 = "min" === t10 ? this.minDateBox : this.maxDateBox;
          if (o10) {
            o10.setAttribute("type", cR(i10.inputDateFormat || "%e %b %Y"));
            let t11 = o10.getAttribute("data-hc-time"), a10 = cS(t11) ? Number(t11) : void 0;
            if (cS(e10)) {
              let t12 = a10;
              cS(t12) && o10.setAttribute("data-hc-time-previous", t12), o10.setAttribute("data-hc-time", e10), a10 = e10;
            }
            o10.value = s10.dateFormat(this.inputTypeFormats[o10.type] || i10.inputEditDateFormat, a10), r10 && r10.attr({ text: s10.dateFormat(i10.inputDateFormat, a10) });
          }
        }
        setInputExtremes(t10, e10, i10) {
          let s10 = "min" === t10 ? this.minInput : this.maxInput;
          if (s10) {
            let t11 = this.inputTypeFormats[s10.type], o10 = this.chart.time;
            if (t11) {
              let r10 = o10.dateFormat(t11, e10);
              s10.min !== r10 && (s10.min = r10);
              let a10 = o10.dateFormat(t11, i10);
              s10.max !== a10 && (s10.max = a10);
            }
          }
        }
        showInput(t10) {
          let e10 = "min" === t10 ? this.minDateBox : this.maxDateBox, i10 = "min" === t10 ? this.minInput : this.maxInput;
          if (i10 && e10 && this.inputGroup) {
            let t11 = "text" === i10.type, { translateX: s10 = 0, translateY: o10 = 0 } = this.inputGroup, { x: r10 = 0, width: a10 = 0, height: n10 = 0 } = e10, { inputBoxWidth: h10 } = this.options;
            cw(i10, { width: t11 ? a10 + (h10 ? -2 : 20) + "px" : "auto", height: n10 - 2 + "px", border: "2px solid silver" }), t11 && h10 ? cw(i10, { left: s10 + r10 + "px", top: o10 + "px" }) : cw(i10, { left: Math.min(Math.round(r10 + s10 - (i10.offsetWidth - a10) / 2), this.chart.chartWidth - i10.offsetWidth) + "px", top: o10 - (i10.offsetHeight - n10) / 2 + "px" });
          }
        }
        hideInput(t10) {
          let e10 = "min" === t10 ? this.minInput : this.maxInput;
          e10 && cw(e10, { top: "-9999em", border: 0, width: "1px", height: "1px" });
        }
        defaultInputDateParser(t10, e10, i10) {
          return (i10 == null ? void 0 : i10.parse(t10)) || 0;
        }
        drawInput(t10) {
          let { chart: e10, div: i10, inputGroup: s10 } = this, o10 = this, r10 = e10.renderer.style || {}, a10 = e10.renderer, n10 = e10.options.rangeSelector, h10 = cv.lang, l10 = "min" === t10;
          function d10(t11) {
            var _a;
            let { maxInput: i11, minInput: s11 } = o10, r11 = e10.xAxis[0], a11 = ((_a = e10.scroller) == null ? void 0 : _a.getUnionExtremes()) || r11, n11 = a11.dataMin, h11 = a11.dataMax, d11 = e10.xAxis[0].getExtremes()[t11], c11 = o10.getInputValue(t11);
            cE(c11) && c11 !== d11 && (l10 && i11 && cE(n11) ? c11 > Number(i11.getAttribute("data-hc-time")) ? c11 = void 0 : c11 < n11 && (c11 = n11) : s11 && cE(h11) && (c11 < Number(s11.getAttribute("data-hc-time")) ? c11 = void 0 : c11 > h11 && (c11 = h11)), void 0 !== c11 && r11.setExtremes(l10 ? c11 : r11.min, l10 ? r11.max : c11, void 0, void 0, { trigger: "rangeSelectorInput" }));
          }
          let c10 = h10[l10 ? "rangeSelectorFrom" : "rangeSelectorTo"] || "", p10 = a10.label(c10, 0).addClass("highcharts-range-label").attr({ padding: c10 ? 2 : 0, height: c10 ? n10.inputBoxHeight : 0 }).add(s10), u2 = a10.label("", 0).addClass("highcharts-range-input").attr({ padding: 2, width: n10.inputBoxWidth, height: n10.inputBoxHeight, "text-align": "center" }).on("click", function() {
            o10.showInput(t10), o10[t10 + "Input"].focus();
          });
          e10.styledMode || u2.attr({ stroke: n10.inputBoxBorderColor, "stroke-width": 1 }), u2.add(s10);
          let g2 = cM("input", { name: t10, className: "highcharts-range-selector" }, void 0, i10);
          g2.setAttribute("type", cR(n10.inputDateFormat || "%e %b %Y")), e10.styledMode || (p10.css(cD(r10, n10.labelStyle)), u2.css(cD({ color: "#333333" }, r10, n10.inputStyle)), cw(g2, cP({ position: "absolute", border: 0, boxShadow: "0 0 15px rgba(0,0,0,0.3)", width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: r10.fontSize, fontFamily: r10.fontFamily, top: "-9999em" }, n10.inputStyle))), g2.onfocus = () => {
            o10.showInput(t10);
          }, g2.onblur = () => {
            g2 === L.doc.activeElement && d10(t10), o10.hideInput(t10), o10.setInputValue(t10), g2.blur();
          };
          let f2 = false;
          return g2.onchange = () => {
            f2 || (d10(t10), o10.hideInput(t10), g2.blur());
          }, g2.onkeypress = (e11) => {
            13 === e11.keyCode && d10(t10);
          }, g2.onkeydown = (e11) => {
            f2 = true, ("ArrowUp" === e11.key || "ArrowDown" === e11.key || "Tab" === e11.key) && d10(t10);
          }, g2.onkeyup = () => {
            f2 = false;
          }, { dateBox: u2, input: g2, label: p10 };
        }
        getPosition() {
          let t10 = this.chart, e10 = t10.options.rangeSelector, i10 = "top" === e10.verticalAlign ? t10.plotTop - t10.axisOffset[0] : 0;
          return { buttonTop: i10 + e10.buttonPosition.y, inputTop: i10 + e10.inputPosition.y - 10 };
        }
        getYTDExtremes(t10, e10) {
          let i10 = this.chart.time, s10 = i10.toParts(t10)[0];
          return { max: t10, min: Math.max(e10, i10.makeTime(s10, 0)) };
        }
        createElements() {
          var _a;
          let t10 = this.chart, e10 = t10.renderer, i10 = t10.container, s10 = t10.options, o10 = s10.rangeSelector, r10 = o10.inputEnabled, a10 = cI((_a = s10.chart.style) == null ? void 0 : _a.zIndex, 0) + 1;
          false !== o10.enabled && (this.group = e10.g("range-selector-group").attr({ zIndex: 7 }).add(), this.div = cM("div", void 0, { position: "relative", height: 0, zIndex: a10 }), this.buttonOptions.length && this.renderButtons(), i10.parentNode && i10.parentNode.insertBefore(this.div, i10), r10 && this.createInputs());
        }
        createInputs() {
          this.inputGroup = this.chart.renderer.g("input-group").add(this.group);
          let t10 = this.drawInput("min");
          this.minDateBox = t10.dateBox, this.minLabel = t10.label, this.minInput = t10.input;
          let e10 = this.drawInput("max");
          this.maxDateBox = e10.dateBox, this.maxLabel = e10.label, this.maxInput = e10.input;
        }
        render(t10, e10) {
          var _a, _b;
          if (false === this.options.enabled) return;
          let i10 = this.chart, s10 = i10.options.rangeSelector;
          if (s10.inputEnabled) {
            this.inputGroup || this.createInputs(), this.setInputValue("min", t10), this.setInputValue("max", e10), this.chart.styledMode || ((_a = this.maxLabel) == null ? void 0 : _a.css(s10.labelStyle), (_b = this.minLabel) == null ? void 0 : _b.css(s10.labelStyle));
            let o10 = i10.scroller && i10.scroller.getUnionExtremes() || i10.xAxis[0] || {};
            if (cS(o10.dataMin) && cS(o10.dataMax)) {
              let t11 = i10.xAxis[0].minRange || 0;
              this.setInputExtremes("min", o10.dataMin, Math.min(o10.dataMax, this.getInputValue("max")) - t11), this.setInputExtremes("max", Math.max(o10.dataMin, this.getInputValue("min")) + t11, o10.dataMax);
            }
            if (this.inputGroup) {
              let t11 = 0;
              [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach((e11) => {
                if (e11) {
                  let { width: i11 } = e11.getBBox();
                  i11 && (e11.attr({ x: t11 }), t11 += i11 + s10.inputSpacing);
                }
              });
            }
          } else this.inputGroup && (this.inputGroup.destroy(), delete this.inputGroup);
          !this.chart.styledMode && this.zoomText && this.zoomText.css(s10.labelStyle), this.alignElements(), this.updateButtonStates();
        }
        renderButtons() {
          var _a;
          var t10;
          let { chart: e10, options: i10 } = this, s10 = cv.lang, o10 = e10.renderer, r10 = cD(i10.buttonTheme), a10 = r10 && r10.states;
          delete r10.width, delete r10.states, this.buttonGroup = o10.g("range-selector-buttons").add(this.group);
          let n10 = this.dropdown = cM("select", void 0, { position: "absolute", padding: 0, border: 0, cursor: "pointer", opacity: 1e-4 }, this.div), h10 = (_a = e10.userOptions.rangeSelector) == null ? void 0 : _a.buttonTheme;
          this.dropdownLabel = o10.button("", 0, 0, () => {
          }, cD(r10, { "stroke-width": cI(r10["stroke-width"], 0), width: "auto", paddingLeft: cI(i10.buttonTheme.paddingLeft, h10 == null ? void 0 : h10.padding, 8), paddingRight: cI(i10.buttonTheme.paddingRight, h10 == null ? void 0 : h10.padding, 8) }), a10 && a10.hover, a10 && a10.select, a10 && a10.disabled).hide().add(this.group), ck(n10, "touchstart", () => {
            n10.style.fontSize = "16px";
          });
          let l10 = L.isMS ? "mouseover" : "mouseenter", d10 = L.isMS ? "mouseout" : "mouseleave";
          ck(n10, l10, () => {
            cO(this.dropdownLabel.element, l10);
          }), ck(n10, d10, () => {
            cO(this.dropdownLabel.element, d10);
          }), ck(n10, "change", () => {
            cO(this.buttons[n10.selectedIndex - 1].element, "click");
          }), this.zoomText = o10.label(s10.rangeSelectorZoom || "", 0).attr({ padding: i10.buttonTheme.padding, height: i10.buttonTheme.height, paddingLeft: 0, paddingRight: 0 }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(i10.labelStyle), (t10 = i10.buttonTheme)["stroke-width"] ?? (t10["stroke-width"] = 0)), cM("option", { textContent: this.zoomText.textStr, disabled: true }, void 0, n10), this.createButtons();
        }
        createButtons() {
          let { options: t10 } = this, e10 = cD(t10.buttonTheme), i10 = e10 && e10.states, s10 = e10.width || 28;
          delete e10.width, delete e10.states, this.buttonOptions.forEach((t11, e11) => {
            this.createButton(t11, e11, s10, i10);
          });
        }
        createButton(t10, e10, i10, s10) {
          let { dropdown: o10, buttons: r10, chart: a10, options: n10 } = this, h10 = a10.renderer, l10 = cD(n10.buttonTheme);
          o10 == null ? void 0 : o10.add(cM("option", { textContent: t10.title || t10.text }), e10 + 2), r10[e10] = h10.button(t10.text, 0, 0, (i11) => {
            let s11;
            let o11 = t10.events && t10.events.click;
            o11 && (s11 = o11.call(t10, i11)), false !== s11 && this.clickButton(e10), this.isActive = true;
          }, l10, s10 && s10.hover, s10 && s10.select, s10 && s10.disabled).attr({ "text-align": "center", width: i10 }).add(this.buttonGroup), t10.title && r10[e10].attr("title", t10.title);
        }
        alignElements() {
          var _a;
          let { buttonGroup: t10, buttons: e10, chart: i10, group: s10, inputGroup: o10, options: r10, zoomText: a10 } = this, n10 = i10.options, h10 = n10.exporting && false !== n10.exporting.enabled && n10.navigation && n10.navigation.buttonOptions, { buttonPosition: l10, inputPosition: d10, verticalAlign: c10 } = r10, p10 = (t11, e11, s11) => h10 && this.titleCollision(i10) && "top" === c10 && s11 && e11.y - t11.getBBox().height - 12 < (h10.y || 0) + (h10.height || 0) + i10.spacing[0] ? -40 : 0, u2 = i10.plotLeft;
          if (s10 && l10 && d10) {
            let n11 = l10.x - i10.spacing[3];
            if (t10) {
              if (this.positionButtons(), !this.initialButtonGroupWidth) {
                let t11 = 0;
                a10 && (t11 += a10.getBBox().width + 5), e10.forEach((i11, s11) => {
                  t11 += i11.width || 0, s11 !== e10.length - 1 && (t11 += r10.buttonSpacing);
                }), this.initialButtonGroupWidth = t11;
              }
              u2 -= i10.spacing[3];
              let o11 = p10(t10, l10, "right" === l10.align || "right" === d10.align);
              this.alignButtonGroup(o11), ((_a = this.buttonGroup) == null ? void 0 : _a.translateY) && this.dropdownLabel.attr({ y: this.buttonGroup.translateY }), s10.placed = t10.placed = i10.hasLoaded;
            }
            let h11 = 0;
            r10.inputEnabled && o10 && (h11 = p10(o10, d10, "right" === l10.align || "right" === d10.align), "left" === d10.align ? n11 = u2 : "right" === d10.align && (n11 = -Math.max(i10.axisOffset[1], -h11)), o10.align({ y: d10.y, width: o10.getBBox().width, align: d10.align, x: d10.x + n11 - 2 }, true, i10.spacingBox), o10.placed = i10.hasLoaded), this.handleCollision(h11), s10.align({ verticalAlign: c10 }, true, i10.spacingBox);
            let g2 = s10.alignAttr.translateY, f2 = s10.getBBox().height + 20, m2 = 0;
            if ("bottom" === c10) {
              let t11 = i10.legend && i10.legend.options;
              m2 = g2 - (f2 = f2 + (t11 && "bottom" === t11.verticalAlign && t11.enabled && !t11.floating ? i10.legend.legendHeight + cI(t11.margin, 10) : 0) - 20) - (r10.floating ? 0 : r10.y) - (i10.titleOffset ? i10.titleOffset[2] : 0) - 10;
            }
            "top" === c10 ? (r10.floating && (m2 = 0), i10.titleOffset && i10.titleOffset[0] && (m2 = i10.titleOffset[0]), m2 += i10.margin[0] - i10.spacing[0] || 0) : "middle" === c10 && (d10.y === l10.y ? m2 = g2 : (d10.y || l10.y) && (d10.y < 0 || l10.y < 0 ? m2 -= Math.min(d10.y, l10.y) : m2 = g2 - f2)), s10.translate(r10.x, r10.y + Math.floor(m2));
            let { minInput: x2, maxInput: y2, dropdown: b2 } = this;
            r10.inputEnabled && x2 && y2 && (x2.style.marginTop = s10.translateY + "px", y2.style.marginTop = s10.translateY + "px"), b2 && (b2.style.marginTop = s10.translateY + "px");
          }
        }
        redrawElements() {
          var _a, _b, _c, _d, _e;
          let t10 = this.chart, { inputBoxHeight: e10, inputBoxBorderColor: i10 } = this.options;
          if ((_a = this.maxDateBox) == null ? void 0 : _a.attr({ height: e10 }), (_b = this.minDateBox) == null ? void 0 : _b.attr({ height: e10 }), t10.styledMode || ((_c = this.maxDateBox) == null ? void 0 : _c.attr({ stroke: i10 }), (_d = this.minDateBox) == null ? void 0 : _d.attr({ stroke: i10 })), this.isDirty) {
            this.isDirty = false, this.isCollapsed = void 0;
            let t11 = this.options.buttons ?? [], e11 = Math.min(t11.length, this.buttonOptions.length), { dropdown: i11, options: s10 } = this, o10 = cD(s10.buttonTheme), r10 = o10 && o10.states, a10 = o10.width || 28;
            if (t11.length < this.buttonOptions.length) for (let e12 = this.buttonOptions.length - 1; e12 >= t11.length; e12--) {
              let t12 = this.buttons.pop();
              t12 == null ? void 0 : t12.destroy(), (_e = this.dropdown) == null ? void 0 : _e.options.remove(e12 + 1);
            }
            for (let s11 = e11 - 1; s11 >= 0; s11--) if (0 !== Object.keys(cT(t11[s11], this.buttonOptions[s11])).length) {
              let e12 = t11[s11];
              this.buttons[s11].destroy(), i11 == null ? void 0 : i11.options.remove(s11 + 1), this.createButton(e12, s11, a10, r10), this.computeButtonRange(e12);
            }
            if (t11.length > this.buttonOptions.length) for (let e12 = this.buttonOptions.length; e12 < t11.length; e12++) this.createButton(t11[e12], e12, a10, r10), this.computeButtonRange(t11[e12]);
            this.buttonOptions = this.options.buttons ?? [], cS(this.options.selected) && this.buttons.length && this.clickButton(this.options.selected, false);
          }
        }
        alignButtonGroup(t10, e10) {
          let { chart: i10, options: s10, buttonGroup: o10, dropdown: r10, dropdownLabel: a10 } = this, { buttonPosition: n10 } = s10, h10 = i10.plotLeft - i10.spacing[3], l10 = n10.x - i10.spacing[3], d10 = i10.plotLeft;
          "right" === n10.align ? (l10 += t10 - h10, this.hasVisibleDropdown && (d10 = i10.chartWidth + t10 - this.maxButtonWidth() - 20)) : "center" === n10.align && (l10 -= h10 / 2, this.hasVisibleDropdown && (d10 = i10.chartWidth / 2 - this.maxButtonWidth())), r10 && cw(r10, { left: d10 + "px", top: (o10 == null ? void 0 : o10.translateY) + "px" }), a10 == null ? void 0 : a10.attr({ x: d10 }), o10 && o10.align({ y: n10.y, width: cI(e10, this.initialButtonGroupWidth), align: n10.align, x: l10 }, true, i10.spacingBox);
        }
        positionButtons() {
          let { buttons: t10, chart: e10, options: i10, zoomText: s10 } = this, o10 = e10.hasLoaded ? "animate" : "attr", { buttonPosition: r10 } = i10, a10 = e10.plotLeft, n10 = a10;
          s10 && "hidden" !== s10.visibility && (s10[o10]({ x: cI(a10 + r10.x, a10) }), n10 += r10.x + s10.getBBox().width + 5);
          for (let e11 = 0, s11 = this.buttonOptions.length; e11 < s11; ++e11) "hidden" !== t10[e11].visibility ? (t10[e11][o10]({ x: n10 }), n10 += (t10[e11].width || 0) + i10.buttonSpacing) : t10[e11][o10]({ x: a10 });
        }
        handleCollision(t10) {
          let { chart: e10, buttonGroup: i10, inputGroup: s10, initialButtonGroupWidth: o10 } = this, { buttonPosition: r10, dropdown: a10, inputPosition: n10 } = this.options, h10 = () => {
            s10 && i10 && s10.attr({ translateX: s10.alignAttr.translateX + (e10.axisOffset[1] >= -t10 ? 0 : -t10), translateY: s10.alignAttr.translateY + i10.getBBox().height + 10 });
          };
          s10 && i10 ? n10.align === r10.align ? (h10(), o10 > e10.plotWidth + t10 - 20 ? this.collapseButtons() : this.expandButtons()) : o10 - t10 + s10.getBBox().width > e10.plotWidth ? "responsive" === a10 ? this.collapseButtons() : h10() : this.expandButtons() : i10 && "responsive" === a10 && (o10 > e10.plotWidth ? this.collapseButtons() : this.expandButtons()), i10 && ("always" === a10 && this.collapseButtons(), "never" === a10 && this.expandButtons()), this.alignButtonGroup(t10);
        }
        collapseButtons() {
          let { buttons: t10, zoomText: e10 } = this;
          true !== this.isCollapsed && (this.isCollapsed = true, e10.hide(), t10.forEach((t11) => void t11.hide()), this.showDropdown());
        }
        expandButtons() {
          let { buttons: t10, zoomText: e10 } = this;
          false !== this.isCollapsed && (this.isCollapsed = false, this.hideDropdown(), e10.show(), t10.forEach((t11) => void t11.show()), this.positionButtons());
        }
        showDropdown() {
          let { buttonGroup: t10, dropdownLabel: e10, dropdown: i10 } = this;
          t10 && i10 && (e10.show(), cw(i10, { visibility: "inherit" }), this.hasVisibleDropdown = true);
        }
        hideDropdown() {
          let { dropdown: t10 } = this;
          t10 && (this.dropdownLabel.hide(), cw(t10, { visibility: "hidden", width: "1px", height: "1px" }), this.hasVisibleDropdown = false);
        }
        getHeight() {
          let t10 = this.options, e10 = this.group, i10 = t10.inputPosition, s10 = t10.buttonPosition, o10 = t10.y, r10 = s10.y, a10 = i10.y, n10 = 0;
          if (t10.height) return t10.height;
          this.alignElements(), n10 = e10 ? e10.getBBox(true).height + 13 + o10 : 0;
          let h10 = Math.min(a10, r10);
          return (a10 < 0 && r10 < 0 || a10 > 0 && r10 > 0) && (n10 += Math.abs(h10)), n10;
        }
        titleCollision(t10) {
          return !(t10.options.title.text || t10.options.subtitle.text);
        }
        update(t10, e10 = true) {
          let i10 = this.chart;
          if (cD(true, this.options, t10), this.options.selected && this.options.selected >= this.options.buttons.length && (this.options.selected = void 0, i10.options.rangeSelector.selected = void 0), cS(t10.enabled)) return this.destroy(), this.init(i10);
          this.isDirty = !!t10.buttons, e10 && this.render();
        }
        destroy() {
          let t10 = this, e10 = t10.minInput, i10 = t10.maxInput;
          t10.eventsToUnbind && (t10.eventsToUnbind.forEach((t11) => t11()), t10.eventsToUnbind = void 0), cA(t10.buttons), e10 && (e10.onfocus = e10.onblur = e10.onchange = null), i10 && (i10.onfocus = i10.onblur = i10.onchange = null), cB(t10, function(e11, i11) {
            e11 && "chart" !== i11 && (e11 instanceof e0 ? e11.destroy() : e11 instanceof window.HTMLElement && cC(e11), delete t10[i11]), e11 !== cN.prototype[i11] && (t10[i11] = null);
          }, this), this.buttons = [];
        }
      }
      cP(cN.prototype, { inputTypeFormats: { "datetime-local": "%Y-%m-%dT%H:%M:%S", date: "%Y-%m-%d", time: "%H:%M:%S" } });
      let { format: cW } = eg, { getOptions: cG } = tT, { setFixedRange: cX } = da, { addEvent: cH, clamp: cF, crisp: cY, defined: cj, extend: cU, find: cV, isNumber: c_, isString: c$, merge: cZ, pick: cq, splat: cK } = ti;
      function cJ(t10, e10, i10) {
        var _a, _b;
        return "xAxis" === t10 ? { minPadding: 0, maxPadding: 0, overscroll: 0, ordinal: true } : "yAxis" === t10 ? { labels: { y: -2 }, opposite: i10.opposite ?? e10.opposite ?? true, showLastLabel: !!(e10.categories || "category" === e10.type), title: { text: ((_a = i10.title) == null ? void 0 : _a.text) !== "Values" ? (_b = i10.title) == null ? void 0 : _b.text : null } } : {};
      }
      function cQ(t10, e10) {
        if ("xAxis" === t10) {
          let t11 = cq(e10.navigator && e10.navigator.enabled, de.enabled, true), i10 = { type: "datetime", categories: void 0 };
          return t11 && (i10.startOnTick = false, i10.endOnTick = false), i10;
        }
        return {};
      }
      class c0 extends aQ {
        init(t10, e10) {
          let i10 = cG(), s10 = t10.xAxis, o10 = t10.yAxis, r10 = cq(t10.navigator && t10.navigator.enabled, de.enabled, true);
          t10.xAxis = t10.yAxis = void 0;
          let a10 = cZ({ chart: { panning: { enabled: true, type: "x" }, zooming: { pinchType: "x", mouseWheel: { type: "x" } } }, navigator: { enabled: r10 }, scrollbar: { enabled: cq(dM.enabled, true) }, rangeSelector: { enabled: cq(ct.rangeSelector.enabled, true) }, title: { text: null }, tooltip: { split: cq(i10.tooltip && i10.tooltip.split, true), crosshairs: true }, legend: { enabled: false } }, t10, { isStock: true });
          t10.xAxis = s10, t10.yAxis = o10, a10.xAxis = cK(t10.xAxis || {}).map((e11) => cZ(cJ("xAxis", e11, i10.xAxis), e11, cQ("xAxis", t10))), a10.yAxis = cK(t10.yAxis || {}).map((t11) => cZ(cJ("yAxis", t11, i10.yAxis), t11)), super.init(a10, e10);
        }
        createAxis(t10, e10) {
          return e10.axis = cZ(cJ(t10, e10.axis, cG()[t10]), e10.axis, cQ(t10, this.userOptions)), super.createAxis(t10, e10);
        }
      }
      cH(aQ, "update", function(t10) {
        let e10 = t10.options;
        "scrollbar" in e10 && this.navigator && (cZ(true, this.options.scrollbar, e10.scrollbar), this.navigator.update({ enabled: !!this.navigator.navigatorEnabled }), delete e10.scrollbar);
      }), function(t10) {
        function e10(t11) {
          var _a, _b, _c;
          if (!(((_b = (_a = this.crosshair) == null ? void 0 : _a.label) == null ? void 0 : _b.enabled) && this.cross && c_(this.min) && c_(this.max))) return;
          let e11 = this.chart, i11 = this.logarithmic, s11 = this.crosshair.label, o11 = this.horiz, r11 = this.opposite, a11 = this.left, n11 = this.top, h11 = this.width, l10 = "inside" === this.options.tickPosition, d10 = false !== this.crosshair.snap, c10 = t11.e || ((_c = this.cross) == null ? void 0 : _c.e), p10 = t11.point, u2 = this.crossLabel, g2, f2, m2 = s11.format, x2 = "", y2, b2 = 0, v2 = this.min, k2 = this.max;
          i11 && (v2 = i11.lin2log(this.min), k2 = i11.lin2log(this.max));
          let M2 = o11 ? "center" : r11 ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
          u2 || (u2 = this.crossLabel = e11.renderer.label("", 0, void 0, s11.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (p10 && p10.series ? p10.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({ align: s11.align || M2, padding: cq(s11.padding, 8), r: cq(s11.borderRadius, 3), zIndex: 2 }).add(this.labelGroup), e11.styledMode || u2.attr({ fill: s11.backgroundColor || p10 && p10.series && p10.series.color || "#666666", stroke: s11.borderColor || "", "stroke-width": s11.borderWidth || 0 }).css(cU({ color: "#ffffff", fontWeight: "normal", fontSize: "0.7em", textAlign: "center" }, s11.style || {}))), o11 ? (g2 = d10 ? (p10.plotX || 0) + a11 : c10.chartX, f2 = n11 + (r11 ? 0 : this.height)) : (g2 = a11 + this.offset + (r11 ? h11 : 0), f2 = d10 ? (p10.plotY || 0) + n11 : c10.chartY), m2 || s11.formatter || (this.dateTime && (x2 = "%b %d, %Y"), m2 = "{value" + (x2 ? ":" + x2 : "") + "}");
          let w2 = d10 ? this.isXAxis ? p10.x : p10.y : this.toValue(o11 ? c10.chartX : c10.chartY), S2 = p10 && p10.series ? p10.series.isPointInside(p10) : c_(w2) && w2 > v2 && w2 < k2, A2 = "";
          m2 ? A2 = cW(m2, { value: w2 }, e11) : s11.formatter && c_(w2) && (A2 = s11.formatter.call(this, w2)), u2.attr({ text: A2, x: g2, y: f2, visibility: S2 ? "inherit" : "hidden" });
          let T2 = u2.getBBox();
          !c_(u2.x) || o11 || r11 || (g2 = u2.x - T2.width / 2), c_(u2.y) && (o11 ? (l10 && !r11 || !l10 && r11) && (f2 = u2.y - T2.height) : f2 = u2.y - T2.height / 2), y2 = o11 ? { left: a11, right: a11 + this.width } : { left: "left" === this.labelAlign ? a11 : 0, right: "right" === this.labelAlign ? a11 + this.width : e11.chartWidth };
          let C2 = u2.translateX || 0;
          C2 < y2.left && (b2 = y2.left - C2), C2 + T2.width >= y2.right && (b2 = -(C2 + T2.width - y2.right)), u2.attr({ x: Math.max(0, g2 + b2), y: Math.max(0, f2), anchorX: o11 ? g2 : this.opposite ? 0 : e11.chartWidth, anchorY: o11 ? this.opposite ? e11.chartHeight : 0 : f2 + T2.height / 2 });
        }
        function i10() {
          this.crossLabel && (this.crossLabel = this.crossLabel.hide());
        }
        function s10(t11) {
          let e11 = this.chart, i11 = this.options, s11 = e11._labelPanes = e11._labelPanes || {}, o11 = i11.labels;
          if (e11.options.isStock && "yAxis" === this.coll) {
            let e12 = i11.top + "," + i11.height;
            !s11[e12] && o11.enabled && (15 === o11.distance && 1 === this.side && (o11.distance = 0), void 0 === o11.align && (o11.align = "right"), s11[e12] = this, t11.align = "right", t11.preventDefault());
          }
        }
        function o10() {
          let t11 = this.chart, e11 = this.options && this.options.top + "," + this.options.height;
          e11 && t11._labelPanes && t11._labelPanes[e11] === this && delete t11._labelPanes[e11];
        }
        function r10(t11) {
          let e11 = this, i11 = e11.isLinked && !e11.series && e11.linkedParent ? e11.linkedParent.series : e11.series, s11 = e11.chart, o11 = s11.renderer, r11 = e11.left, a11 = e11.top, n11 = [], h11 = t11.translatedValue, l10 = t11.value, d10 = t11.force, c10, p10, u2, g2, f2 = [], m2, x2;
          if (s11.options.isStock && false !== t11.acrossPanes && "xAxis" === e11.coll || "yAxis" === e11.coll) {
            for (let o12 of (t11.preventDefault(), f2 = ((t12) => {
              let o13 = "xAxis" === t12 ? "yAxis" : "xAxis", r12 = e11.options[o13];
              return c_(r12) ? [s11[o13][r12]] : c$(r12) ? [s11.get(r12)] : i11.map((t13) => t13[o13]);
            })(e11.coll), e11.isXAxis ? s11.yAxis : s11.xAxis)) if (!o12.options.isInternal) {
              let t12 = o12.isXAxis ? "yAxis" : "xAxis";
              e11 === (cj(o12.options[t12]) ? s11[t12][o12.options[t12]] : s11[t12][0]) && f2.push(o12);
            }
            for (let t12 of (m2 = f2.length ? [] : [e11.isXAxis ? s11.yAxis[0] : s11.xAxis[0]], f2)) -1 !== m2.indexOf(t12) || cV(m2, (e12) => e12.pos === t12.pos && e12.len === t12.len) || m2.push(t12);
            if (c_(x2 = cq(h11, e11.translate(l10 || 0, void 0, void 0, t11.old)))) {
              if (e11.horiz) for (let t12 of m2) {
                let i12;
                g2 = (p10 = t12.pos) + t12.len, c10 = u2 = Math.round(x2 + e11.transB), "pass" !== d10 && (c10 < r11 || c10 > r11 + e11.width) && (d10 ? c10 = u2 = cF(c10, r11, r11 + e11.width) : i12 = true), i12 || n11.push(["M", c10, p10], ["L", u2, g2]);
              }
              else for (let t12 of m2) {
                let i12;
                u2 = (c10 = t12.pos) + t12.len, p10 = g2 = Math.round(a11 + e11.height - x2), "pass" !== d10 && (p10 < a11 || p10 > a11 + e11.height) && (d10 ? p10 = g2 = cF(p10, a11, a11 + e11.height) : i12 = true), i12 || n11.push(["M", c10, p10], ["L", u2, g2]);
              }
            }
            t11.path = n11.length > 0 ? o11.crispPolyLine(n11, t11.lineWidth || 1) : void 0;
          }
        }
        function a10(t11) {
          if (this.chart.options.isStock) {
            let e11;
            this.is("column") || this.is("columnrange") ? e11 = { borderWidth: 0, shadow: false } : this.is("scatter") || this.is("sma") || (e11 = { marker: { enabled: false, radius: 2 } }), e11 && (t11.plotOptions[this.type] = cZ(t11.plotOptions[this.type], e11));
          }
        }
        function n10() {
          let t11 = this.chart, e11 = this.options.dataGrouping;
          return false !== this.allowDG && e11 && cq(e11.enabled, t11.options.isStock);
        }
        function h10(t11, e11) {
          for (let i11 = 0; i11 < t11.length; i11 += 2) {
            let s11 = t11[i11], o11 = t11[i11 + 1];
            cj(s11[1]) && s11[1] === o11[1] && (s11[1] = o11[1] = cY(s11[1], e11)), cj(s11[2]) && s11[2] === o11[2] && (s11[2] = o11[2] = cY(s11[2], e11));
          }
          return t11;
        }
        t10.compose = function(t11, l10, d10, c10) {
          let p10 = d10.prototype;
          p10.forceCropping || (cH(l10, "afterDrawCrosshair", e10), cH(l10, "afterHideCrosshair", i10), cH(l10, "autoLabelAlign", s10), cH(l10, "destroy", o10), cH(l10, "getPlotLinePath", r10), t11.prototype.setFixedRange = cX, p10.forceCropping = n10, cH(d10, "setOptions", a10), c10.prototype.crispPolyLine = h10);
        }, t10.stockChart = function(e11, i11, s11) {
          return new t10(e11, i11, s11);
        };
      }(c0 || (c0 = {}));
      let c1 = c0, { column: { prototype: { pointClass: c2 } } } = rv.seriesTypes, { column: c3 } = rv.seriesTypes, { crisp: c5, extend: c6, merge: c9 } = ti;
      class c4 extends c3 {
        extendStem(t10, e10, i10) {
          let s10 = t10[0], o10 = t10[1];
          "number" == typeof s10[2] && (s10[2] = Math.max(i10 + e10, s10[2])), "number" == typeof o10[2] && (o10[2] = Math.min(i10 - e10, o10[2]));
        }
        getPointPath(t10, e10) {
          let i10 = e10.strokeWidth(), s10 = t10.series, o10 = c5(t10.plotX || 0, i10), r10 = Math.round(t10.shapeArgs.width / 2), a10 = [["M", o10, Math.round(t10.yBottom)], ["L", o10, Math.round(t10.plotHigh)]];
          if (null !== t10.close) {
            let e11 = c5(t10.plotClose, i10);
            a10.push(["M", o10, e11], ["L", o10 + r10, e11]), s10.extendStem(a10, i10 / 2, e11);
          }
          return a10;
        }
        drawSinglePoint(t10) {
          let e10 = t10.series, i10 = e10.chart, s10, o10 = t10.graphic;
          void 0 !== t10.plotY && (o10 || (t10.graphic = o10 = i10.renderer.path().add(e10.group)), i10.styledMode || o10.attr(e10.pointAttribs(t10, t10.selected && "select")), s10 = e10.getPointPath(t10, o10), o10[o10 ? "animate" : "attr"]({ d: s10 }).addClass(t10.getClassName(), true));
        }
        drawPoints() {
          this.points.forEach(this.drawSinglePoint);
        }
        init() {
          super.init.apply(this, arguments), this.options.stacking = void 0;
        }
        pointAttribs(t10, e10) {
          let i10 = super.pointAttribs.call(this, t10, e10);
          return delete i10.fill, i10;
        }
        toYData(t10) {
          return [t10.high, t10.low, t10.close];
        }
        translate() {
          let t10 = this, e10 = t10.yAxis, i10 = this.pointArrayMap && this.pointArrayMap.slice() || [], s10 = i10.map((t11) => `plot${t11.charAt(0).toUpperCase() + t11.slice(1)}`);
          s10.push("yBottom"), i10.push("low"), super.translate.apply(t10), t10.points.forEach(function(o10) {
            i10.forEach(function(i11, r10) {
              let a10 = o10[i11];
              null !== a10 && (t10.dataModify && (a10 = t10.dataModify.modifyValue(a10)), o10[s10[r10]] = e10.toPixels(a10, true));
            }), o10.tooltipPos[1] = o10.plotHigh + e10.pos - t10.chart.plotTop;
          });
        }
      }
      c4.defaultOptions = c9(c3.defaultOptions, { lineWidth: 1, tooltip: { pointFormat: '<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>' }, threshold: null, states: { hover: { lineWidth: 3 } }, stickyTracking: true }), c6(c4.prototype, { pointClass: class extends c2 {
      }, animate: null, directTouch: false, keysAffectYAxis: ["low", "high"], pointArrayMap: ["high", "low", "close"], pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, pointValKey: "close" }), rv.registerSeriesType("hlc", c4);
      let { seriesTypes: { hlc: c8 } } = rv;
      class c7 extends c8.prototype.pointClass {
        getClassName() {
          return super.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
        }
        resolveUpColor() {
          this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);
        }
        resolveColor() {
          super.resolveColor(), this.series.is("heikinashi") || this.resolveUpColor();
        }
        getZone() {
          let t10 = super.getZone();
          return this.resolveUpColor(), t10;
        }
        applyOptions() {
          return super.applyOptions.apply(this, arguments), this.resolveColor && this.resolveColor(), this;
        }
      }
      let { composed: pt } = L, { hlc: pe } = rv.seriesTypes, { addEvent: pi, crisp: ps, extend: po, merge: pr, pushUnique: pa } = ti;
      function pn(t10) {
        let e10 = t10.options, i10 = e10.dataGrouping;
        i10 && e10.useOhlcData && "highcharts-navigator-series" !== e10.id && (i10.approximation = "ohlc");
      }
      function ph(t10) {
        let e10 = t10.options;
        e10.useOhlcData && "highcharts-navigator-series" !== e10.id && po(this, { pointValKey: pl.prototype.pointValKey, pointArrayMap: pl.prototype.pointArrayMap, toYData: pl.prototype.toYData });
      }
      class pl extends pe {
        static compose(t10, ...e10) {
          pa(pt, "OHLCSeries") && (pi(t10, "afterSetOptions", pn), pi(t10, "init", ph));
        }
        getPointPath(t10, e10) {
          let i10 = super.getPointPath(t10, e10), s10 = e10.strokeWidth(), o10 = ps(t10.plotX || 0, s10), r10 = Math.round(t10.shapeArgs.width / 2);
          if (null !== t10.open) {
            let e11 = ps(t10.plotOpen, s10);
            i10.push(["M", o10, e11], ["L", o10 - r10, e11]), super.extendStem(i10, s10 / 2, e11);
          }
          return i10;
        }
        pointAttribs(t10, e10) {
          let i10 = super.pointAttribs.call(this, t10, e10), s10 = this.options;
          return delete i10.fill, !t10.options.color && s10.upColor && t10.open < t10.close && (i10.stroke = s10.upColor), i10;
        }
        toYData(t10) {
          return [t10.open, t10.high, t10.low, t10.close];
        }
      }
      pl.defaultOptions = pr(pe.defaultOptions, { tooltip: { pointFormat: '<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>' } }), po(pl.prototype, { pointClass: c7, pointArrayMap: ["open", "high", "low", "close"] }), rv.registerSeriesType("ohlc", pl);
      let { column: pd, ohlc: pc } = rv.seriesTypes, { crisp: pp, merge: pu } = ti;
      class pg extends pc {
        pointAttribs(t10, e10) {
          let i10 = pd.prototype.pointAttribs.call(this, t10, e10), s10 = this.options, o10 = t10.open < t10.close, r10 = s10.lineColor || this.color, a10 = t10.color || this.color;
          if (i10["stroke-width"] = s10.lineWidth, i10.fill = t10.options.color || o10 && s10.upColor || a10, i10.stroke = t10.options.lineColor || o10 && s10.upLineColor || r10, e10) {
            let t11 = s10.states[e10];
            i10.fill = t11.color || i10.fill, i10.stroke = t11.lineColor || i10.stroke, i10["stroke-width"] = t11.lineWidth || i10["stroke-width"];
          }
          return i10;
        }
        drawPoints() {
          let t10 = this.points, e10 = this.chart, i10 = this.yAxis.reversed;
          for (let s10 of t10) {
            let t11 = s10.graphic, o10, r10, a10, n10, h10, l10, d10, c10, p10, u2 = !t11;
            if (void 0 !== s10.plotY) {
              t11 || (s10.graphic = t11 = e10.renderer.path().add(this.group)), this.chart.styledMode || t11.attr(this.pointAttribs(s10, s10.selected && "select")).shadow(this.options.shadow);
              let g2 = t11.strokeWidth();
              d10 = pp(s10.plotX || 0, g2), a10 = Math.min(o10 = s10.plotOpen, r10 = s10.plotClose), n10 = Math.max(o10, r10), p10 = Math.round(s10.shapeArgs.width / 2), h10 = i10 ? n10 !== s10.yBottom : Math.round(a10) !== Math.round(s10.plotHigh || 0), l10 = i10 ? Math.round(a10) !== Math.round(s10.plotHigh || 0) : n10 !== s10.yBottom, a10 = pp(a10, g2), n10 = pp(n10, g2), (c10 = []).push(["M", d10 - p10, n10], ["L", d10 - p10, a10], ["L", d10 + p10, a10], ["L", d10 + p10, n10], ["Z"], ["M", d10, a10], ["L", d10, h10 ? Math.round(i10 ? s10.yBottom : s10.plotHigh) : a10], ["M", d10, n10], ["L", d10, l10 ? Math.round(i10 ? s10.plotHigh : s10.yBottom) : n10]), t11[u2 ? "attr" : "animate"]({ d: c10 }).addClass(s10.getClassName(), true);
            }
          }
        }
      }
      pg.defaultOptions = pu(pc.defaultOptions, { tooltip: pc.defaultOptions.tooltip }, { states: { hover: { lineWidth: 2 } }, threshold: null, lineColor: "#000000", lineWidth: 1, upColor: "#ffffff", stickyTracking: true }), rv.registerSeriesType("candlestick", pg);
      let { column: { prototype: { pointClass: pf } } } = rv.seriesTypes, { isNumber: pm } = ti, px = class extends pf {
        constructor() {
          super(...arguments), this.ttBelow = false;
        }
        isValid() {
          return pm(this.y) || void 0 === this.y;
        }
        hasNewShapeType() {
          let t10 = this.options.shape || this.series.options.shape;
          return this.graphic && t10 && t10 !== this.graphic.symbolKey;
        }
      };
      !function(t10) {
        let e10 = [];
        function i10(t11, e11, i11, s11, o10) {
          let r10 = o10 && o10.anchorX || t11, a10 = o10 && o10.anchorY || e11, n10 = this.circle(r10 - 1, a10 - 1, 2, 2);
          return n10.push(["M", r10, a10], ["L", t11, e11 + s11], ["L", t11, e11], ["L", t11 + i11, e11], ["L", t11 + i11, e11 + s11], ["L", t11, e11 + s11], ["Z"]), n10;
        }
        function s10(t11, e11) {
          t11[e11 + "pin"] = function(i11, s11, o10, r10, a10) {
            let n10;
            let h10 = a10 && a10.anchorX, l10 = a10 && a10.anchorY;
            if ("circle" === e11 && r10 > o10 && (i11 -= Math.round((r10 - o10) / 2), o10 = r10), n10 = t11[e11](i11, s11, o10, r10, a10), h10 && l10) {
              let a11 = h10;
              if ("circle" === e11) a11 = i11 + o10 / 2;
              else {
                let t12 = n10[0], e12 = n10[1];
                "M" === t12[0] && "L" === e12[0] && (a11 = (t12[1] + e12[1]) / 2);
              }
              let d10 = s11 > l10 ? s11 : s11 + r10;
              n10.push(["M", a11, d10], ["L", h10, l10]), n10 = n10.concat(t11.circle(h10 - 1, l10 - 1, 2, 2));
            }
            return n10;
          };
        }
        t10.compose = function(t11) {
          if (-1 === e10.indexOf(t11)) {
            e10.push(t11);
            let o11 = t11.prototype.symbols;
            o11.flag = i10, s10(o11, "circle"), s10(o11, "square");
          }
          let o10 = ef.getRendererType();
          e10.indexOf(o10) && e10.push(o10);
        };
      }(T || (T = {}));
      let py = T, { composed: pb } = L, { prototype: pv } = ht, { prototype: pk } = rQ, { defined: pM, pushUnique: pw, stableSort: pS } = ti;
      !function(t10) {
        function e10(t11) {
          return pk.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this, t11);
        }
        function i10() {
          var _a, _b;
          pv.translate.apply(this);
          let t11 = this, e11 = t11.options, i11 = t11.chart, s10 = t11.points, o10 = e11.onSeries, r10 = o10 && i11.get(o10), a10 = r10 && r10.options.step, n10 = r10 && r10.points, h10 = i11.inverted, l10 = t11.xAxis, d10 = t11.yAxis, c10 = s10.length - 1, p10, u2, g2 = e11.onKey || "y", f2 = n10 && n10.length, m2 = 0, x2, y2, b2, v2, k2;
          if (r10 && r10.visible && f2) {
            for (m2 = (r10.pointXOffset || 0) + (r10.barW || 0) / 2, v2 = r10.currentDataGrouping, y2 = n10[f2 - 1].x + (v2 ? v2.totalRange : 0), pS(s10, (t12, e12) => t12.x - e12.x), g2 = "plot" + g2[0].toUpperCase() + g2.substr(1); f2-- && s10[c10]; ) if (x2 = n10[f2], (p10 = s10[c10]).y = x2.y, x2.x <= p10.x && void 0 !== x2[g2]) {
              if (p10.x <= y2 && (p10.plotY = x2[g2], x2.x < p10.x && !a10 && (b2 = n10[f2 + 1]) && void 0 !== b2[g2])) {
                if (pM(p10.plotX) && r10.is("spline")) {
                  let t12 = [x2.plotX || 0, x2.plotY || 0], e12 = [b2.plotX || 0, b2.plotY || 0], i12 = ((_a = x2.controlPoints) == null ? void 0 : _a.high) || t12, s11 = ((_b = b2.controlPoints) == null ? void 0 : _b.low) || e12, o11 = (o12, r12) => Math.pow(1 - o12, 3) * t12[r12] + 3 * (1 - o12) * (1 - o12) * o12 * i12[r12] + 3 * (1 - o12) * o12 * o12 * s11[r12] + o12 * o12 * o12 * e12[r12], r11 = 0, a11 = 1, n11;
                  for (let t13 = 0; t13 < 100; t13++) {
                    let t14 = (r11 + a11) / 2, e13 = o11(t14, 0);
                    if (null === e13) break;
                    if (0.25 > Math.abs(e13 - p10.plotX)) {
                      n11 = t14;
                      break;
                    }
                    e13 < p10.plotX ? r11 = t14 : a11 = t14;
                  }
                  pM(n11) && (p10.plotY = o11(n11, 1), p10.y = d10.toValue(p10.plotY, true));
                } else k2 = (p10.x - x2.x) / (b2.x - x2.x), p10.plotY += k2 * (b2[g2] - x2[g2]), p10.y += k2 * (b2.y - x2.y);
              }
              if (c10--, f2++, c10 < 0) break;
            }
          }
          s10.forEach((e12, i12) => {
            let o11;
            e12.plotX += m2, (void 0 === e12.plotY || h10) && (e12.plotX >= 0 && e12.plotX <= l10.len ? h10 ? (e12.plotY = l10.translate(e12.x, 0, 1, 0, 1), e12.plotX = pM(e12.y) ? d10.translate(e12.y, 0, 0, 0, 1) : 0) : e12.plotY = (l10.opposite ? 0 : t11.yAxis.len) + l10.offset : e12.shapeArgs = {}), (u2 = s10[i12 - 1]) && u2.plotX === e12.plotX && (void 0 === u2.stackIndex && (u2.stackIndex = 0), o11 = u2.stackIndex + 1), e12.stackIndex = o11;
          }), this.onSeries = r10;
        }
        t10.compose = function(t11) {
          if (pw(pb, "OnSeries")) {
            let s10 = t11.prototype;
            s10.getPlotBox = e10, s10.translate = i10;
          }
          return t11;
        }, t10.getPlotBox = e10, t10.translate = i10;
      }(C || (C = {}));
      let pA = C, { noop: pT } = L, { distribute: pC } = ev, { series: pP, seriesTypes: { column: pO } } = rv, { addEvent: pE, defined: pL, extend: pD, isNumber: pB, merge: pI, objectEach: pz, wrap: pR } = ti;
      class pN extends pO {
        animate(t10) {
          t10 && this.setClip();
        }
        drawPoints() {
          let t10, e10, i10, s10, o10, r10, a10, n10, h10, l10, d10;
          let c10 = this.points, p10 = this.chart, u2 = p10.renderer, g2 = p10.inverted, f2 = this.options, m2 = f2.y, x2 = this.yAxis, y2 = {}, b2 = [], v2 = pB(f2.borderRadius) ? f2.borderRadius : 0;
          for (s10 = c10.length; s10--; ) o10 = c10[s10], l10 = (g2 ? o10.plotY : o10.plotX) > this.xAxis.len, t10 = o10.plotX, a10 = o10.stackIndex, i10 = o10.options.shape || f2.shape, void 0 !== (e10 = o10.plotY) && (e10 = o10.plotY + m2 - (void 0 !== a10 && a10 * f2.stackDistance)), o10.anchorX = a10 ? void 0 : o10.plotX, n10 = a10 ? void 0 : o10.plotY, d10 = "flag" !== i10, r10 = o10.graphic, void 0 !== e10 && t10 >= 0 && !l10 ? (r10 && o10.hasNewShapeType() && (r10 = r10.destroy()), r10 || (r10 = o10.graphic = u2.label("", 0, void 0, i10, void 0, void 0, f2.useHTML).addClass("highcharts-point").add(this.markerGroup), o10.graphic.div && (o10.graphic.div.point = o10), r10.isNew = true), r10.attr({ align: d10 ? "center" : "left", width: f2.width, height: f2.height, "text-align": f2.textAlign, r: v2 }), p10.styledMode || r10.attr(this.pointAttribs(o10)).css(pI(f2.style, o10.style)).shadow(f2.shadow), t10 > 0 && (t10 -= r10.strokeWidth() % 2), h10 = { y: e10, anchorY: n10 }, f2.allowOverlapX && (h10.x = t10, h10.anchorX = o10.anchorX), r10.attr({ text: o10.options.title ?? f2.title ?? "A" })[r10.isNew ? "attr" : "animate"](h10), f2.allowOverlapX || (y2[o10.plotX] ? y2[o10.plotX].size = Math.max(y2[o10.plotX].size, r10.width || 0) : y2[o10.plotX] = { align: d10 ? 0.5 : 0, size: r10.width || 0, target: t10, anchorX: t10 }), o10.tooltipPos = [t10, e10 + x2.pos - p10.plotTop]) : r10 && (o10.graphic = r10.destroy());
          if (!f2.allowOverlapX) {
            let t11 = 100;
            for (let e11 of (pz(y2, function(e12) {
              e12.plotX = e12.anchorX, b2.push(e12), t11 = Math.max(e12.size, t11);
            }), pC(b2, g2 ? x2.len : this.xAxis.len, t11), c10)) {
              let t12 = e11.plotX, i11 = e11.graphic, s11 = i11 && y2[t12];
              s11 && i11 && (pL(s11.pos) ? i11[i11.isNew ? "attr" : "animate"]({ x: s11.pos + (s11.align || 0) * s11.size, anchorX: e11.anchorX }).show().isNew = false : i11.hide().isNew = true);
            }
          }
          f2.useHTML && this.markerGroup && pR(this.markerGroup, "on", function(t11) {
            return e0.prototype.on.apply(t11.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
          });
        }
        drawTracker() {
          let t10 = this.points;
          for (let e10 of (super.drawTracker(), t10)) {
            let i10 = e10.graphic;
            i10 && (e10.unbindMouseOver && e10.unbindMouseOver(), e10.unbindMouseOver = pE(i10.element, "mouseover", function() {
              for (let s10 of (e10.stackIndex > 0 && !e10.raised && (e10._y = i10.y, i10.attr({ y: e10._y - 8 }), e10.raised = true), t10)) s10 !== e10 && s10.raised && s10.graphic && (s10.graphic.attr({ y: s10._y }), s10.raised = false);
            }));
          }
        }
        pointAttribs(t10, e10) {
          let i10 = this.options, s10 = t10 && t10.color || this.color, o10 = i10.lineColor, r10 = t10 && t10.lineWidth, a10 = t10 && t10.fillColor || i10.fillColor;
          return e10 && (a10 = i10.states[e10].fillColor, o10 = i10.states[e10].lineColor, r10 = i10.states[e10].lineWidth), { fill: a10 || s10, stroke: o10 || s10, "stroke-width": r10 || i10.lineWidth || 0 };
        }
        setClip() {
          pP.prototype.setClip.apply(this, arguments), false !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
        }
      }
      pN.compose = py.compose, pN.defaultOptions = pI(pO.defaultOptions, { borderRadius: 0, pointRange: 0, allowOverlapX: false, shape: "flag", stackDistance: 12, textAlign: "center", tooltip: { pointFormat: "{point.text}" }, threshold: null, y: -30, fillColor: "#ffffff", lineWidth: 1, states: { hover: { lineColor: "#000000", fillColor: "#ccd3ff" } }, style: { fontSize: "0.7em", fontWeight: "bold" } }), pA.compose(pN), pD(pN.prototype, { allowDG: false, forceCrop: true, invertible: false, noSharedTooltip: true, pointClass: px, sorted: false, takeOrdinalPosition: false, trackerGroups: ["markerGroup"], buildKDTree: pT, init: pP.prototype.init }), rv.registerSeriesType("flags", pN);
      let { addEvent: pW, find: pG, fireEvent: pX, isArray: pH, isNumber: pF, pick: pY } = ti;
      !function(t10) {
        function e10() {
          void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, false);
        }
        function i10() {
          var _a;
          ((_a = this.brokenAxis) == null ? void 0 : _a.hasBreaks) && (this.options.ordinal = false);
        }
        function s10() {
          let t11 = this.brokenAxis;
          if (t11 == null ? void 0 : t11.hasBreaks) {
            let e11 = this.tickPositions, i11 = this.tickPositions.info, s11 = [];
            for (let i12 = 0; i12 < e11.length; i12++) t11.isInAnyBreak(e11[i12]) || s11.push(e11[i12]);
            this.tickPositions = s11, this.tickPositions.info = i11;
          }
        }
        function o10() {
          this.brokenAxis || (this.brokenAxis = new l10(this));
        }
        function r10() {
          var _a, _b;
          let { isDirty: t11, options: { connectNulls: e11 }, points: i11, xAxis: s11, yAxis: o11 } = this;
          if (t11) {
            let t12 = i11.length;
            for (; t12--; ) {
              let r11 = i11[t12], a11 = !(null === r11.y && false === e11) && (((_a = s11 == null ? void 0 : s11.brokenAxis) == null ? void 0 : _a.isInAnyBreak(r11.x, true)) || ((_b = o11 == null ? void 0 : o11.brokenAxis) == null ? void 0 : _b.isInAnyBreak(r11.y, true)));
              r11.visible = !a11 && false !== r11.options.visible;
            }
          }
        }
        function a10() {
          this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, pY(this.pointArrayMap, ["y"]));
        }
        function n10(t11, e11) {
          var _a;
          let i11, s11, o11;
          let r11 = this, a11 = r11.points;
          if ((_a = t11 == null ? void 0 : t11.brokenAxis) == null ? void 0 : _a.hasBreaks) {
            let n11 = t11.brokenAxis;
            e11.forEach(function(e12) {
              var _a2, _b;
              i11 = (n11 == null ? void 0 : n11.breakArray) || [], s11 = t11.isXAxis ? t11.min : pY(r11.options.threshold, t11.min);
              let h11 = (_b = (_a2 = t11 == null ? void 0 : t11.options) == null ? void 0 : _a2.breaks) == null ? void 0 : _b.filter(function(t12) {
                let e13 = true;
                for (let s12 = 0; s12 < i11.length; s12++) {
                  let o12 = i11[s12];
                  if (o12.from === t12.from && o12.to === t12.to) {
                    e13 = false;
                    break;
                  }
                }
                return e13;
              });
              a11.forEach(function(r12) {
                o11 = pY(r12["stack" + e12.toUpperCase()], r12[e12]), i11.forEach(function(e13) {
                  if (pF(s11) && pF(o11)) {
                    let i12 = "";
                    s11 < e13.from && o11 > e13.to || s11 > e13.from && o11 < e13.from ? i12 = "pointBreak" : (s11 < e13.from && o11 > e13.from && o11 < e13.to || s11 > e13.from && o11 > e13.to && o11 < e13.from) && (i12 = "pointInBreak"), i12 && pX(t11, i12, { point: r12, brk: e13 });
                  }
                }), h11 == null ? void 0 : h11.forEach(function(e13) {
                  pX(t11, "pointOutsideOfBreak", { point: r12, brk: e13 });
                });
              });
            });
          }
        }
        function h10() {
          let t11 = this.currentDataGrouping, e11 = t11 == null ? void 0 : t11.gapSize, i11 = this.points.slice(), s11 = this.yAxis, o11 = this.options.gapSize, r11 = i11.length - 1;
          if (o11 && r11 > 0) {
            let t12, a11;
            for ("value" !== this.options.gapUnit && (o11 *= this.basePointRange), e11 && e11 > o11 && e11 >= this.basePointRange && (o11 = e11); r11--; ) if (a11 && false !== a11.visible || (a11 = i11[r11 + 1]), t12 = i11[r11], false !== a11.visible && false !== t12.visible) {
              if (a11.x - t12.x > o11) {
                let e12 = (t12.x + a11.x) / 2;
                i11.splice(r11 + 1, 0, { isNull: true, x: e12 }), s11.stacking && this.options.stacking && ((s11.stacking.stacks[this.stackKey][e12] = new nl(s11, s11.options.stackLabels, false, e12, this.stack)).total = 0);
              }
              a11 = t12;
            }
          }
          return this.getGraphPath(i11);
        }
        t10.compose = function(t11, l11) {
          if (!t11.keepProps.includes("brokenAxis")) {
            t11.keepProps.push("brokenAxis"), pW(t11, "init", o10), pW(t11, "afterInit", e10), pW(t11, "afterSetTickPositions", s10), pW(t11, "afterSetOptions", i10);
            let d10 = l11.prototype;
            d10.drawBreaks = n10, d10.gappedPath = h10, pW(l11, "afterGeneratePoints", r10), pW(l11, "afterRender", a10);
          }
          return t11;
        };
        class l10 {
          static isInBreak(t11, e11) {
            let i11 = t11.repeat || 1 / 0, s11 = t11.from, o11 = t11.to - t11.from, r11 = e11 >= s11 ? (e11 - s11) % i11 : i11 - (s11 - e11) % i11;
            return t11.inclusive ? r11 <= o11 : r11 < o11 && 0 !== r11;
          }
          static lin2Val(t11) {
            let e11 = this.brokenAxis, i11 = e11 && e11.breakArray;
            if (!i11 || !pF(t11)) return t11;
            let s11 = t11, o11, r11;
            for (r11 = 0; r11 < i11.length && !((o11 = i11[r11]).from >= s11); r11++) o11.to < s11 ? s11 += o11.len : l10.isInBreak(o11, s11) && (s11 += o11.len);
            return s11;
          }
          static val2Lin(t11) {
            let e11 = this.brokenAxis, i11 = e11 && e11.breakArray;
            if (!i11 || !pF(t11)) return t11;
            let s11 = t11, o11, r11;
            for (r11 = 0; r11 < i11.length; r11++) if ((o11 = i11[r11]).to <= t11) s11 -= o11.len;
            else if (o11.from >= t11) break;
            else if (l10.isInBreak(o11, t11)) {
              s11 -= t11 - o11.from;
              break;
            }
            return s11;
          }
          constructor(t11) {
            this.hasBreaks = false, this.axis = t11;
          }
          findBreakAt(t11, e11) {
            return pG(e11, function(e12) {
              return e12.from < t11 && t11 < e12.to;
            });
          }
          isInAnyBreak(t11, e11) {
            let i11 = this.axis, s11 = i11.options.breaks || [], o11 = s11.length, r11, a11, n11;
            if (o11 && pF(t11)) {
              for (; o11--; ) l10.isInBreak(s11[o11], t11) && (r11 = true, a11 || (a11 = pY(s11[o11].showPoints, !i11.isXAxis)));
              n11 = r11 && e11 ? r11 && !a11 : r11;
            }
            return n11;
          }
          setBreaks(t11, e11) {
            let i11 = this, s11 = i11.axis, o11 = s11.chart.time, r11 = pH(t11) && !!t11.length && !!Object.keys(t11[0]).length;
            s11.isDirty = i11.hasBreaks !== r11, i11.hasBreaks = r11, t11 == null ? void 0 : t11.forEach((t12) => {
              t12.from = o11.parse(t12.from) || 0, t12.to = o11.parse(t12.to) || 0;
            }), t11 !== s11.options.breaks && (s11.options.breaks = s11.userOptions.breaks = t11), s11.forceRedraw = true, s11.series.forEach(function(t12) {
              t12.isDirty = true;
            }), r11 || s11.val2lin !== l10.val2Lin || (delete s11.val2lin, delete s11.lin2val), r11 && (s11.userOptions.ordinal = false, s11.lin2val = l10.lin2Val, s11.val2lin = l10.val2Lin, s11.setExtremes = function(t12, e12, o12, r12, a11) {
              if (i11.hasBreaks) {
                let s12;
                let o13 = this.options.breaks || [];
                for (; s12 = i11.findBreakAt(t12, o13); ) t12 = s12.to;
                for (; s12 = i11.findBreakAt(e12, o13); ) e12 = s12.from;
                e12 < t12 && (e12 = t12);
              }
              s11.constructor.prototype.setExtremes.call(this, t12, e12, o12, r12, a11);
            }, s11.setAxisTranslation = function() {
              if (s11.constructor.prototype.setAxisTranslation.call(this), i11.unitLength = void 0, i11.hasBreaks) {
                let t12 = s11.options.breaks || [], e12 = [], o12 = [], r12 = pY(s11.pointRangePadding, 0), a11 = 0, n11, h11, d10 = s11.userMin || s11.min, c10 = s11.userMax || s11.max, p10, u2;
                t12.forEach(function(t13) {
                  h11 = t13.repeat || 1 / 0, pF(d10) && pF(c10) && (l10.isInBreak(t13, d10) && (d10 += t13.to % h11 - d10 % h11), l10.isInBreak(t13, c10) && (c10 -= c10 % h11 - t13.from % h11));
                }), t12.forEach(function(t13) {
                  if (p10 = t13.from, h11 = t13.repeat || 1 / 0, pF(d10) && pF(c10)) {
                    for (; p10 - h11 > d10; ) p10 -= h11;
                    for (; p10 < d10; ) p10 += h11;
                    for (u2 = p10; u2 < c10; u2 += h11) e12.push({ value: u2, move: "in" }), e12.push({ value: u2 + t13.to - t13.from, move: "out", size: t13.breakSize });
                  }
                }), e12.sort(function(t13, e13) {
                  return t13.value === e13.value ? ("in" === t13.move ? 0 : 1) - ("in" === e13.move ? 0 : 1) : t13.value - e13.value;
                }), n11 = 0, p10 = d10, e12.forEach(function(t13) {
                  1 === (n11 += "in" === t13.move ? 1 : -1) && "in" === t13.move && (p10 = t13.value), 0 === n11 && pF(p10) && (o12.push({ from: p10, to: t13.value, len: t13.value - p10 - (t13.size || 0) }), a11 += t13.value - p10 - (t13.size || 0));
                }), i11.breakArray = o12, pF(d10) && pF(c10) && pF(s11.min) && (i11.unitLength = c10 - d10 - a11 + r12, pX(s11, "afterBreaks"), s11.staticScale ? s11.transA = s11.staticScale : i11.unitLength && (s11.transA *= (c10 - s11.min + r12) / i11.unitLength), r12 && (s11.minPixelPadding = s11.transA * (s11.minPointOffset || 0)), s11.min = d10, s11.max = c10);
              }
            }), pY(e11, true) && s11.chart.redraw();
          }
        }
        t10.Additions = l10;
      }(P || (P = {}));
      let pj = P;
      L.BrokenAxis = L.BrokenAxis || pj, L.BrokenAxis.compose(L.Axis, L.Series);
      let pU = {}, { arrayMax: pV, arrayMin: p_, correctFloat: p$, extend: pZ, isNumber: pq } = ti;
      function pK(t10) {
        let e10 = t10.length, i10 = pJ(t10);
        return pq(i10) && e10 && (i10 = p$(i10 / e10)), i10;
      }
      function pJ(t10) {
        let e10 = t10.length, i10;
        if (!e10 && t10.hasNulls) i10 = null;
        else if (e10) for (i10 = 0; e10--; ) i10 += t10[e10];
        return i10;
      }
      let pQ = { average: pK, averages: function() {
        let t10 = [];
        return [].forEach.call(arguments, function(e10) {
          t10.push(pK(e10));
        }), void 0 === t10[0] ? void 0 : t10;
      }, close: function(t10) {
        return t10.length ? t10[t10.length - 1] : t10.hasNulls ? null : void 0;
      }, high: function(t10) {
        return t10.length ? pV(t10) : t10.hasNulls ? null : void 0;
      }, hlc: function(t10, e10, i10) {
        if (t10 = pU.high(t10), e10 = pU.low(e10), i10 = pU.close(i10), pq(t10) || pq(e10) || pq(i10)) return [t10, e10, i10];
      }, low: function(t10) {
        return t10.length ? p_(t10) : t10.hasNulls ? null : void 0;
      }, ohlc: function(t10, e10, i10, s10) {
        if (t10 = pU.open(t10), e10 = pU.high(e10), i10 = pU.low(i10), s10 = pU.close(s10), pq(t10) || pq(e10) || pq(i10) || pq(s10)) return [t10, e10, i10, s10];
      }, open: function(t10) {
        return t10.length ? t10[0] : t10.hasNulls ? null : void 0;
      }, range: function(t10, e10) {
        return (t10 = pU.low(t10), e10 = pU.high(e10), pq(t10) || pq(e10)) ? [t10, e10] : null === t10 && null === e10 ? null : void 0;
      }, sum: pJ };
      pZ(pU, pQ);
      let p0 = { common: { groupPixelWidth: 2, dateTimeLabelFormats: { millisecond: ["%[AebHMSL]", "%[AebHMSL]", "-%[HMSL]"], second: ["%[AebHMS]", "%[AebHMS]", "-%[HMS]"], minute: ["%[AebHM]", "%[AebHM]", "-%[HM]"], hour: ["%[AebHM]", "%[AebHM]", "-%[HM]"], day: ["%[AebY]", "%[Aeb]", "-%[AebY]"], week: ["week from %[AebY]", "%[Aeb]", "-%[AebY]"], month: ["%[BY]", "%[B]", "-%[BY]"], year: ["%Y", "%Y", "-%Y"] } }, seriesSpecific: { line: {}, spline: {}, area: {}, areaspline: {}, arearange: {}, column: { groupPixelWidth: 10 }, columnrange: { groupPixelWidth: 10 }, candlestick: { groupPixelWidth: 10 }, ohlc: { groupPixelWidth: 5 }, hlc: { groupPixelWidth: 5 }, heikinashi: { groupPixelWidth: 10 } }, units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]] }, { addEvent: p1, extend: p2, merge: p3, pick: p5 } = ti;
      function p6(t10) {
        let e10 = this, i10 = e10.series;
        i10.forEach(function(t11) {
          t11.groupPixelWidth = void 0;
        }), i10.forEach(function(i11) {
          i11.groupPixelWidth = e10.getGroupPixelWidth && e10.getGroupPixelWidth(), i11.groupPixelWidth && (i11.hasProcessed = true), i11.applyGrouping(!!t10.hasExtremesChanged);
        });
      }
      function p9() {
        let t10 = this.series, e10 = t10.length, i10 = 0, s10 = false, o10, r10;
        for (; e10--; ) (r10 = t10[e10].options.dataGrouping) && (i10 = Math.max(i10, p5(r10.groupPixelWidth, p0.common.groupPixelWidth)), o10 = (t10[e10].dataTable.modified || t10[e10].dataTable).rowCount, (t10[e10].groupPixelWidth || o10 > this.chart.plotSizeX / i10 || o10 && r10.forced) && (s10 = true));
        return s10 ? i10 : 0;
      }
      function p4() {
        this.series.forEach(function(t10) {
          t10.hasProcessed = false;
        });
      }
      function p8(t10, e10) {
        let i10;
        if (e10 = p5(e10, true), t10 || (t10 = { forced: false, units: null }), this instanceof o) for (i10 = this.series.length; i10--; ) this.series[i10].update({ dataGrouping: t10 }, false);
        else this.chart.options.series.forEach(function(e11) {
          e11.dataGrouping = "boolean" == typeof t10 ? t10 : p3(t10, e11.dataGrouping);
        });
        this.ordinal && (this.ordinal.slope = void 0), e10 && this.chart.redraw();
      }
      let p7 = { compose: function(t10) {
        o = t10;
        let e10 = t10.prototype;
        e10.applyGrouping || (p1(t10, "afterSetScale", p4), p1(t10, "postProcessData", p6), p2(e10, { applyGrouping: p6, getGroupPixelWidth: p9, setDataGrouping: p8 }));
      } }, { series: { prototype: ut } } = rv, { addEvent: ue, defined: ui, error: us, extend: uo, isNumber: ur, merge: ua, pick: un, splat: uh } = ti, ul = ut.generatePoints;
      function ud(t10) {
        var e10;
        let i10, s10;
        let o10 = this.chart, r10 = this.options.dataGrouping, a10 = false !== this.allowDG && r10 && un(r10.enabled, o10.options.isStock), n10 = this.reserveSpace(), h10 = this.currentDataGrouping, l10, d10, c10 = false;
        a10 && !this.requireSorting && (this.requireSorting = c10 = true);
        let p10 = false == !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !t10) || !a10;
        if (c10 && (this.requireSorting = false), p10) return;
        this.destroyGroupedData();
        let u2 = r10.groupAll ? this.dataTable : this.dataTable.modified || this.dataTable, g2 = this.getColumn("x", !r10.groupAll), f2 = o10.plotSizeX, m2 = this.xAxis, x2 = m2.getExtremes(), y2 = m2.options.ordinal, b2 = this.groupPixelWidth;
        if (b2 && g2 && u2.rowCount && f2 && ur(x2.min)) {
          s10 = true, this.isDirty = true, this.points = null;
          let t11 = x2.min, a11 = x2.max, h11 = y2 && m2.ordinal && m2.ordinal.getGroupIntervalFactor(t11, a11, this) || 1, c11 = b2 * (a11 - t11) / f2 * h11, p11 = m2.getTimeTicks(sJ.Additions.prototype.normalizeTimeTickInterval(c11, r10.units || p0.units), Math.min(t11, g2[0]), Math.max(a11, g2[g2.length - 1]), m2.options.startOfWeek, g2, this.closestPointRange), v2 = ut.groupData.apply(this, [u2, p11, r10.approximation]), k2 = v2.modified, M2 = k2.getColumn("x", true), w2 = 0;
          for ((r10 == null ? void 0 : r10.smoothed) && k2.rowCount && (r10.firstAnchor = "firstPoint", r10.anchor = "middle", r10.lastAnchor = "lastPoint", us(32, false, o10, { "dataGrouping.smoothed": "use dataGrouping.anchor" })), i10 = 1; i10 < p11.length; i10++) p11.info.segmentStarts && -1 !== p11.info.segmentStarts.indexOf(i10) || (w2 = Math.max(p11[i10] - p11[i10 - 1], w2));
          (l10 = p11.info).gapSize = w2, this.closestPointRange = p11.info.totalRange, this.groupMap = v2.groupMap, this.currentDataGrouping = l10, !function(t12, e11, i11) {
            let s11 = t12.options.dataGrouping, o11 = t12.currentDataGrouping && t12.currentDataGrouping.gapSize, r11 = t12.getColumn("x");
            if (!(s11 && r11.length && o11 && t12.groupMap)) return;
            let a12 = e11.length - 1, n11 = s11.anchor, h12 = s11.firstAnchor, l11 = s11.lastAnchor, d11 = e11.length - 1, c12 = 0;
            if (h12 && r11[0] >= e11[0]) {
              let i12;
              c12++;
              let s12 = t12.groupMap[0].start, a13 = t12.groupMap[0].length;
              ur(s12) && ur(a13) && (i12 = s12 + (a13 - 1)), e11[0] = { start: e11[0], middle: e11[0] + 0.5 * o11, end: e11[0] + o11, firstPoint: r11[0], lastPoint: i12 && r11[i12] }[h12];
            }
            if (a12 > 0 && l11 && o11 && e11[a12] >= i11 - o11) {
              d11--;
              let i12 = t12.groupMap[t12.groupMap.length - 1].start;
              e11[a12] = { start: e11[a12], middle: e11[a12] + 0.5 * o11, end: e11[a12] + o11, firstPoint: i12 && r11[i12], lastPoint: r11[r11.length - 1] }[l11];
            }
            if (n11 && "start" !== n11) {
              let t13 = o11 * { middle: 0.5, end: 1 }[n11];
              for (; d11 >= c12; ) e11[d11] += t13, d11--;
            }
          }(this, M2 || [], a11), n10 && M2 && (ui((e10 = M2)[0]) && ur(m2.min) && ur(m2.dataMin) && e10[0] < m2.min && ((!ui(m2.options.min) && m2.min <= m2.dataMin || m2.min === m2.dataMin) && (m2.min = Math.min(e10[0], m2.min)), m2.dataMin = Math.min(e10[0], m2.dataMin)), ui(e10[e10.length - 1]) && ur(m2.max) && ur(m2.dataMax) && e10[e10.length - 1] > m2.max && ((!ui(m2.options.max) && ur(m2.dataMax) && m2.max >= m2.dataMax || m2.max === m2.dataMax) && (m2.max = Math.max(e10[e10.length - 1], m2.max)), m2.dataMax = Math.max(e10[e10.length - 1], m2.dataMax))), r10.groupAll && (this.allGroupedTable = k2, M2 = (k2 = (d10 = this.cropData(k2, m2.min || 0, m2.max || 0)).modified).getColumn("x"), this.cropStart = d10.start), this.dataTable.modified = k2;
        } else this.groupMap = void 0, this.currentDataGrouping = void 0;
        this.hasGroupedData = s10, this.preventGraphAnimation = (h10 && h10.totalRange) !== (l10 && l10.totalRange);
      }
      function uc() {
        this.groupedData && (this.groupedData.forEach(function(t10, e10) {
          t10 && (this.groupedData[e10] = t10.destroy ? t10.destroy() : null);
        }, this), this.groupedData.length = 0, delete this.allGroupedTable);
      }
      function up() {
        ul.apply(this), this.destroyGroupedData(), this.groupedData = this.hasGroupedData ? this.points : null;
      }
      function uu() {
        return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") || this.options.cumulative ? "sum" : "average";
      }
      function ug(t10, e10, i10) {
        let s10 = t10.getColumn("x", true) || [], o10 = t10.getColumn("y", true), r10 = this, a10 = r10.data, n10 = r10.options && r10.options.data, h10 = [], l10 = new rc(), d10 = [], c10 = t10.rowCount, p10 = !!o10, u2 = [], g2 = r10.pointArrayMap, f2 = g2 && g2.length, m2 = ["x"].concat(g2 || ["y"]), x2 = (g2 || ["y"]).map(() => []), y2 = this.options.dataGrouping && this.options.dataGrouping.groupAll, b2, v2, k2, M2 = 0, w2 = 0, S2 = "function" == typeof i10 ? i10 : i10 && pU[i10] ? pU[i10] : pU[r10.getDGApproximation && r10.getDGApproximation() || "average"];
        if (f2) {
          let t11 = g2.length;
          for (; t11--; ) u2.push([]);
        } else u2.push([]);
        let A2 = f2 || 1;
        for (let t11 = 0; t11 <= c10; t11++) if (!(s10[t11] < e10[0])) {
          for (; void 0 !== e10[M2 + 1] && s10[t11] >= e10[M2 + 1] || t11 === c10; ) {
            if (b2 = e10[M2], r10.dataGroupInfo = { start: y2 ? w2 : r10.cropStart + w2, length: u2[0].length, groupStart: b2 }, k2 = S2.apply(r10, u2), r10.pointClass && !ui(r10.dataGroupInfo.options) && (r10.dataGroupInfo.options = ua(r10.pointClass.prototype.optionsToObject.call({ series: r10 }, r10.options.data[r10.cropStart + w2])), m2.forEach(function(t12) {
              delete r10.dataGroupInfo.options[t12];
            })), void 0 !== k2) {
              h10.push(b2);
              let t12 = uh(k2);
              for (let e11 = 0; e11 < t12.length; e11++) x2[e11].push(t12[e11]);
              d10.push(r10.dataGroupInfo);
            }
            w2 = t11;
            for (let t12 = 0; t12 < A2; t12++) u2[t12].length = 0, u2[t12].hasNulls = false;
            if (M2 += 1, t11 === c10) break;
          }
          if (t11 === c10) break;
          if (g2) {
            let e11;
            let i11 = y2 ? t11 : r10.cropStart + t11, s11 = a10 && a10[i11] || r10.pointClass.prototype.applyOptions.apply({ series: r10 }, [n10[i11]]);
            for (let t12 = 0; t12 < f2; t12++) ur(e11 = s11[g2[t12]]) ? u2[t12].push(e11) : null === e11 && (u2[t12].hasNulls = true);
          } else ur(v2 = p10 ? o10[t11] : null) ? u2[0].push(v2) : null === v2 && (u2[0].hasNulls = true);
        }
        let T2 = { x: h10 };
        return (g2 || ["y"]).forEach((t11, e11) => {
          T2[t11] = x2[e11];
        }), l10.setColumns(T2), { groupMap: d10, modified: l10 };
      }
      function uf(t10) {
        let e10 = t10.options, i10 = this.type, s10 = this.chart.options.plotOptions, o10 = this.useCommonDataGrouping && p0.common, r10 = p0.seriesSpecific, a10 = tT.defaultOptions.plotOptions[i10].dataGrouping;
        if (s10 && (r10[i10] || o10)) {
          let t11 = this.chart.rangeSelector;
          a10 || (a10 = ua(p0.common, r10[i10])), e10.dataGrouping = ua(o10, a10, s10.series && s10.series.dataGrouping, s10[i10].dataGrouping, this.userOptions.dataGrouping, !e10.isInternal && t11 && ur(t11.selected) && t11.buttonOptions[t11.selected].dataGrouping);
        }
      }
      let um = { compose: function(t10) {
        let e10 = t10.prototype;
        e10.applyGrouping || (ue(t10.prototype.pointClass, "update", function() {
          if (this.dataGroup) return us(24, false, this.series.chart), false;
        }), ue(t10, "afterSetOptions", uf), ue(t10, "destroy", uc), uo(e10, { applyGrouping: ud, destroyGroupedData: uc, generatePoints: up, getDGApproximation: uu, groupData: ug }));
      }, groupData: ug }, { format: ux } = eg, { composed: uy } = L, { addEvent: ub, extend: uv, isNumber: uk, pick: uM, pushUnique: uw } = ti;
      function uS(t10) {
        var _a;
        let e10 = this.chart, i10 = e10.time, s10 = t10.point, o10 = s10.series, r10 = o10.options, a10 = o10.tooltipOptions, n10 = r10.dataGrouping, h10 = o10.xAxis, l10 = a10.xDateFormat || "", d10, c10, p10, u2, g2, f2 = a10[t10.isFooter ? "footerFormat" : "headerFormat"];
        if (h10 && "datetime" === h10.options.type && n10 && uk(s10.key)) {
          c10 = o10.currentDataGrouping, p10 = n10.dateTimeLabelFormats || p0.common.dateTimeLabelFormats, c10 ? (u2 = p10[c10.unitName], 1 === c10.count ? l10 = u2[0] : (l10 = u2[1], d10 = u2[2])) : !l10 && p10 && h10.dateTime && (l10 = h10.dateTime.getXDateFormat(s10.x, a10.dateTimeLabelFormats));
          let r11 = uM((_a = o10.groupMap) == null ? void 0 : _a[s10.index].groupStart, s10.key), m2 = r11 + ((c10 == null ? void 0 : c10.totalRange) || 0) - 1;
          g2 = i10.dateFormat(l10, r11), d10 && (g2 += i10.dateFormat(d10, m2)), o10.chart.styledMode && (f2 = this.styledModeFormat(f2)), t10.text = ux(f2, { point: uv(s10, { key: g2 }), series: o10 }, e10), t10.preventDefault();
        }
      }
      let uA = { compose: function(t10, e10, i10) {
        p7.compose(t10), um.compose(e10), i10 && uw(uy, "DataGrouping") && ub(i10, "headerFormatter", uS);
      }, groupData: um.groupData };
      L.dataGrouping = L.dataGrouping || {}, L.dataGrouping.approximationDefaults = L.dataGrouping.approximationDefaults || pQ, L.dataGrouping.approximations = L.dataGrouping.approximations || pU, uA.compose(L.Axis, L.Series, L.Tooltip);
      let { defined: uT, isNumber: uC, pick: uP } = ti, uO = { backgroundColor: "string", borderColor: "string", borderRadius: "string", color: "string", fill: "string", fontSize: "string", labels: "string", name: "string", stroke: "string", title: "string" }, { addEvent: uE, isObject: uL, pick: uD, defined: uB, merge: uI } = ti, { getAssignedAxis: uz } = { annotationsFieldsTypes: uO, getAssignedAxis: function(t10) {
        return t10.filter((t11) => {
          let e10 = t11.axis.getExtremes(), i10 = e10.min, s10 = e10.max, o10 = uP(t11.axis.minPointOffset, 0);
          return uC(i10) && uC(s10) && t11.value >= i10 - o10 && t11.value <= s10 + o10 && !t11.axis.options.isInternal;
        })[0];
      }, getFieldType: function(t10, e10) {
        let i10 = uO[t10], s10 = typeof e10;
        return uT(i10) && (s10 = i10), { string: "text", number: "number", boolean: "checkbox" }[s10];
      } }, uR = [], uN = { enabled: true, sensitivity: 1.1 }, uW = (t10) => (uL(t10) || (t10 = { enabled: t10 ?? true }), uI(uN, t10)), uG = function(t10, e10, i10, s10, o10, a10, n10) {
        let h10 = uD(n10.type, t10.zooming.type, ""), l10 = [];
        "x" === h10 ? l10 = i10 : "y" === h10 ? l10 = s10 : "xy" === h10 && (l10 = t10.axes);
        let d10 = t10.transform({ axes: l10, to: { x: o10 - 5, y: a10 - 5, width: 10, height: 10 }, from: { x: o10 - 5 * e10, y: a10 - 5 * e10, width: 10 * e10, height: 10 * e10 }, trigger: "mousewheel" });
        return d10 && (uB(r) && clearTimeout(r), r = setTimeout(() => {
          var _a;
          (_a = t10.pointer) == null ? void 0 : _a.drop();
        }, 400)), d10;
      };
      function uX() {
        let t10 = uW(this.zooming.mouseWheel);
        t10.enabled && uE(this.container, "wheel", (e10) => {
          var _a, _b;
          e10 = ((_a = this.pointer) == null ? void 0 : _a.normalize(e10)) || e10;
          let { pointer: i10 } = this, s10 = i10 && !i10.inClass(e10.target, "highcharts-no-mousewheel");
          if (this.isInsidePlot(e10.chartX - this.plotLeft, e10.chartY - this.plotTop) && s10) {
            let s11 = t10.sensitivity || 1.1, o10 = e10.detail || (e10.deltaY || 0) / 120, r10 = uz(i10.getCoordinates(e10).xAxis), a10 = uz(i10.getCoordinates(e10).yAxis);
            uG(this, Math.pow(s11, o10), r10 ? [r10.axis] : this.xAxis, a10 ? [a10.axis] : this.yAxis, e10.chartX, e10.chartY, t10) && ((_b = e10.preventDefault) == null ? void 0 : _b.call(e10));
          }
        });
      }
      L.MouseWheelZoom = L.MouseWheelZoom || { compose: function(t10) {
        -1 === uR.indexOf(t10) && (uR.push(t10), uE(t10, "afterGetContainer", uX));
      } }, L.MouseWheelZoom.compose(L.Chart), L.Navigator = L.Navigator || dQ, L.OrdinalAxis = L.OrdinalAxis || d7, L.RangeSelector = L.RangeSelector || cN, L.Scrollbar = L.Scrollbar || dB, L.stockChart = L.stockChart || c1.stockChart, L.StockChart = L.StockChart || L.stockChart, L.extend(L.StockChart, c1), lX.compose(L.Series, L.Axis, L.Point), pN.compose(L.Renderer), pl.compose(L.Series), L.Navigator.compose(L.Chart, L.Axis, L.Series), L.OrdinalAxis.compose(L.Axis, L.Series, L.Chart), L.RangeSelector.compose(L.Axis, L.Chart), L.Scrollbar.compose(L.Axis), L.StockChart.compose(L.Chart, L.Axis, L.Series, L.SVGRenderer), /**
      * @license Highstock JS v12.1.2 (2024-12-21)
      * @module highcharts/highstock
      *
      * (c) 2009-2024 Torstein Honsi
      *
      * License: www.highcharts.com/license
      */
      L.product = "Highstock";
      let uH = L;
      return E.default;
    })());
  }
});
export default require_highstock();
//# sourceMappingURL=highcharts_highstock.js.map
