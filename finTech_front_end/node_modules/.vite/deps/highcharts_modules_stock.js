import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/highcharts/modules/stock.js
var require_stock = __commonJS({
  "node_modules/highcharts/modules/stock.js"(exports, module) {
    !/**
    * Highcharts JS v12.1.2 (2024-12-21)
    * @module highcharts/modules/broken-axis
    * @requires highcharts
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(t._Highcharts, t._Highcharts.Axis, t._Highcharts.Point, t._Highcharts.Series, t._Highcharts.Color, t._Highcharts.SeriesRegistry, t._Highcharts.RendererRegistry, t._Highcharts.SVGRenderer, t._Highcharts.SVGElement, t._Highcharts.Chart, t._Highcharts.Templating, t._Highcharts.Series.types.column, t._Highcharts.StackItem) : "function" == typeof define && define.amd ? define("highcharts/modules/stock", ["highcharts/highcharts"], function(t2) {
        return e(t2, t2.Axis, t2.Point, t2.Series, t2.Color, t2.SeriesRegistry, t2.RendererRegistry, t2.SVGRenderer, t2.SVGElement, t2.Chart, t2.Templating, t2.Series, ["types"], ["column"], t2.StackItem);
      }) : "object" == typeof exports ? exports["highcharts/modules/stock"] = e(t._Highcharts, t._Highcharts.Axis, t._Highcharts.Point, t._Highcharts.Series, t._Highcharts.Color, t._Highcharts.SeriesRegistry, t._Highcharts.RendererRegistry, t._Highcharts.SVGRenderer, t._Highcharts.SVGElement, t._Highcharts.Chart, t._Highcharts.Templating, t._Highcharts.Series.types.column, t._Highcharts.StackItem) : t.Highcharts = e(t.Highcharts, t.Highcharts.Axis, t.Highcharts.Point, t.Highcharts.Series, t.Highcharts.Color, t.Highcharts.SeriesRegistry, t.Highcharts.RendererRegistry, t.Highcharts.SVGRenderer, t.Highcharts.SVGElement, t.Highcharts.Chart, t.Highcharts.Templating, t.Highcharts.Series.types.column, t.Highcharts.StackItem);
    }("undefined" == typeof window ? exports : window, (t, e, i, s, o, n, r, a, l, h, d, p, c) => (() => {
      "use strict";
      let u, g, m, f;
      var x, b, v, y, M, A, k, w = { 532: (t10) => {
        t10.exports = e;
      }, 960: (t10) => {
        t10.exports = h;
      }, 620: (t10) => {
        t10.exports = o;
      }, 260: (t10) => {
        t10.exports = i;
      }, 608: (t10) => {
        t10.exports = r;
      }, 28: (t10) => {
        t10.exports = l;
      }, 540: (t10) => {
        t10.exports = a;
      }, 448: (t10) => {
        t10.exports = p;
      }, 820: (t10) => {
        t10.exports = s;
      }, 512: (t10) => {
        t10.exports = n;
      }, 184: (t10) => {
        t10.exports = c;
      }, 984: (t10) => {
        t10.exports = d;
      }, 944: (e10) => {
        e10.exports = t;
      } }, S = {};
      function E(t10) {
        var e10 = S[t10];
        if (void 0 !== e10) return e10.exports;
        var i10 = S[t10] = { exports: {} };
        return w[t10](i10, i10.exports, E), i10.exports;
      }
      E.n = (t10) => {
        var e10 = t10 && t10.__esModule ? () => t10.default : () => t10;
        return E.d(e10, { a: e10 }), e10;
      }, E.d = (t10, e10) => {
        for (var i10 in e10) E.o(e10, i10) && !E.o(t10, i10) && Object.defineProperty(t10, i10, { enumerable: true, get: e10[i10] });
      }, E.o = (t10, e10) => Object.prototype.hasOwnProperty.call(t10, e10);
      var C = {};
      E.d(C, { default: () => oO });
      var T = E(944), B = E.n(T), O = E(532), D = E.n(O), P = E(260), R = E.n(P), G = E(820), I = E.n(G);
      let { tooltipFormatter: z } = R().prototype, { addEvent: L, arrayMax: W, arrayMin: H, correctFloat: X, defined: Y, isArray: N, isNumber: F, isString: U, pick: _ } = B();
      !function(t10) {
        function e10(t11, e11, i11) {
          !this.isXAxis && (this.series.forEach(function(i12) {
            "compare" === t11 && "boolean" != typeof e11 ? i12.setCompare(e11, false) : "cumulative" !== t11 || U(e11) || i12.setCumulative(e11, false);
          }), _(i11, true) && this.chart.redraw());
        }
        function i10(t11) {
          let e11 = this, { numberFormatter: i11 } = e11.series.chart, s11 = function(s12) {
            t11 = t11.replace("{point." + s12 + "}", (e11[s12] > 0 && "change" === s12 ? "+" : "") + i11(e11[s12], _(e11.series.tooltipOptions.changeDecimals, 2)));
          };
          return Y(e11.change) && s11("change"), Y(e11.cumulativeSum) && s11("cumulativeSum"), z.apply(this, [t11]);
        }
        function s10() {
          let t11;
          let e11 = this.options.compare;
          ("percent" === e11 || "value" === e11 || this.options.cumulative) && (t11 = new d2(this), "percent" === e11 || "value" === e11 ? t11.initCompare(e11) : t11.initCumulative()), this.dataModify = t11;
        }
        function o2(t11) {
          let e11 = t11.dataExtremes, i11 = e11.activeYData;
          if (this.dataModify && e11) {
            let t12;
            this.options.compare ? t12 = [this.dataModify.modifyValue(e11.dataMin), this.dataModify.modifyValue(e11.dataMax)] : this.options.cumulative && N(i11) && i11.length >= 2 && (t12 = d2.getCumulativeExtremes(i11)), t12 && (e11.dataMin = H(t12), e11.dataMax = W(t12));
          }
        }
        function n2(t11, e11) {
          this.options.compare = this.userOptions.compare = t11, this.update({}, _(e11, true)), this.dataModify && ("value" === t11 || "percent" === t11) ? this.dataModify.initCompare(t11) : this.points.forEach((t12) => {
            delete t12.change;
          });
        }
        function r2() {
          let t11 = this.getColumn(this.pointArrayMap && (this.options.pointValKey || this.pointValKey) || "y", true);
          if (this.xAxis && t11.length && this.dataModify) {
            let e11 = this.getColumn("x", true), i11 = this.dataTable.rowCount, s11 = true === this.options.compareStart ? 0 : 1;
            for (let o3 = 0; o3 < i11 - s11; o3++) {
              let i12 = t11[o3];
              if (F(i12) && 0 !== i12 && e11[o3 + s11] >= (this.xAxis.min || 0)) {
                this.dataModify.compareValue = i12;
                break;
              }
            }
          }
        }
        function a2(t11, e11) {
          this.setModifier("compare", t11, e11);
        }
        function l2(t11, e11) {
          t11 = _(t11, false), this.options.cumulative = this.userOptions.cumulative = t11, this.update({}, _(e11, true)), this.dataModify ? this.dataModify.initCumulative() : this.points.forEach((t12) => {
            delete t12.cumulativeSum;
          });
        }
        function h2(t11, e11) {
          this.setModifier("cumulative", t11, e11);
        }
        t10.compose = function(t11, d3, p2) {
          let c2 = d3.prototype, u2 = p2.prototype, g2 = t11.prototype;
          return g2.setCompare || (g2.setCompare = n2, g2.setCumulative = l2, L(t11, "afterInit", s10), L(t11, "afterGetExtremes", o2), L(t11, "afterProcessData", r2)), c2.setCompare || (c2.setCompare = a2, c2.setModifier = e10, c2.setCumulative = h2, u2.tooltipFormatter = i10), t11;
        };
        class d2 {
          constructor(t11) {
            this.series = t11;
          }
          modifyValue() {
            return 0;
          }
          static getCumulativeExtremes(t11) {
            let e11 = 1 / 0, i11 = -1 / 0;
            return t11.reduce((t12, s11) => {
              let o3 = t12 + s11;
              return e11 = Math.min(e11, o3, t12), i11 = Math.max(i11, o3, t12), o3;
            }), [e11, i11];
          }
          initCompare(t11) {
            this.modifyValue = function(e11, i11) {
              null === e11 && (e11 = 0);
              let s11 = this.compareValue;
              if (void 0 !== e11 && void 0 !== s11) {
                if ("value" === t11 ? e11 -= s11 : e11 = e11 / s11 * 100 - (100 === this.series.options.compareBase ? 0 : 100), void 0 !== i11) {
                  let t12 = this.series.points[i11];
                  t12 && (t12.change = e11);
                }
                return e11;
              }
              return 0;
            };
          }
          initCumulative() {
            this.modifyValue = function(t11, e11) {
              if (null === t11 && (t11 = 0), void 0 !== t11 && void 0 !== e11) {
                let i11 = e11 > 0 ? this.series.points[e11 - 1] : null;
                i11 && i11.cumulativeSum && (t11 = X(i11.cumulativeSum + t11));
                let s11 = this.series.points[e11], o3 = s11.series.options.cumulativeStart, n3 = s11.x <= this.series.xAxis.max && s11.x >= this.series.xAxis.min;
                return s11 && (!o3 || n3 ? s11.cumulativeSum = t11 : s11.cumulativeSum = void 0), t11;
              }
              return 0;
            };
          }
        }
        t10.Additions = d2;
      }(x || (x = {}));
      let V = x, { isTouchDevice: Z } = B(), { addEvent: j, merge: K, pick: q } = B(), $ = [];
      function J() {
        this.navigator && this.navigator.setBaseSeries(null, false);
      }
      function Q() {
        var _a;
        let t10, e10, i10;
        let s10 = this.legend, o2 = this.navigator;
        if (o2) {
          t10 = s10 && s10.options, e10 = o2.xAxis, i10 = o2.yAxis;
          let { scrollbarHeight: n2, scrollButtonSize: r2 } = o2;
          this.inverted ? (o2.left = o2.opposite ? this.chartWidth - n2 - o2.height : this.spacing[3] + n2, o2.top = this.plotTop + r2) : (o2.left = q(e10.left, this.plotLeft + r2), o2.top = o2.navigatorOptions.top || this.chartHeight - o2.height - n2 - (((_a = this.scrollbar) == null ? void 0 : _a.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t10 && "bottom" === t10.verticalAlign && "proximate" !== t10.layout && t10.enabled && !t10.floating ? s10.legendHeight + q(t10.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e10 && i10 && (this.inverted ? e10.options.left = i10.options.left = o2.left : e10.options.top = i10.options.top = o2.top, e10.setAxisSize(), i10.setAxisSize());
        }
      }
      function tt(t10) {
        !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new u(this), q(t10.redraw, true) && this.redraw(t10.animation));
      }
      function te() {
        let t10 = this.options;
        (t10.navigator.enabled || t10.scrollbar.enabled) && (this.scroller = this.navigator = new u(this));
      }
      function ti() {
        let t10 = this.options, e10 = t10.navigator, i10 = t10.rangeSelector;
        if ((e10 && e10.enabled || i10 && i10.enabled) && (!Z && "x" === this.zooming.type || Z && "x" === this.zooming.pinchType)) return false;
      }
      function ts(t10) {
        let e10 = t10.navigator;
        if (e10 && t10.xAxis[0]) {
          let i10 = t10.xAxis[0].getExtremes();
          e10.render(i10.min, i10.max);
        }
      }
      function to(t10) {
        let e10 = t10.options.navigator || {}, i10 = t10.options.scrollbar || {};
        !this.navigator && !this.scroller && (e10.enabled || i10.enabled) && (K(true, this.options.navigator, e10), K(true, this.options.scrollbar, i10), delete t10.options.navigator, delete t10.options.scrollbar);
      }
      let tn = { compose: function(t10, e10) {
        if (B().pushUnique($, t10)) {
          let i10 = t10.prototype;
          u = e10, i10.callbacks.push(ts), j(t10, "afterAddSeries", J), j(t10, "afterSetChartSize", Q), j(t10, "afterUpdate", tt), j(t10, "beforeRender", te), j(t10, "beforeShowResetZoom", ti), j(t10, "update", to);
        }
      } }, { isTouchDevice: tr } = B(), { addEvent: ta, correctFloat: tl, defined: th, isNumber: td, pick: tp } = B();
      function tc() {
        this.navigatorAxis || (this.navigatorAxis = new tg(this));
      }
      function tu(t10) {
        let e10;
        let i10 = this.chart, s10 = i10.options, o2 = s10.navigator, n2 = this.navigatorAxis, r2 = i10.zooming.pinchType, a2 = s10.rangeSelector, l2 = i10.zooming.type;
        if (this.isXAxis && ((o2 == null ? void 0 : o2.enabled) || (a2 == null ? void 0 : a2.enabled))) {
          if ("y" === l2 && "zoom" === t10.trigger) e10 = false;
          else if (("zoom" === t10.trigger && "xy" === l2 || tr && "xy" === r2) && this.options.range) {
            let e11 = n2.previousZoom;
            th(t10.min) ? n2.previousZoom = [this.min, this.max] : e11 && (t10.min = e11[0], t10.max = e11[1], n2.previousZoom = void 0);
          }
        }
        void 0 !== e10 && t10.preventDefault();
      }
      class tg {
        static compose(t10) {
          t10.keepProps.includes("navigatorAxis") || (t10.keepProps.push("navigatorAxis"), ta(t10, "init", tc), ta(t10, "setExtremes", tu));
        }
        constructor(t10) {
          this.axis = t10;
        }
        destroy() {
          this.axis = void 0;
        }
        toFixedRange(t10, e10, i10, s10) {
          let o2 = this.axis, n2 = (o2.pointRange || 0) / 2, r2 = tp(i10, o2.translate(t10, true, !o2.horiz)), a2 = tp(s10, o2.translate(e10, true, !o2.horiz));
          return th(i10) || (r2 = tl(r2 + n2)), th(s10) || (a2 = tl(a2 - n2)), td(r2) && td(a2) || (r2 = a2 = void 0), { min: r2, max: a2 };
        }
      }
      var tm = E(620), tf = E.n(tm), tx = E(512), tb = E.n(tx);
      let { parse: tv } = tf(), { seriesTypes: ty } = tb(), tM = { height: 40, margin: 25, maskInside: true, handles: { width: 7, borderRadius: 0, height: 15, symbols: ["navigator-handle", "navigator-handle"], enabled: true, lineWidth: 1, backgroundColor: "#f2f2f2", borderColor: "#999999" }, maskFill: tv("#667aff").setOpacity(0.3).get(), outlineColor: "#999999", outlineWidth: 1, series: { type: void 0 === ty.areaspline ? "line" : "areaspline", fillOpacity: 0.05, lineWidth: 1, compare: null, sonification: { enabled: false }, dataGrouping: { approximation: "average", enabled: true, groupPixelWidth: 2, firstAnchor: "firstPoint", anchor: "middle", lastAnchor: "lastPoint", units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]] }, dataLabels: { enabled: false, zIndex: 2 }, id: "highcharts-navigator-series", className: "highcharts-navigator-series", lineColor: null, marker: { enabled: false }, threshold: null }, xAxis: { className: "highcharts-navigator-xaxis", tickLength: 0, lineWidth: 0, gridLineColor: "#e6e6e6", id: "navigator-x-axis", gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", style: { color: "#000000", fontSize: "0.7em", opacity: 0.6, textOutline: "2px contrast" }, x: 3, y: -4 }, crosshair: false }, yAxis: { className: "highcharts-navigator-yaxis", gridLineWidth: 0, startOnTick: false, endOnTick: false, minPadding: 0.1, id: "navigator-y-axis", maxPadding: 0.1, labels: { enabled: false }, crosshair: false, title: { text: null }, tickLength: 0, tickWidth: 0 } }, { defined: tA, isNumber: tk, pick: tw } = B(), tS = { rect: function(t10, e10, i10, s10, o2) {
        return o2 && o2.r ? function(t11, e11, i11, s11, o3) {
          let n2 = (o3 == null ? void 0 : o3.r) || 0;
          return [["M", t11 + n2, e11], ["L", t11 + i11 - n2, e11], ["A", n2, n2, 0, 0, 1, t11 + i11, e11 + n2], ["L", t11 + i11, e11 + s11 - n2], ["A", n2, n2, 0, 0, 1, t11 + i11 - n2, e11 + s11], ["L", t11 + n2, e11 + s11], ["A", n2, n2, 0, 0, 1, t11, e11 + s11 - n2], ["L", t11, e11 + n2], ["A", n2, n2, 0, 0, 1, t11 + n2, e11], ["Z"]];
        }(t10, e10, i10, s10, o2) : [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
      } }, { relativeLength: tE } = B(), tC = { "navigator-handle": function(t10, e10, i10, s10, o2 = {}) {
        let n2 = o2.width ? o2.width / 2 : i10, r2 = tE(o2.borderRadius || 0, Math.min(2 * n2, s10));
        return [["M", -1.5, (s10 = o2.height || s10) / 2 - 3.5], ["L", -1.5, s10 / 2 + 4.5], ["M", 0.5, s10 / 2 - 3.5], ["L", 0.5, s10 / 2 + 4.5], ...tS.rect(-n2 - 1, 0.5, 2 * n2 + 1, s10, { r: r2 })];
      } };
      var tT = E(608), tB = E.n(tT);
      let { defined: tO } = B(), tD = { setFixedRange: function(t10) {
        let e10 = this.xAxis[0];
        tO(e10.dataMax) && tO(e10.dataMin) && t10 ? this.fixedRange = Math.min(t10, e10.dataMax - e10.dataMin) : this.fixedRange = t10;
      } }, { setOptions: tP } = B(), { composed: tR } = B(), { getRendererType: tG } = tB(), { setFixedRange: tI } = tD, { addEvent: tz, extend: tL, pushUnique: tW } = B();
      function tH() {
        this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, false);
      }
      let tX = { compose: function(t10, e10, i10) {
        tg.compose(e10), tW(tR, "Navigator") && (t10.prototype.setFixedRange = tI, tL(tG().prototype.symbols, tC), tz(i10, "afterUpdate", tH), tP({ navigator: tM }));
      } }, { composed: tY } = B(), { addEvent: tN, defined: tF, pick: tU, pushUnique: t_ } = B();
      !function(t10) {
        let e10;
        function i10(t11) {
          let e11 = tU(t11.options && t11.options.min, t11.min), i11 = tU(t11.options && t11.options.max, t11.max);
          return { axisMin: e11, axisMax: i11, scrollMin: tF(t11.dataMin) ? Math.min(e11, t11.min, t11.dataMin, tU(t11.threshold, 1 / 0)) : e11, scrollMax: tF(t11.dataMax) ? Math.max(i11, t11.max, t11.dataMax, tU(t11.threshold, -1 / 0)) : i11 };
        }
        function s10() {
          let t11 = this.scrollbar, e11 = t11 && !t11.options.opposite, i11 = this.horiz ? 2 : e11 ? 3 : 1;
          t11 && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i11] += t11.size + (t11.options.margin || 0));
        }
        function o2() {
          let t11 = this;
          t11.options && t11.options.scrollbar && t11.options.scrollbar.enabled && (t11.options.scrollbar.vertical = !t11.horiz, t11.options.startOnTick = t11.options.endOnTick = false, t11.scrollbar = new e10(t11.chart.renderer, t11.options.scrollbar, t11.chart), tN(t11.scrollbar, "changed", function(e11) {
            let s11, o3;
            let { axisMin: n3, axisMax: r2, scrollMin: a2, scrollMax: l2 } = i10(t11), h2 = l2 - a2;
            if (tF(n3) && tF(r2)) {
              if (t11.horiz && !t11.reversed || !t11.horiz && t11.reversed ? (s11 = a2 + h2 * this.to, o3 = a2 + h2 * this.from) : (s11 = a2 + h2 * (1 - this.from), o3 = a2 + h2 * (1 - this.to)), this.shouldUpdateExtremes(e11.DOMType)) {
                let i11 = "mousemove" !== e11.DOMType && "touchmove" !== e11.DOMType && void 0;
                t11.setExtremes(o3, s11, true, i11, e11);
              } else this.setRange(this.from, this.to);
            }
          }));
        }
        function n2() {
          let t11, e11, s11;
          let { scrollMin: o3, scrollMax: n3 } = i10(this), r2 = this.scrollbar, a2 = this.axisTitleMargin + (this.titleOffset || 0), l2 = this.chart.scrollbarsOffsets, h2 = this.options.margin || 0;
          if (r2 && l2) {
            if (this.horiz) this.opposite || (l2[1] += a2), r2.position(this.left, this.top + this.height + 2 + l2[1] - (this.opposite ? h2 : 0), this.width, this.height), this.opposite || (l2[1] += h2), t11 = 1;
            else {
              let e12;
              this.opposite && (l2[0] += a2), e12 = r2.options.opposite ? this.left + this.width + 2 + l2[0] - (this.opposite ? 0 : h2) : this.opposite ? 0 : h2, r2.position(e12, this.top, this.width, this.height), this.opposite && (l2[0] += h2), t11 = 0;
            }
            if (l2[t11] += r2.size + (r2.options.margin || 0), isNaN(o3) || isNaN(n3) || !tF(this.min) || !tF(this.max) || this.dataMin === this.dataMax) r2.setRange(0, 1);
            else if (this.min === this.max) {
              let t12 = this.pointRange / (this.dataMax + 1);
              e11 = t12 * this.min, s11 = t12 * (this.max + 1), r2.setRange(e11, s11);
            } else e11 = (this.min - o3) / (n3 - o3), s11 = (this.max - o3) / (n3 - o3), this.horiz && !this.reversed || !this.horiz && this.reversed ? r2.setRange(e11, s11) : r2.setRange(1 - s11, 1 - e11);
          }
        }
        t10.compose = function(t11, i11) {
          t_(tY, "Axis.Scrollbar") && (e10 = i11, tN(t11, "afterGetOffset", s10), tN(t11, "afterInit", o2), tN(t11, "afterRender", n2));
        };
      }(b || (b = {}));
      let tV = b, tZ = { height: 10, barBorderRadius: 5, buttonBorderRadius: 0, buttonsEnabled: false, liveRedraw: void 0, margin: void 0, minWidth: 6, opposite: true, step: 0.2, zIndex: 3, barBackgroundColor: "#cccccc", barBorderWidth: 0, barBorderColor: "#cccccc", buttonArrowColor: "#333333", buttonBackgroundColor: "#e6e6e6", buttonBorderColor: "#cccccc", buttonBorderWidth: 1, rifleColor: "none", trackBackgroundColor: "rgba(255, 255, 255, 0.001)", trackBorderColor: "#cccccc", trackBorderRadius: 5, trackBorderWidth: 1 }, { defaultOptions: tj } = B(), { addEvent: tK, correctFloat: tq, crisp: t$, defined: tJ, destroyObjectProperties: tQ, fireEvent: t0, merge: t1, pick: t2, removeEvent: t5 } = B();
      class t3 {
        static compose(t10) {
          tV.compose(t10, t3);
        }
        static swapXY(t10, e10) {
          return e10 && t10.forEach((t11) => {
            let e11;
            let i10 = t11.length;
            for (let s10 = 0; s10 < i10; s10 += 2) "number" == typeof (e11 = t11[s10 + 1]) && (t11[s10 + 1] = t11[s10 + 2], t11[s10 + 2] = e11);
          }), t10;
        }
        constructor(t10, e10, i10) {
          this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t10, e10, i10);
        }
        addEvents() {
          let t10 = this.options.inverted ? [1, 0] : [0, 1], e10 = this.scrollbarButtons, i10 = this.scrollbarGroup.element, s10 = this.track.element, o2 = this.mouseDownHandler.bind(this), n2 = this.mouseMoveHandler.bind(this), r2 = this.mouseUpHandler.bind(this), a2 = [[e10[t10[0]].element, "click", this.buttonToMinClick.bind(this)], [e10[t10[1]].element, "click", this.buttonToMaxClick.bind(this)], [s10, "click", this.trackClick.bind(this)], [i10, "mousedown", o2], [i10.ownerDocument, "mousemove", n2], [i10.ownerDocument, "mouseup", r2], [i10, "touchstart", o2], [i10.ownerDocument, "touchmove", n2], [i10.ownerDocument, "touchend", r2]];
          a2.forEach(function(t11) {
            tK.apply(null, t11);
          }), this._events = a2;
        }
        buttonToMaxClick(t10) {
          let e10 = (this.to - this.from) * t2(this.options.step, 0.2);
          this.updatePosition(this.from + e10, this.to + e10), t0(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t10 });
        }
        buttonToMinClick(t10) {
          let e10 = tq(this.to - this.from) * t2(this.options.step, 0.2);
          this.updatePosition(tq(this.from - e10), tq(this.to - e10)), t0(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t10 });
        }
        cursorToScrollbarPosition(t10) {
          let e10 = this.options, i10 = e10.minWidth > this.calculatedWidth ? e10.minWidth : 0;
          return { chartX: (t10.chartX - this.x - this.xOffset) / (this.barWidth - i10), chartY: (t10.chartY - this.y - this.yOffset) / (this.barWidth - i10) };
        }
        destroy() {
          let t10 = this, e10 = t10.chart.scroller;
          t10.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function(e11) {
            t10[e11] && t10[e11].destroy && (t10[e11] = t10[e11].destroy());
          }), e10 && t10 === e10.scrollbar && (e10.scrollbar = null, tQ(e10.scrollbarButtons));
        }
        drawScrollbarButton(t10) {
          let e10 = this.renderer, i10 = this.scrollbarButtons, s10 = this.options, o2 = this.size, n2 = e10.g().add(this.group);
          if (i10.push(n2), s10.buttonsEnabled) {
            let r2 = e10.rect().addClass("highcharts-scrollbar-button").add(n2);
            this.chart.styledMode || r2.attr({ stroke: s10.buttonBorderColor, "stroke-width": s10.buttonBorderWidth, fill: s10.buttonBackgroundColor }), r2.attr(r2.crisp({ x: -0.5, y: -0.5, width: o2, height: o2, r: s10.buttonBorderRadius }, r2.strokeWidth()));
            let a2 = e10.path(t3.swapXY([["M", o2 / 2 + (t10 ? -1 : 1), o2 / 2 - 3], ["L", o2 / 2 + (t10 ? -1 : 1), o2 / 2 + 3], ["L", o2 / 2 + (t10 ? 2 : -2), o2 / 2]], s10.vertical)).addClass("highcharts-scrollbar-arrow").add(i10[t10]);
            this.chart.styledMode || a2.attr({ fill: s10.buttonArrowColor });
          }
        }
        init(t10, e10, i10) {
          this.scrollbarButtons = [], this.renderer = t10, this.userOptions = e10, this.options = t1(tZ, tj.scrollbar, e10), this.options.margin = t2(this.options.margin, 10), this.chart = i10, this.size = t2(this.options.size, this.options.height), e10.enabled && (this.render(), this.addEvents());
        }
        mouseDownHandler(t10) {
          var _a;
          let e10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10, i10 = this.cursorToScrollbarPosition(e10);
          this.chartX = i10.chartX, this.chartY = i10.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = true;
        }
        mouseMoveHandler(t10) {
          var _a;
          let e10;
          let i10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10, s10 = this.options.vertical ? "chartY" : "chartX", o2 = this.initPositions || [];
          this.grabbedCenter && (!t10.touches || 0 !== t10.touches[0][s10]) && (e10 = this.cursorToScrollbarPosition(i10)[s10] - this[s10], this.hasDragged = true, this.updatePosition(o2[0] + e10, o2[1] + e10), this.hasDragged && t0(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t10.type, DOMEvent: t10 }));
        }
        mouseUpHandler(t10) {
          this.hasDragged && t0(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t10.type, DOMEvent: t10 }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
        }
        position(t10, e10, i10, s10) {
          let { buttonsEnabled: o2, margin: n2 = 0, vertical: r2 } = this.options, a2 = this.rendered ? "animate" : "attr", l2 = s10, h2 = 0;
          this.group.show(), this.x = t10, this.y = e10 + this.trackBorderWidth, this.width = i10, this.height = s10, this.xOffset = l2, this.yOffset = h2, r2 ? (this.width = this.yOffset = i10 = h2 = this.size, this.xOffset = l2 = 0, this.yOffset = h2 = o2 ? this.size : 0, this.barWidth = s10 - (o2 ? 2 * i10 : 0), this.x = t10 += n2) : (this.height = s10 = this.size, this.xOffset = l2 = o2 ? this.size : 0, this.barWidth = i10 - (o2 ? 2 * s10 : 0), this.y = this.y + n2), this.group[a2]({ translateX: t10, translateY: this.y }), this.track[a2]({ width: i10, height: s10 }), this.scrollbarButtons[1][a2]({ translateX: r2 ? 0 : i10 - l2, translateY: r2 ? s10 - h2 : 0 });
        }
        removeEvents() {
          this._events.forEach(function(t10) {
            t5.apply(null, t10);
          }), this._events.length = 0;
        }
        render() {
          let t10 = this.renderer, e10 = this.options, i10 = this.size, s10 = this.chart.styledMode, o2 = t10.g("scrollbar").attr({ zIndex: e10.zIndex }).hide().add();
          this.group = o2, this.track = t10.rect().addClass("highcharts-scrollbar-track").attr({ r: e10.trackBorderRadius || 0, height: i10, width: i10 }).add(o2), s10 || this.track.attr({ fill: e10.trackBackgroundColor, stroke: e10.trackBorderColor, "stroke-width": e10.trackBorderWidth });
          let n2 = this.trackBorderWidth = this.track.strokeWidth();
          this.track.attr({ x: -t$(0, n2), y: -t$(0, n2) }), this.scrollbarGroup = t10.g().add(o2), this.scrollbar = t10.rect().addClass("highcharts-scrollbar-thumb").attr({ height: i10 - n2, width: i10 - n2, r: e10.barBorderRadius || 0 }).add(this.scrollbarGroup), this.scrollbarRifles = t10.path(t3.swapXY([["M", -3, i10 / 4], ["L", -3, 2 * i10 / 3], ["M", 0, i10 / 4], ["L", 0, 2 * i10 / 3], ["M", 3, i10 / 4], ["L", 3, 2 * i10 / 3]], e10.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s10 || (this.scrollbar.attr({ fill: e10.barBackgroundColor, stroke: e10.barBorderColor, "stroke-width": e10.barBorderWidth }), this.scrollbarRifles.attr({ stroke: e10.rifleColor, "stroke-width": 1 })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-t$(0, this.scrollbarStrokeWidth), -t$(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);
        }
        setRange(t10, e10) {
          let i10, s10;
          let o2 = this.options, n2 = o2.vertical, r2 = o2.minWidth, a2 = this.barWidth, l2 = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
          if (!tJ(a2)) return;
          let h2 = a2 * Math.min(e10, 1);
          i10 = Math.ceil(a2 * (t10 = Math.max(t10, 0))), this.calculatedWidth = s10 = tq(h2 - i10), s10 < r2 && (i10 = (a2 - r2 + s10) * t10, s10 = r2);
          let d2 = Math.floor(i10 + this.xOffset + this.yOffset), p2 = s10 / 2 - 0.5;
          this.from = t10, this.to = e10, n2 ? (this.scrollbarGroup[l2]({ translateY: d2 }), this.scrollbar[l2]({ height: s10 }), this.scrollbarRifles[l2]({ translateY: p2 }), this.scrollbarTop = d2, this.scrollbarLeft = 0) : (this.scrollbarGroup[l2]({ translateX: d2 }), this.scrollbar[l2]({ width: s10 }), this.scrollbarRifles[l2]({ translateX: p2 }), this.scrollbarLeft = d2, this.scrollbarTop = 0), s10 <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), false === o2.showFull && (t10 <= 0 && e10 >= 1 ? this.group.hide() : this.group.show()), this.rendered = true;
        }
        shouldUpdateExtremes(t10) {
          return t2(this.options.liveRedraw, B().svg && !B().isTouchDevice && !this.chart.boosted) || "mouseup" === t10 || "touchend" === t10 || !tJ(t10);
        }
        trackClick(t10) {
          var _a;
          let e10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10, i10 = this.to - this.from, s10 = this.y + this.scrollbarTop, o2 = this.x + this.scrollbarLeft;
          this.options.vertical && e10.chartY > s10 || !this.options.vertical && e10.chartX > o2 ? this.updatePosition(this.from + i10, this.to + i10) : this.updatePosition(this.from - i10, this.to - i10), t0(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t10 });
        }
        update(t10) {
          this.destroy(), this.init(this.chart.renderer, t1(true, this.options, t10), this.chart);
        }
        updatePosition(t10, e10) {
          e10 > 1 && (t10 = tq(1 - tq(e10 - t10)), e10 = 1), t10 < 0 && (e10 = tq(e10 - t10), t10 = 0), this.from = t10, this.to = e10;
        }
      }
      t3.defaultOptions = tZ, tj.scrollbar = t1(true, t3.defaultOptions, tj.scrollbar);
      var t6 = E(540), t4 = E.n(t6);
      let { defaultOptions: t8 } = B(), { isTouchDevice: t9 } = B(), { prototype: { symbols: t7 } } = t4(), { addEvent: et, clamp: ee, correctFloat: ei, defined: es, destroyObjectProperties: eo, erase: en, extend: er, find: ea, fireEvent: el, isArray: eh, isNumber: ed, merge: ep, pick: ec, removeEvent: eu, splat: eg } = B();
      function em(t10, ...e10) {
        let i10 = [].filter.call(e10, ed);
        if (i10.length) return Math[t10].apply(0, i10);
      }
      class ef {
        static compose(t10, e10, i10) {
          tn.compose(t10, ef), tX.compose(t10, e10, i10);
        }
        constructor(t10) {
          this.isDirty = false, this.scrollbarHeight = 0, this.init(t10);
        }
        drawHandle(t10, e10, i10, s10) {
          let o2 = this.navigatorOptions.handles.height;
          this.handles[e10][s10](i10 ? { translateX: Math.round(this.left + this.height / 2), translateY: Math.round(this.top + parseInt(t10, 10) + 0.5 - o2) } : { translateX: Math.round(this.left + parseInt(t10, 10)), translateY: Math.round(this.top + this.height / 2 - o2 / 2 - 1) });
        }
        drawOutline(t10, e10, i10, s10) {
          let o2 = this.navigatorOptions.maskInside, n2 = this.outline.strokeWidth(), r2 = n2 / 2, a2 = n2 % 2 / 2, l2 = this.scrollButtonSize, h2 = this.size, d2 = this.top, p2 = this.height, c2 = d2 - r2, u2 = d2 + p2, g2 = this.left, m2, f2;
          i10 ? (m2 = d2 + e10 + a2, e10 = d2 + t10 + a2, f2 = [["M", g2 + p2, d2 - l2 - a2], ["L", g2 + p2, m2], ["L", g2, m2], ["M", g2, e10], ["L", g2 + p2, e10], ["L", g2 + p2, d2 + h2 + l2]], o2 && f2.push(["M", g2 + p2, m2 - r2], ["L", g2 + p2, e10 + r2])) : (g2 -= l2, t10 += g2 + l2 - a2, e10 += g2 + l2 - a2, f2 = [["M", g2, c2], ["L", t10, c2], ["L", t10, u2], ["M", e10, u2], ["L", e10, c2], ["L", g2 + h2 + 2 * l2, c2]], o2 && f2.push(["M", t10 - r2, c2], ["L", e10 + r2, c2])), this.outline[s10]({ d: f2 });
        }
        drawMasks(t10, e10, i10, s10) {
          let o2, n2, r2, a2;
          let l2 = this.left, h2 = this.top, d2 = this.height;
          i10 ? (r2 = [l2, l2, l2], a2 = [h2, h2 + t10, h2 + e10], n2 = [d2, d2, d2], o2 = [t10, e10 - t10, this.size - e10]) : (r2 = [l2, l2 + t10, l2 + e10], a2 = [h2, h2, h2], n2 = [t10, e10 - t10, this.size - e10], o2 = [d2, d2, d2]), this.shades.forEach((t11, e11) => {
            t11[s10]({ x: r2[e11], y: a2[e11], width: n2[e11], height: o2[e11] });
          });
        }
        renderElements() {
          var _a;
          let t10 = this, e10 = t10.navigatorOptions, i10 = e10.maskInside, s10 = t10.chart, o2 = s10.inverted, n2 = s10.renderer, r2 = { cursor: o2 ? "ns-resize" : "ew-resize" }, a2 = t10.navigatorGroup ?? (t10.navigatorGroup = n2.g("navigator").attr({ zIndex: 8, visibility: "hidden" }).add());
          if ([!i10, i10, !i10].forEach((i11, o3) => {
            let l2 = t10.shades[o3] ?? (t10.shades[o3] = n2.rect().addClass("highcharts-navigator-mask" + (1 === o3 ? "-inside" : "-outside")).add(a2));
            s10.styledMode || (l2.attr({ fill: i11 ? e10.maskFill : "rgba(0,0,0,0)" }), 1 === o3 && l2.css(r2));
          }), t10.outline || (t10.outline = n2.path().addClass("highcharts-navigator-outline").add(a2)), s10.styledMode || t10.outline.attr({ "stroke-width": e10.outlineWidth, stroke: e10.outlineColor }), (_a = e10.handles) == null ? void 0 : _a.enabled) {
            let i11 = e10.handles, { height: o3, width: l2 } = i11;
            [0, 1].forEach((e11) => {
              var _a2;
              let h2 = i11.symbols[e11];
              if (t10.handles[e11] && t10.handles[e11].symbolUrl === h2) {
                if (!t10.handles[e11].isImg && t10.handles[e11].symbolName !== h2) {
                  let i12 = t7[h2].call(t7, -l2 / 2 - 1, 0, l2, o3);
                  t10.handles[e11].attr({ d: i12 }), t10.handles[e11].symbolName = h2;
                }
              } else (_a2 = t10.handles[e11]) == null ? void 0 : _a2.destroy(), t10.handles[e11] = n2.symbol(h2, -l2 / 2 - 1, 0, l2, o3, i11), t10.handles[e11].attr({ zIndex: 7 - e11 }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][e11]).add(a2), t10.addMouseEvents();
              s10.inverted && t10.handles[e11].attr({ rotation: 90, rotationOriginX: Math.floor(-l2 / 2), rotationOriginY: (o3 + l2) / 2 }), s10.styledMode || t10.handles[e11].attr({ fill: i11.backgroundColor, stroke: i11.borderColor, "stroke-width": i11.lineWidth, width: i11.width, height: i11.height, x: -l2 / 2 - 1, y: 0 }).css(r2);
            });
          }
        }
        update(t10, e10 = false) {
          var _a;
          let i10 = this.chart, s10 = i10.options.chart.inverted !== ((_a = i10.scrollbar) == null ? void 0 : _a.options.vertical);
          if (ep(true, i10.options.navigator, t10), this.navigatorOptions = i10.options.navigator || {}, this.setOpposite(), es(t10.enabled) || s10) return this.destroy(), this.navigatorEnabled = t10.enabled || this.navigatorEnabled, this.init(i10);
          if (this.navigatorEnabled && (this.isDirty = true, false === t10.adaptToUpdatedData && this.baseSeries.forEach((t11) => {
            eu(t11, "updatedData", this.updatedDataHandler);
          }, this), t10.adaptToUpdatedData && this.baseSeries.forEach((t11) => {
            t11.eventsToUnbind.push(et(t11, "updatedData", this.updatedDataHandler));
          }, this), (t10.series || t10.baseSeries) && this.setBaseSeries(void 0, false), t10.height || t10.xAxis || t10.yAxis)) {
            this.height = t10.height ?? this.height;
            let e11 = this.getXAxisOffsets();
            this.xAxis.update({ ...t10.xAxis, offsets: e11, [i10.inverted ? "width" : "height"]: this.height, [i10.inverted ? "height" : "width"]: void 0 }, false), this.yAxis.update({ ...t10.yAxis, [i10.inverted ? "width" : "height"]: this.height }, false);
          }
          e10 && i10.redraw();
        }
        render(t10, e10, i10, s10) {
          let o2 = this.chart, n2 = this.xAxis, r2 = n2.pointRange || 0, a2 = n2.navigatorAxis.fake ? o2.xAxis[0] : n2, l2 = this.navigatorEnabled, h2 = this.rendered, d2 = o2.inverted, p2 = o2.xAxis[0].minRange, c2 = o2.xAxis[0].options.maxRange, u2 = this.scrollButtonSize, g2, m2, f2, x2 = this.scrollbarHeight, b2, v2;
          if (this.hasDragged && !es(i10)) return;
          if (this.isDirty && this.renderElements(), t10 = ei(t10 - r2 / 2), e10 = ei(e10 + r2 / 2), !ed(t10) || !ed(e10)) {
            if (!h2) return;
            i10 = 0, s10 = ec(n2.width, a2.width);
          }
          this.left = ec(n2.left, o2.plotLeft + u2 + (d2 ? o2.plotWidth : 0));
          let y2 = this.size = b2 = ec(n2.len, (d2 ? o2.plotHeight : o2.plotWidth) - 2 * u2);
          g2 = d2 ? x2 : b2 + 2 * u2, i10 = ec(i10, n2.toPixels(t10, true)), s10 = ec(s10, n2.toPixels(e10, true)), ed(i10) && Math.abs(i10) !== 1 / 0 || (i10 = 0, s10 = g2);
          let M2 = n2.toValue(i10, true), A2 = n2.toValue(s10, true), k2 = Math.abs(ei(A2 - M2));
          k2 < p2 ? this.grabbedLeft ? i10 = n2.toPixels(A2 - p2 - r2, true) : this.grabbedRight && (s10 = n2.toPixels(M2 + p2 + r2, true)) : es(c2) && ei(k2 - r2) > c2 && (this.grabbedLeft ? i10 = n2.toPixels(A2 - c2 - r2, true) : this.grabbedRight && (s10 = n2.toPixels(M2 + c2 + r2, true))), this.zoomedMax = ee(Math.max(i10, s10), 0, y2), this.zoomedMin = ee(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i10, s10), 0, y2), this.range = this.zoomedMax - this.zoomedMin, y2 = Math.round(this.zoomedMax);
          let w2 = Math.round(this.zoomedMin);
          l2 && (this.navigatorGroup.attr({ visibility: "inherit" }), v2 = h2 && !this.hasDragged ? "animate" : "attr", this.drawMasks(w2, y2, d2, v2), this.drawOutline(w2, y2, d2, v2), this.navigatorOptions.handles.enabled && (this.drawHandle(w2, 0, d2, v2), this.drawHandle(y2, 1, d2, v2))), this.scrollbar && (d2 ? (f2 = this.top - u2, m2 = this.left - x2 + (l2 || !a2.opposite ? 0 : (a2.titleOffset || 0) + a2.axisTitleMargin), x2 = b2 + 2 * u2) : (f2 = this.top + (l2 ? this.height : -x2), m2 = this.left - u2), this.scrollbar.position(m2, f2, g2, x2), this.scrollbar.setRange(this.zoomedMin / (b2 || 1), this.zoomedMax / (b2 || 1))), this.rendered = true, this.isDirty = false, el(this, "afterRender");
        }
        addMouseEvents() {
          let t10 = this, e10 = t10.chart, i10 = e10.container, s10 = [], o2, n2;
          t10.mouseMoveHandler = o2 = function(e11) {
            t10.onMouseMove(e11);
          }, t10.mouseUpHandler = n2 = function(e11) {
            t10.onMouseUp(e11);
          }, (s10 = t10.getPartsEvents("mousedown")).push(et(e10.renderTo, "mousemove", o2), et(i10.ownerDocument, "mouseup", n2), et(e10.renderTo, "touchmove", o2), et(i10.ownerDocument, "touchend", n2)), s10.concat(t10.getPartsEvents("touchstart")), t10.eventsToUnbind = s10, t10.series && t10.series[0] && s10.push(et(t10.series[0].xAxis, "foundExtremes", function() {
            e10.navigator.modifyNavigatorAxisExtremes();
          }));
        }
        getPartsEvents(t10) {
          let e10 = this, i10 = [];
          return ["shades", "handles"].forEach(function(s10) {
            e10[s10].forEach(function(o2, n2) {
              i10.push(et(o2.element, t10, function(t11) {
                e10[s10 + "Mousedown"](t11, n2);
              }));
            });
          }), i10;
        }
        shadesMousedown(t10, e10) {
          var _a;
          t10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10;
          let i10 = this.chart, s10 = this.xAxis, o2 = this.zoomedMin, n2 = this.size, r2 = this.range, a2 = this.left, l2 = t10.chartX, h2, d2, p2, c2;
          i10.inverted && (l2 = t10.chartY, a2 = this.top), 1 === e10 ? (this.grabbedCenter = l2, this.fixedWidth = r2, this.dragOffset = l2 - o2) : (c2 = l2 - a2 - r2 / 2, 0 === e10 ? c2 = Math.max(0, c2) : 2 === e10 && c2 + r2 >= n2 && (c2 = n2 - r2, this.reversedExtremes ? (c2 -= r2, d2 = this.getUnionExtremes().dataMin) : h2 = this.getUnionExtremes().dataMax), c2 !== o2 && (this.fixedWidth = r2, es((p2 = s10.navigatorAxis.toFixedRange(c2, c2 + r2, d2, h2)).min) && el(this, "setRange", { min: Math.min(p2.min, p2.max), max: Math.max(p2.min, p2.max), redraw: true, eventArguments: { trigger: "navigator" } })));
        }
        handlesMousedown(t10, e10) {
          var _a;
          t10 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t10)) || t10;
          let i10 = this.chart, s10 = i10.xAxis[0], o2 = this.reversedExtremes;
          0 === e10 ? (this.grabbedLeft = true, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o2 ? s10.min : s10.max) : (this.grabbedRight = true, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o2 ? s10.max : s10.min), i10.setFixedRange(void 0);
        }
        onMouseMove(t10) {
          var _a;
          let e10 = this, i10 = e10.chart, s10 = e10.navigatorSize, o2 = e10.range, n2 = e10.dragOffset, r2 = i10.inverted, a2 = e10.left, l2;
          (!t10.touches || 0 !== t10.touches[0].pageX) && (l2 = (t10 = ((_a = i10.pointer) == null ? void 0 : _a.normalize(t10)) || t10).chartX, r2 && (a2 = e10.top, l2 = t10.chartY), e10.grabbedLeft ? (e10.hasDragged = true, e10.render(0, 0, l2 - a2, e10.otherHandlePos)) : e10.grabbedRight ? (e10.hasDragged = true, e10.render(0, 0, e10.otherHandlePos, l2 - a2)) : e10.grabbedCenter && (e10.hasDragged = true, l2 < n2 ? l2 = n2 : l2 > s10 + n2 - o2 && (l2 = s10 + n2 - o2), e10.render(0, 0, l2 - n2, l2 - n2 + o2)), e10.hasDragged && e10.scrollbar && ec(e10.scrollbar.options.liveRedraw, !t9 && !this.chart.boosted) && (t10.DOMType = t10.type, setTimeout(function() {
            e10.onMouseUp(t10);
          }, 0)));
        }
        onMouseUp(t10) {
          let e10, i10, s10, o2, n2, r2;
          let a2 = this.chart, l2 = this.xAxis, h2 = this.scrollbar, d2 = t10.DOMEvent || t10, p2 = a2.inverted, c2 = this.rendered && !this.hasDragged ? "animate" : "attr";
          (this.hasDragged && (!h2 || !h2.hasDragged) || "scrollbar" === t10.trigger) && (s10 = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o2 = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (n2 = this.fixedExtreme), this.zoomedMax === this.size && (n2 = this.reversedExtremes ? s10.dataMin : s10.dataMax), 0 === this.zoomedMin && (o2 = this.reversedExtremes ? s10.dataMax : s10.dataMin), es((r2 = l2.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o2, n2)).min) && el(this, "setRange", { min: Math.min(r2.min, r2.max), max: Math.max(r2.min, r2.max), redraw: true, animation: !this.hasDragged && null, eventArguments: { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: d2 } })), "mousemove" !== t10.DOMType && "touchmove" !== t10.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && ed(this.zoomedMin) && ed(this.zoomedMax) && (i10 = Math.round(this.zoomedMin), e10 = Math.round(this.zoomedMax), this.shades && this.drawMasks(i10, e10, p2, c2), this.outline && this.drawOutline(i10, e10, p2, c2), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i10, 0, p2, c2), this.drawHandle(e10, 1, p2, c2)));
        }
        removeEvents() {
          this.eventsToUnbind && (this.eventsToUnbind.forEach(function(t10) {
            t10();
          }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();
        }
        removeBaseSeriesEvents() {
          let t10 = this.baseSeries || [];
          this.navigatorEnabled && t10[0] && (false !== this.navigatorOptions.adaptToUpdatedData && t10.forEach(function(t11) {
            eu(t11, "updatedData", this.updatedDataHandler);
          }, this), t10[0].xAxis && eu(t10[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
        }
        getXAxisOffsets() {
          return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];
        }
        init(t10) {
          var _a;
          let e10 = t10.options, i10 = e10.navigator || {}, s10 = i10.enabled, o2 = e10.scrollbar || {}, n2 = o2.enabled, r2 = s10 && i10.height || 0, a2 = n2 && o2.height || 0, l2 = o2.buttonsEnabled && a2 || 0;
          this.handles = [], this.shades = [], this.chart = t10, this.setBaseSeries(), this.height = r2, this.scrollbarHeight = a2, this.scrollButtonSize = l2, this.scrollbarEnabled = n2, this.navigatorEnabled = s10, this.navigatorOptions = i10, this.scrollbarOptions = o2, this.setOpposite();
          let h2 = this, d2 = h2.baseSeries, p2 = t10.xAxis.length, c2 = t10.yAxis.length, u2 = d2 && d2[0] && d2[0].xAxis || t10.xAxis[0] || { options: {} };
          if (t10.isDirtyBox = true, h2.navigatorEnabled) {
            let e11 = this.getXAxisOffsets();
            h2.xAxis = new (D())(t10, ep({ breaks: u2.options.breaks, ordinal: u2.options.ordinal, overscroll: u2.options.overscroll }, i10.xAxis, { type: "datetime", yAxis: (_a = i10.yAxis) == null ? void 0 : _a.id, index: p2, isInternal: true, offset: 0, keepOrdinalPadding: true, startOnTick: false, endOnTick: false, minPadding: u2.options.ordinal ? 0 : u2.options.minPadding, maxPadding: u2.options.ordinal ? 0 : u2.options.maxPadding, zoomEnabled: false }, t10.inverted ? { offsets: e11, width: r2 } : { offsets: e11, height: r2 }), "xAxis"), h2.yAxis = new (D())(t10, ep(i10.yAxis, { alignTicks: false, offset: 0, index: c2, isInternal: true, reversed: ec(i10.yAxis && i10.yAxis.reversed, t10.yAxis[0] && t10.yAxis[0].reversed, false), zoomEnabled: false }, t10.inverted ? { width: r2 } : { height: r2 }), "yAxis"), d2 || i10.series.data ? h2.updateNavigatorSeries(false) : 0 === t10.series.length && (h2.unbindRedraw = et(t10, "beforeRedraw", function() {
              t10.series.length > 0 && !h2.series && (h2.setBaseSeries(), h2.unbindRedraw());
            })), h2.reversedExtremes = t10.inverted && !h2.xAxis.reversed || !t10.inverted && h2.xAxis.reversed, h2.renderElements(), h2.addMouseEvents();
          } else h2.xAxis = { chart: t10, navigatorAxis: { fake: true }, translate: function(e11, i11) {
            let s11 = t10.xAxis[0], o3 = s11.getExtremes(), n3 = s11.len - 2 * l2, r3 = em("min", s11.options.min, o3.dataMin), a3 = em("max", s11.options.max, o3.dataMax) - r3;
            return i11 ? e11 * a3 / n3 + r3 : n3 * (e11 - r3) / a3;
          }, toPixels: function(t11) {
            return this.translate(t11);
          }, toValue: function(t11) {
            return this.translate(t11, true);
          } }, h2.xAxis.navigatorAxis.axis = h2.xAxis, h2.xAxis.navigatorAxis.toFixedRange = tg.prototype.toFixedRange.bind(h2.xAxis.navigatorAxis);
          if (t10.options.scrollbar.enabled) {
            let e11 = ep(t10.options.scrollbar, { vertical: t10.inverted });
            !ed(e11.margin) && h2.navigatorEnabled && (e11.margin = t10.inverted ? -3 : 3), t10.scrollbar = h2.scrollbar = new t3(t10.renderer, e11, t10), et(h2.scrollbar, "changed", function(t11) {
              let e12 = h2.size, i11 = e12 * this.to, s11 = e12 * this.from;
              h2.hasDragged = h2.scrollbar.hasDragged, h2.render(0, 0, s11, i11), this.shouldUpdateExtremes(t11.DOMType) && setTimeout(function() {
                h2.onMouseUp(t11);
              });
            });
          }
          h2.addBaseSeriesEvents(), h2.addChartEvents();
        }
        setOpposite() {
          let t10 = this.navigatorOptions, e10 = this.navigatorEnabled, i10 = this.chart;
          this.opposite = ec(t10.opposite, !!(!e10 && i10.inverted));
        }
        getUnionExtremes(t10) {
          let e10;
          let i10 = this.chart.xAxis[0], s10 = this.chart.time, o2 = this.xAxis, n2 = o2.options, r2 = i10.options;
          return t10 && null === i10.dataMin || (e10 = { dataMin: ec(s10.parse(n2 == null ? void 0 : n2.min), em("min", s10.parse(r2.min), i10.dataMin, o2.dataMin, o2.min)), dataMax: ec(s10.parse(n2 == null ? void 0 : n2.max), em("max", s10.parse(r2.max), i10.dataMax, o2.dataMax, o2.max)) }), e10;
        }
        setBaseSeries(t10, e10) {
          let i10 = this.chart, s10 = this.baseSeries = [];
          t10 = t10 || i10.options && i10.options.navigator.baseSeries || (i10.series.length ? ea(i10.series, (t11) => !t11.options.isInternal).index : 0), (i10.series || []).forEach((e11, i11) => {
            !e11.options.isInternal && (e11.options.showInNavigator || (i11 === t10 || e11.options.id === t10) && false !== e11.options.showInNavigator) && s10.push(e11);
          }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(true, e10);
        }
        updateNavigatorSeries(t10, e10) {
          var _a, _b;
          let i10 = this, s10 = i10.chart, o2 = i10.baseSeries, n2 = { enableMouseTracking: false, index: null, linkedTo: null, group: "nav", padXAxis: false, xAxis: (_a = this.navigatorOptions.xAxis) == null ? void 0 : _a.id, yAxis: (_b = this.navigatorOptions.yAxis) == null ? void 0 : _b.id, showInLegend: false, stacking: void 0, isInternal: true, states: { inactive: { opacity: 1 } } }, r2 = i10.series = (i10.series || []).filter((t11) => {
            let e11 = t11.baseSeries;
            return !(0 > o2.indexOf(e11)) || (e11 && (eu(e11, "updatedData", i10.updatedDataHandler), delete e11.navigatorSeries), t11.chart && t11.destroy(), false);
          }), a2, l2, h2 = i10.navigatorOptions.series, d2;
          o2 && o2.length && o2.forEach((t11) => {
            var _a2;
            let p2 = t11.navigatorSeries, c2 = er({ color: t11.color, visible: t11.visible }, eh(h2) ? t8.navigator.series : h2);
            if (p2 && false === i10.navigatorOptions.adaptToUpdatedData) return;
            n2.name = "Navigator " + o2.length, d2 = (a2 = t11.options || {}).navigatorOptions || {}, c2.dataLabels = eg(c2.dataLabels), (l2 = ep(a2, n2, c2, d2)).pointRange = ec(c2.pointRange, d2.pointRange, t8.plotOptions[l2.type || "line"].pointRange);
            let u2 = d2.data || c2.data;
            i10.hasNavigatorData = i10.hasNavigatorData || !!u2, l2.data = u2 || ((_a2 = a2.data) == null ? void 0 : _a2.slice(0)), p2 && p2.options ? p2.update(l2, e10) : (t11.navigatorSeries = s10.initSeries(l2), s10.setSortedData(), t11.navigatorSeries.baseSeries = t11, r2.push(t11.navigatorSeries));
          }), (h2.data && !(o2 && o2.length) || eh(h2)) && (i10.hasNavigatorData = false, (h2 = eg(h2)).forEach((t11, e11) => {
            n2.name = "Navigator " + (r2.length + 1), (l2 = ep(t8.navigator.series, { color: s10.series[e11] && !s10.series[e11].options.isInternal && s10.series[e11].color || s10.options.colors[e11] || s10.options.colors[0] }, n2, t11)).data = t11.data, l2.data && (i10.hasNavigatorData = true, r2.push(s10.initSeries(l2)));
          })), t10 && this.addBaseSeriesEvents();
        }
        addBaseSeriesEvents() {
          let t10 = this, e10 = t10.baseSeries || [];
          e10[0] && e10[0].xAxis && e10[0].eventsToUnbind.push(et(e10[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), e10.forEach((i10) => {
            i10.eventsToUnbind.push(et(i10, "show", function() {
              this.navigatorSeries && this.navigatorSeries.setVisible(true, false);
            })), i10.eventsToUnbind.push(et(i10, "hide", function() {
              this.navigatorSeries && this.navigatorSeries.setVisible(false, false);
            })), false !== this.navigatorOptions.adaptToUpdatedData && i10.xAxis && i10.eventsToUnbind.push(et(i10, "updatedData", this.updatedDataHandler)), i10.eventsToUnbind.push(et(i10, "remove", function() {
              e10 && en(e10, i10), this.navigatorSeries && t10.series && (en(t10.series, this.navigatorSeries), es(this.navigatorSeries.options) && this.navigatorSeries.remove(false), delete this.navigatorSeries);
            }));
          });
        }
        getBaseSeriesMin(t10) {
          return this.baseSeries.reduce(function(t11, e10) {
            return Math.min(t11, e10.getColumn("x")[0] ?? t11);
          }, t10);
        }
        modifyNavigatorAxisExtremes() {
          let t10 = this.xAxis;
          if (void 0 !== t10.getExtremes) {
            let e10 = this.getUnionExtremes(true);
            e10 && (e10.dataMin !== t10.min || e10.dataMax !== t10.max) && (t10.min = e10.dataMin, t10.max = e10.dataMax);
          }
        }
        modifyBaseAxisExtremes() {
          var _a;
          let t10, e10;
          let i10 = this.chart.navigator, s10 = this.getExtremes(), o2 = s10.min, n2 = s10.max, r2 = s10.dataMin, a2 = s10.dataMax, l2 = n2 - o2, h2 = i10.stickToMin, d2 = i10.stickToMax, p2 = ec((_a = this.ordinal) == null ? void 0 : _a.convertOverscroll(this.options.overscroll), 0), c2 = i10.series && i10.series[0], u2 = !!this.setExtremes;
          !(this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger) && (h2 && (t10 = (e10 = r2) + l2), d2 && (t10 = a2 + p2, h2 || (e10 = Math.max(r2, t10 - l2, i10.getBaseSeriesMin(c2 && c2.xData ? c2.xData[0] : -Number.MAX_VALUE)))), u2 && (h2 || d2) && ed(e10) && (this.min = this.userMin = e10, this.max = this.userMax = t10)), i10.stickToMin = i10.stickToMax = null;
        }
        updatedDataHandler() {
          let t10 = this.chart.navigator, e10 = this.navigatorSeries, i10 = t10.reversedExtremes ? 0 === Math.round(t10.zoomedMin) : Math.round(t10.zoomedMax) >= Math.round(t10.size);
          t10.stickToMax = ec(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i10), t10.stickToMin = t10.shouldStickToMin(this, t10), e10 && !t10.hasNavigatorData && (e10.options.pointStart = this.getColumn("x")[0], e10.setData(this.options.data, false, null, false));
        }
        shouldStickToMin(t10, e10) {
          let i10 = e10.getBaseSeriesMin(t10.getColumn("x")[0]), s10 = t10.xAxis, o2 = s10.max, n2 = s10.min, r2 = s10.options.range;
          return !!(ed(o2) && ed(n2)) && (r2 && o2 - i10 > 0 ? o2 - i10 < r2 : n2 <= i10);
        }
        addChartEvents() {
          this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(et(this.chart, "redraw", function() {
            let t10 = this.navigator, e10 = t10 && (t10.baseSeries && t10.baseSeries[0] && t10.baseSeries[0].xAxis || this.xAxis[0]);
            e10 && t10.render(e10.min, e10.max);
          }), et(this.chart, "getMargins", function() {
            let t10 = this.navigator, e10 = t10.opposite ? "plotTop" : "marginBottom";
            this.inverted && (e10 = t10.opposite ? "marginRight" : "plotLeft"), this[e10] = (this[e10] || 0) + (t10.navigatorEnabled || !this.inverted ? t10.height + t10.scrollbarHeight : 0) + t10.navigatorOptions.margin;
          }), et(ef, "setRange", function(t10) {
            this.chart.xAxis[0].setExtremes(t10.min, t10.max, t10.redraw, t10.animation, t10.eventArguments);
          }));
        }
        destroy() {
          this.removeEvents(), this.xAxis && (en(this.chart.xAxis, this.xAxis), en(this.chart.axes, this.xAxis)), this.yAxis && (en(this.chart.yAxis, this.yAxis), en(this.chart.axes, this.yAxis)), (this.series || []).forEach((t10) => {
            t10.destroy && t10.destroy();
          }), ["series", "xAxis", "yAxis", "shades", "outline", "scrollbarTrack", "scrollbarRifles", "scrollbarGroup", "scrollbar", "navigatorGroup", "rendered"].forEach((t10) => {
            this[t10] && this[t10].destroy && this[t10].destroy(), this[t10] = null;
          }), [this.handles].forEach((t10) => {
            eo(t10);
          }), this.navigatorEnabled = false;
        }
      }
      let { fireEvent: ex, isArray: eb, objectEach: ev, uniqueKey: ey } = B(), eM = class {
        constructor(t10 = {}) {
          this.autoId = !t10.id, this.columns = {}, this.id = t10.id || ey(), this.modified = this, this.rowCount = 0, this.versionTag = ey();
          let e10 = 0;
          ev(t10.columns || {}, (t11, i10) => {
            this.columns[i10] = t11.slice(), e10 = Math.max(e10, t11.length);
          }), this.applyRowCount(e10);
        }
        applyRowCount(t10) {
          this.rowCount = t10, ev(this.columns, (e10) => {
            eb(e10) && (e10.length = t10);
          });
        }
        getColumn(t10, e10) {
          return this.columns[t10];
        }
        getColumns(t10, e10) {
          return (t10 || Object.keys(this.columns)).reduce((t11, e11) => (t11[e11] = this.columns[e11], t11), {});
        }
        getRow(t10, e10) {
          return (e10 || Object.keys(this.columns)).map((e11) => {
            var _a;
            return (_a = this.columns[e11]) == null ? void 0 : _a[t10];
          });
        }
        setColumn(t10, e10 = [], i10 = 0, s10) {
          this.setColumns({ [t10]: e10 }, i10, s10);
        }
        setColumns(t10, e10, i10) {
          let s10 = this.rowCount;
          ev(t10, (t11, e11) => {
            this.columns[e11] = t11.slice(), s10 = t11.length;
          }), this.applyRowCount(s10), (i10 == null ? void 0 : i10.silent) || (ex(this, "afterSetColumns"), this.versionTag = ey());
        }
        setRow(t10, e10 = this.rowCount, i10, s10) {
          let { columns: o2 } = this, n2 = i10 ? this.rowCount + 1 : e10 + 1;
          ev(t10, (t11, r2) => {
            let a2 = o2[r2] || (s10 == null ? void 0 : s10.addColumns) !== false && Array(n2);
            a2 && (i10 ? a2.splice(e10, 0, t11) : a2[e10] = t11, o2[r2] = a2);
          }), n2 > this.rowCount && this.applyRowCount(n2), (s10 == null ? void 0 : s10.silent) || (ex(this, "afterSetRows"), this.versionTag = ey());
        }
      }, { addEvent: eA, correctFloat: ek, css: ew, defined: eS, error: eE, isNumber: eC, pick: eT, timeUnits: eB, isString: eO } = B();
      !function(t10) {
        function e10(t11, i11, s11, o3, n3 = [], r3 = 0, a3) {
          let l3 = {}, h3 = this.options.tickPixelInterval, d3 = this.chart.time, p3 = [], c2, u2, g2, m2, f2, x2 = 0, b2 = [], v2 = -Number.MAX_VALUE;
          if (!this.options.ordinal && !this.options.breaks || !n3 || n3.length < 3 || void 0 === i11) return d3.getTimeTicks.apply(d3, arguments);
          let y2 = n3.length;
          for (c2 = 0; c2 < y2; c2++) {
            if (f2 = c2 && n3[c2 - 1] > s11, n3[c2] < i11 && (x2 = c2), c2 === y2 - 1 || n3[c2 + 1] - n3[c2] > 5 * r3 || f2) {
              if (n3[c2] > v2) {
                for (u2 = d3.getTimeTicks(t11, n3[x2], n3[c2], o3); u2.length && u2[0] <= v2; ) u2.shift();
                u2.length && (v2 = u2[u2.length - 1]), p3.push(b2.length), b2 = b2.concat(u2);
              }
              x2 = c2 + 1;
            }
            if (f2) break;
          }
          if (u2) {
            if (m2 = u2.info, a3 && m2.unitRange <= eB.hour) {
              for (x2 = 1, c2 = b2.length - 1; x2 < c2; x2++) d3.dateFormat("%d", b2[x2]) !== d3.dateFormat("%d", b2[x2 - 1]) && (l3[b2[x2]] = "day", g2 = true);
              g2 && (l3[b2[0]] = "day"), m2.higherRanks = l3;
            }
            m2.segmentStarts = p3, b2.info = m2;
          } else eE(12, false, this.chart);
          if (a3 && eS(h3)) {
            let t12 = b2.length, e11 = [], i12 = [], o4, n4, r4, a4, d4, p4 = t12;
            for (; p4--; ) n4 = this.translate(b2[p4]), r4 && (i12[p4] = r4 - n4), e11[p4] = r4 = n4;
            for (i12.sort((t13, e12) => t13 - e12), (a4 = i12[Math.floor(i12.length / 2)]) < 0.6 * h3 && (a4 = null), p4 = b2[t12 - 1] > s11 ? t12 - 1 : t12, r4 = void 0; p4--; ) d4 = Math.abs(r4 - (n4 = e11[p4])), r4 && d4 < 0.8 * h3 && (null === a4 || d4 < 0.8 * a4) ? (l3[b2[p4]] && !l3[b2[p4 + 1]] ? (o4 = p4 + 1, r4 = n4) : o4 = p4, b2.splice(o4, 1)) : r4 = n4;
          }
          return b2;
        }
        function i10(t11) {
          let e11 = this.ordinal.positions;
          if (!e11) return t11;
          let i11 = e11.length - 1, s11;
          return (t11 < 0 ? t11 = e11[0] : t11 > i11 ? t11 = e11[i11] : (i11 = Math.floor(t11), s11 = t11 - i11), void 0 !== s11 && void 0 !== e11[i11]) ? e11[i11] + (s11 ? s11 * (e11[i11 + 1] - e11[i11]) : 0) : t11;
        }
        function s10(t11) {
          let e11 = this.ordinal, i11 = this.old ? this.old.min : this.min, s11 = this.old ? this.old.transA : this.transA, o3 = e11.getExtendedPositions();
          if (o3 == null ? void 0 : o3.length) {
            let n3 = ek((t11 - i11) * s11 + this.minPixelPadding), r3 = ek(e11.getIndexOfPoint(n3, o3)), a3 = ek(r3 % 1);
            if (r3 >= 0 && r3 <= o3.length - 1) {
              let t12 = o3[Math.floor(r3)], e12 = o3[Math.ceil(r3)];
              return o3[Math.floor(r3)] + a3 * (e12 - t12);
            }
          }
          return t11;
        }
        function o2(e11, i11) {
          let s11 = t10.Additions.findIndexOf(e11, i11, true);
          if (e11[s11] === i11) return s11;
          let o3 = (i11 - e11[s11]) / (e11[s11 + 1] - e11[s11]);
          return s11 + o3;
        }
        function n2() {
          this.ordinal || (this.ordinal = new t10.Additions(this));
        }
        function r2() {
          let { eventArgs: t11, options: e11 } = this;
          if (this.isXAxis && eS(e11.overscroll) && 0 !== e11.overscroll && eC(this.max) && eC(this.min) && (this.options.ordinal && !this.ordinal.originalOrdinalRange && this.ordinal.getExtendedPositions(false), this.max === this.dataMax && ((t11 == null ? void 0 : t11.trigger) !== "pan" || this.isInternal) && (t11 == null ? void 0 : t11.trigger) !== "navigator")) {
            let i11 = this.ordinal.convertOverscroll(e11.overscroll);
            this.max += i11, !this.isInternal && eS(this.userMin) && (t11 == null ? void 0 : t11.trigger) !== "mousewheel" && (this.min += i11);
          }
        }
        function a2() {
          this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
        }
        function l2() {
          this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
        }
        function h2(t11) {
          let e11 = this.xAxis[0], i11 = e11.ordinal.convertOverscroll(e11.options.overscroll), s11 = t11.originalEvent.chartX, o3 = this.options.chart.panning, n3 = false;
          if (o3 && "y" !== o3.type && e11.options.ordinal && e11.series.length && (!t11.touches || t11.touches.length <= 1)) {
            let t12, o4;
            let r3 = this.mouseDownX, a3 = e11.getExtremes(), l3 = a3.dataMin, h3 = a3.dataMax, d3 = a3.min, p3 = a3.max, c2 = this.hoverPoints, u2 = e11.closestPointRange || e11.ordinal && e11.ordinal.overscrollPointsRange, g2 = Math.round((r3 - s11) / (e11.translationSlope * (e11.ordinal.slope || u2))), m2 = e11.ordinal.getExtendedPositions(), f2 = { ordinal: { positions: m2, extendedOrdinalPositions: m2 } }, x2 = e11.index2val, b2 = e11.val2lin;
            if (d3 <= l3 && g2 < 0 || p3 + i11 >= h3 && g2 > 0) return;
            f2.ordinal.positions ? Math.abs(g2) > 1 && (c2 && c2.forEach(function(t13) {
              t13.setState();
            }), h3 > (o4 = f2.ordinal.positions)[o4.length - 1] && o4.push(h3), this.setFixedRange(p3 - d3), (t12 = e11.navigatorAxis.toFixedRange(void 0, void 0, x2.apply(f2, [b2.apply(f2, [d3, true]) + g2]), x2.apply(f2, [b2.apply(f2, [p3, true]) + g2]))).min >= Math.min(o4[0], d3) && t12.max <= Math.max(o4[o4.length - 1], p3) + i11 && e11.setExtremes(t12.min, t12.max, true, false, { trigger: "pan" }), this.mouseDownX = s11, ew(this.container, { cursor: "move" })) : n3 = true;
          } else n3 = true;
          n3 || o3 && /y/.test(o3.type) ? i11 && (e11.max = e11.dataMax + i11) : t11.preventDefault();
        }
        function d2() {
          let t11 = this.xAxis;
          t11 && t11.options.ordinal && (delete t11.ordinal.index, delete t11.ordinal.originalOrdinalRange);
        }
        function p2(t11, e11) {
          let i11;
          let s11 = this.ordinal, n3 = s11.positions, r3 = s11.slope, a3;
          if (!n3) return t11;
          let l3 = n3.length;
          if (n3[0] <= t11 && n3[l3 - 1] >= t11) i11 = o2(n3, t11);
          else {
            if (!((a3 = s11.getExtendedPositions && s11.getExtendedPositions()) && a3.length)) return t11;
            let l4 = a3.length;
            r3 || (r3 = (a3[l4 - 1] - a3[0]) / l4);
            let h3 = o2(a3, n3[0]);
            if (t11 >= a3[0] && t11 <= a3[l4 - 1]) i11 = o2(a3, t11) - h3;
            else {
              if (!e11) return t11;
              i11 = t11 < a3[0] ? -h3 - (a3[0] - t11) / r3 : (t11 - a3[l4 - 1]) / r3 + l4 - h3;
            }
          }
          return e11 ? i11 : r3 * (i11 || 0) + s11.offset;
        }
        t10.compose = function(t11, o3, c2) {
          let u2 = t11.prototype;
          return u2.ordinal2lin || (u2.getTimeTicks = e10, u2.index2val = i10, u2.lin2val = s10, u2.val2lin = p2, u2.ordinal2lin = u2.val2lin, eA(t11, "afterInit", n2), eA(t11, "foundExtremes", r2), eA(t11, "afterSetScale", a2), eA(t11, "initialAxisTranslation", l2), eA(c2, "pan", h2), eA(c2, "touchpan", h2), eA(o3, "updatedData", d2)), t11;
        }, t10.Additions = class {
          constructor(t11) {
            this.index = {}, this.axis = t11;
          }
          beforeSetTickPositions() {
            var _a;
            let t11 = this.axis, e11 = t11.ordinal, i11 = t11.getExtremes(), s11 = i11.min, o3 = i11.max, n3 = (_a = t11.brokenAxis) == null ? void 0 : _a.hasBreaks, r3 = t11.options.ordinal, a3, l3, h3, d3, p3, c2, u2, g2 = [], m2 = Number.MAX_VALUE, f2 = false, x2 = false, b2 = false;
            if (r3 || n3) {
              let i12 = 0;
              if (t11.series.forEach(function(t12, e12) {
                let s12 = t12.getColumn("x", true);
                if (l3 = [], e12 > 0 && "highcharts-navigator-series" !== t12.options.id && s12.length > 1 && (x2 = i12 !== s12[1] - s12[0]), i12 = s12[1] - s12[0], t12.boosted && (b2 = t12.boosted), t12.reserveSpace() && (false !== t12.takeOrdinalPosition || n3) && (a3 = (g2 = g2.concat(s12)).length, g2.sort(function(t13, e13) {
                  return t13 - e13;
                }), m2 = Math.min(m2, eT(t12.closestPointRange, m2)), a3)) {
                  for (e12 = 0; e12 < a3 - 1; ) g2[e12] !== g2[e12 + 1] && l3.push(g2[e12 + 1]), e12++;
                  l3[0] !== g2[0] && l3.unshift(g2[0]), g2 = l3;
                }
              }), t11.ordinal.originalOrdinalRange || (t11.ordinal.originalOrdinalRange = (g2.length - 1) * m2), x2 && b2 && (g2.pop(), g2.shift()), (a3 = g2.length) > 2) {
                for (h3 = g2[1] - g2[0], u2 = a3 - 1; u2-- && !f2; ) g2[u2 + 1] - g2[u2] !== h3 && (f2 = true);
                !t11.options.keepOrdinalPadding && (g2[0] - s11 > h3 || o3 - g2[g2.length - 1] > h3) && (f2 = true);
              } else t11.options.overscroll && (2 === a3 ? m2 = g2[1] - g2[0] : 1 === a3 ? (m2 = t11.ordinal.convertOverscroll(t11.options.overscroll), g2 = [g2[0], g2[0] + m2]) : m2 = e11.overscrollPointsRange);
              f2 || t11.forceOrdinal ? (t11.options.overscroll && (e11.overscrollPointsRange = m2, g2 = g2.concat(e11.getOverscrollPositions())), e11.positions = g2, d3 = t11.ordinal2lin(Math.max(s11, g2[0]), true), p3 = Math.max(t11.ordinal2lin(Math.min(o3, g2[g2.length - 1]), true), 1), e11.slope = c2 = (o3 - s11) / (p3 - d3), e11.offset = s11 - d3 * c2) : (e11.overscrollPointsRange = eT(t11.closestPointRange, e11.overscrollPointsRange), e11.positions = t11.ordinal.slope = e11.offset = void 0);
            }
            t11.isOrdinal = r3 && f2, e11.groupIntervalFactor = null;
          }
          static findIndexOf(t11, e11, i11) {
            let s11 = 0, o3 = t11.length - 1, n3;
            for (; s11 < o3; ) t11[n3 = Math.ceil((s11 + o3) / 2)] <= e11 ? s11 = n3 : o3 = n3 - 1;
            return t11[s11] === e11 ? s11 : i11 ? s11 : -1;
          }
          getExtendedPositions(t11 = true) {
            let e11 = this, i11 = e11.axis, s11 = i11.constructor.prototype, o3 = i11.chart, n3 = i11.series.reduce((t12, e12) => {
              let i12 = e12.currentDataGrouping;
              return t12 + (i12 ? i12.count + i12.unitName : "raw");
            }, ""), r3 = t11 ? i11.ordinal.convertOverscroll(i11.options.overscroll) : 0, a3 = i11.getExtremes(), l3, h3, d3 = e11.index;
            return d3 || (d3 = e11.index = {}), !d3[n3] && ((l3 = { series: [], chart: o3, forceOrdinal: false, getExtremes: function() {
              return { min: a3.dataMin, max: a3.dataMax + r3 };
            }, applyGrouping: s11.applyGrouping, getGroupPixelWidth: s11.getGroupPixelWidth, getTimeTicks: s11.getTimeTicks, options: { ordinal: true }, ordinal: { getGroupIntervalFactor: this.getGroupIntervalFactor }, ordinal2lin: s11.ordinal2lin, getIndexOfPoint: s11.getIndexOfPoint, val2lin: s11.val2lin }).ordinal.axis = l3, i11.series.forEach((i12) => {
              var _a, _b, _c;
              h3 = { xAxis: l3, chart: o3, groupPixelWidth: i12.groupPixelWidth, destroyGroupedData: B().noop, getColumn: i12.getColumn, applyGrouping: i12.applyGrouping, getProcessedData: i12.getProcessedData, reserveSpace: i12.reserveSpace, visible: i12.visible };
              let s12 = i12.getColumn("x").concat(t11 ? e11.getOverscrollPositions() : []);
              h3.dataTable = new eM({ columns: { x: s12 } }), h3.options = { ...i12.options, dataGrouping: i12.currentDataGrouping ? { firstAnchor: (_a = i12.options.dataGrouping) == null ? void 0 : _a.firstAnchor, anchor: (_b = i12.options.dataGrouping) == null ? void 0 : _b.anchor, lastAnchor: (_c = i12.options.dataGrouping) == null ? void 0 : _c.firstAnchor, enabled: true, forced: true, approximation: "open", units: [[i12.currentDataGrouping.unitName, [i12.currentDataGrouping.count]]] } : { enabled: false } }, l3.series.push(h3), i12.processData.apply(h3);
            }), l3.applyGrouping({ hasExtremesChanged: true }), (h3 == null ? void 0 : h3.closestPointRange) !== (h3 == null ? void 0 : h3.basePointRange) && h3.currentDataGrouping && (l3.forceOrdinal = true), i11.ordinal.beforeSetTickPositions.apply({ axis: l3 }), !i11.ordinal.originalOrdinalRange && l3.ordinal.originalOrdinalRange && (i11.ordinal.originalOrdinalRange = l3.ordinal.originalOrdinalRange), l3.ordinal.positions && (d3[n3] = l3.ordinal.positions)), d3[n3];
          }
          getGroupIntervalFactor(t11, e11, i11) {
            let s11 = i11.getColumn("x", true), o3 = s11.length, n3 = [], r3, a3, l3 = this.groupIntervalFactor;
            if (!l3) {
              for (a3 = 0; a3 < o3 - 1; a3++) n3[a3] = s11[a3 + 1] - s11[a3];
              n3.sort(function(t12, e12) {
                return t12 - e12;
              }), r3 = n3[Math.floor(o3 / 2)], t11 = Math.max(t11, s11[0]), e11 = Math.min(e11, s11[o3 - 1]), this.groupIntervalFactor = l3 = o3 * r3 / (e11 - t11);
            }
            return l3;
          }
          getIndexOfPoint(t11, e11) {
            let i11 = this.axis, s11 = i11.min, n3 = i11.minPixelPadding;
            return o2(e11, s11) + ek((t11 - n3) / (i11.translationSlope * (this.slope || i11.closestPointRange || this.overscrollPointsRange)));
          }
          getOverscrollPositions() {
            let t11 = this.axis, e11 = this.convertOverscroll(t11.options.overscroll), i11 = this.overscrollPointsRange, s11 = [], o3 = t11.dataMax;
            if (eS(i11)) for (; o3 < t11.dataMax + e11; ) s11.push(o3 += i11);
            return s11;
          }
          postProcessTickInterval(t11) {
            let e11 = this.axis, i11 = this.slope, s11 = e11.closestPointRange;
            return i11 && s11 ? e11.options.breaks ? s11 || t11 : t11 / (i11 / s11) : t11;
          }
          convertOverscroll(t11 = 0) {
            let e11 = this, i11 = e11.axis, s11 = function(t12) {
              return eT(e11.originalOrdinalRange, eS(i11.dataMax) && eS(i11.dataMin) ? i11.dataMax - i11.dataMin : 0) * t12;
            };
            if (eO(t11)) {
              let e12 = parseInt(t11, 10);
              if (/%$/.test(t11)) return s11(e12 / 100);
              if (/px/.test(t11)) {
                let t12 = Math.min(e12, 0.9 * i11.len) / i11.len;
                return s11(t12 / (1 - t12));
              }
              return 0;
            }
            return t11;
          }
        };
      }(v || (v = {}));
      let eD = v, eP = { lang: { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "", rangeSelectorTo: "" }, rangeSelector: { allButtonsEnabled: false, buttons: [{ type: "month", count: 1, text: "1m", title: "View 1 month" }, { type: "month", count: 3, text: "3m", title: "View 3 months" }, { type: "month", count: 6, text: "6m", title: "View 6 months" }, { type: "ytd", text: "YTD", title: "View year to date" }, { type: "year", count: 1, text: "1y", title: "View 1 year" }, { type: "all", text: "All", title: "View all" }], buttonSpacing: 5, dropdown: "responsive", enabled: void 0, verticalAlign: "top", buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 }, floating: false, x: 0, y: 0, height: void 0, inputBoxBorderColor: "none", inputBoxHeight: 17, inputBoxWidth: void 0, inputDateFormat: "%[ebY]", inputDateParser: void 0, inputEditDateFormat: "%Y-%m-%d", inputEnabled: true, inputPosition: { align: "right", x: 0, y: 0 }, inputSpacing: 5, selected: void 0, buttonPosition: { align: "left", x: 0, y: 0 }, inputStyle: { color: "#334eff", cursor: "pointer", fontSize: "0.8em" }, labelStyle: { color: "#666666", fontSize: "0.8em" } } }, { defaultOptions: eR } = B(), { composed: eG } = B(), { addEvent: eI, defined: ez, extend: eL, isNumber: eW, merge: eH, pick: eX, pushUnique: eY } = B(), eN = [];
      function eF() {
        let t10, e10;
        let i10 = this.range, s10 = i10.type, o2 = this.max, n2 = this.chart.time, r2 = function(t11, e11) {
          let i11 = n2.toParts(t11), o3 = i11.slice();
          "year" === s10 ? o3[0] += e11 : o3[1] += e11;
          let r3 = n2.makeTime.apply(n2, o3), a3 = n2.toParts(r3);
          return "month" === s10 && i11[1] === a3[1] && 1 === Math.abs(e11) && (o3[0] = i11[0], o3[1] = i11[1], o3[2] = 0), (r3 = n2.makeTime.apply(n2, o3)) - t11;
        };
        eW(i10) ? (t10 = o2 - i10, e10 = i10) : i10 && (t10 = o2 + r2(o2, -(i10.count || 1)), this.chart && this.chart.setFixedRange(o2 - t10));
        let a2 = eX(this.dataMin, Number.MIN_VALUE);
        return eW(t10) || (t10 = a2), t10 <= a2 && (t10 = a2, void 0 === e10 && (e10 = r2(t10, i10.count)), this.newMax = Math.min(t10 + e10, eX(this.dataMax, Number.MAX_VALUE))), eW(o2) ? !eW(i10) && i10 && i10._offsetMin && (t10 += i10._offsetMin) : t10 = void 0, t10;
      }
      function eU() {
        var _a;
        (_a = this.rangeSelector) == null ? void 0 : _a.redrawElements();
      }
      function e_() {
        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new g(this));
      }
      function eV() {
        let t10 = this.rangeSelector;
        if (t10) {
          eW(t10.deferredYTDClick) && (t10.clickButton(t10.deferredYTDClick), delete t10.deferredYTDClick);
          let e10 = t10.options.verticalAlign;
          t10.options.floating || ("bottom" === e10 ? this.extraBottomMargin = true : "top" !== e10 || (this.extraTopMargin = true));
        }
      }
      function eZ() {
        let t10;
        let e10 = this.rangeSelector;
        if (!e10) return;
        let i10 = this.xAxis[0].getExtremes(), s10 = this.legend, o2 = e10 && e10.options.verticalAlign;
        eW(i10.min) && e10.render(i10.min, i10.max), s10.display && "top" === o2 && o2 === s10.options.verticalAlign && (t10 = eH(this.spacingBox), "vertical" === s10.options.layout ? t10.y = this.plotTop : t10.y += e10.getHeight(), s10.group.placed = false, s10.align(t10));
      }
      function ej() {
        for (let t10 = 0, e10 = eN.length; t10 < e10; ++t10) {
          let e11 = eN[t10];
          if (e11[0] === this) {
            e11[1].forEach((t11) => t11()), eN.splice(t10, 1);
            return;
          }
        }
      }
      function eK() {
        var _a;
        let t10 = this.rangeSelector;
        if ((_a = t10 == null ? void 0 : t10.options) == null ? void 0 : _a.enabled) {
          let e10 = t10.getHeight(), i10 = t10.options.verticalAlign;
          t10.options.floating || ("bottom" === i10 ? this.marginBottom += e10 : "middle" === i10 || (this.plotTop += e10));
        }
      }
      function eq(t10) {
        let e10 = t10.options.rangeSelector, i10 = this.extraBottomMargin, s10 = this.extraTopMargin, o2 = this.rangeSelector;
        if (e10 && e10.enabled && !ez(o2) && this.options.rangeSelector && (this.options.rangeSelector.enabled = true, this.rangeSelector = o2 = new g(this)), this.extraBottomMargin = false, this.extraTopMargin = false, o2) {
          let t11 = e10 && e10.verticalAlign || o2.options && o2.options.verticalAlign;
          o2.options.floating || ("bottom" === t11 ? this.extraBottomMargin = true : "middle" === t11 || (this.extraTopMargin = true)), (this.extraBottomMargin !== i10 || this.extraTopMargin !== s10) && (this.isDirtyBox = true);
        }
      }
      let e$ = { compose: function(t10, e10, i10) {
        if (g = i10, eY(eG, "RangeSelector")) {
          let i11 = e10.prototype;
          t10.prototype.minFromRange = eF, eI(e10, "afterGetContainer", e_), eI(e10, "beforeRender", eV), eI(e10, "destroy", ej), eI(e10, "getMargins", eK), eI(e10, "redraw", eZ), eI(e10, "update", eq), eI(e10, "beforeRedraw", eU), i11.callbacks.push(eZ), eL(eR, { rangeSelector: eP.rangeSelector }), eL(eR.lang, eP.lang);
        }
      } };
      var eJ = E(28), eQ = E.n(eJ);
      let { defaultOptions: e0 } = B(), { addEvent: e1, createElement: e2, css: e5, defined: e3, destroyObjectProperties: e6, diffObjects: e4, discardElement: e8, extend: e9, fireEvent: e7, isNumber: it, isString: ie, merge: ii, objectEach: is, pick: io, splat: ir } = B();
      function ia(t10) {
        let e10 = (e11) => RegExp(`%[[a-zA-Z]*${e11}`).test(t10);
        if (ie(t10) ? -1 !== t10.indexOf("%L") : t10.fractionalSecondDigits) return "text";
        let i10 = ie(t10) ? ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(e10) : t10.dateStyle || t10.day || t10.month || t10.year, s10 = ie(t10) ? ["H", "k", "I", "l", "M", "S"].some(e10) : t10.timeStyle || t10.hour || t10.minute || t10.second;
        return i10 && s10 ? "datetime-local" : i10 ? "date" : s10 ? "time" : "text";
      }
      class il {
        static compose(t10, e10) {
          e$.compose(t10, e10, il);
        }
        constructor(t10) {
          this.isDirty = false, this.buttonOptions = il.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.maxButtonWidth = () => {
            let t11 = 0;
            return this.buttons.forEach((e10) => {
              let i10 = e10.getBBox();
              i10.width > t11 && (t11 = i10.width);
            }), t11;
          }, this.init(t10);
        }
        clickButton(t10, e10) {
          let i10 = this.chart, s10 = this.buttonOptions[t10], o2 = i10.xAxis[0], n2 = i10.scroller && i10.scroller.getUnionExtremes() || o2 || {}, r2 = s10.type, a2 = s10.dataGrouping, l2 = n2.dataMin, h2 = n2.dataMax, d2, p2 = it(o2 == null ? void 0 : o2.max) ? Math.round(Math.min(o2.max, h2 ?? o2.max)) : void 0, c2, u2 = s10._range, g2, m2, f2, x2 = true;
          if (null !== l2 && null !== h2) {
            if (this.setSelected(t10), a2 && (this.forcedDataGrouping = true, D().prototype.setDataGrouping.call(o2 || { chart: this.chart }, a2, false), this.frozenStates = s10.preserveDataGrouping), "month" === r2 || "year" === r2) o2 ? (m2 = { range: s10, max: p2, chart: i10, dataMin: l2, dataMax: h2 }, d2 = o2.minFromRange.call(m2), it(m2.newMax) && (p2 = m2.newMax), x2 = false) : u2 = s10;
            else if (u2) it(p2) && (p2 = Math.min((d2 = Math.max(p2 - u2, l2)) + u2, h2), x2 = false);
            else if ("ytd" === r2) {
              if (o2) !o2.hasData() || it(h2) && it(l2) || (l2 = Number.MAX_VALUE, h2 = -Number.MAX_VALUE, i10.series.forEach((t11) => {
                let e11 = t11.getColumn("x");
                e11.length && (l2 = Math.min(e11[0], l2), h2 = Math.max(e11[e11.length - 1], h2));
              }), e10 = false), it(h2) && it(l2) && (d2 = g2 = (f2 = this.getYTDExtremes(h2, l2)).min, p2 = f2.max);
              else {
                this.deferredYTDClick = t10;
                return;
              }
            } else "all" === r2 && o2 && (i10.navigator && i10.navigator.baseSeries[0] && (i10.navigator.baseSeries[0].xAxis.options.range = void 0), d2 = l2, p2 = h2);
            if (x2 && s10._offsetMin && e3(d2) && (d2 += s10._offsetMin), s10._offsetMax && e3(p2) && (p2 += s10._offsetMax), this.dropdown && (this.dropdown.selectedIndex = t10 + 1), o2) it(d2) && it(p2) && (o2.setExtremes(d2, p2, io(e10, true), void 0, { trigger: "rangeSelectorButton", rangeSelectorButton: s10 }), i10.setFixedRange(s10._range));
            else {
              c2 = ir(i10.options.xAxis || {})[0];
              let t11 = e1(i10, "afterCreateAxes", function() {
                let t12 = i10.xAxis[0];
                t12.range = t12.options.range = u2, t12.min = t12.options.min = g2;
              });
              e1(i10, "load", function() {
                let e11 = i10.xAxis[0];
                i10.setFixedRange(s10._range), e11.options.range = c2.range, e11.options.min = c2.min, t11();
              });
            }
            e7(this, "afterBtnClick");
          }
        }
        setSelected(t10) {
          this.selected = this.options.selected = t10;
        }
        init(t10) {
          let e10 = this, i10 = t10.options.rangeSelector, s10 = i10.buttons, o2 = i10.selected, n2 = function() {
            let t11 = e10.minInput, i11 = e10.maxInput;
            t11 && t11.blur && e7(t11, "blur"), i11 && i11.blur && e7(i11, "blur");
          };
          e10.chart = t10, e10.options = i10, e10.buttons = [], e10.buttonOptions = s10, this.eventsToUnbind = [], this.eventsToUnbind.push(e1(t10.container, "mousedown", n2)), this.eventsToUnbind.push(e1(t10, "resize", n2)), s10.forEach(e10.computeButtonRange), void 0 !== o2 && s10[o2] && this.clickButton(o2, false), this.eventsToUnbind.push(e1(t10, "load", function() {
            t10.xAxis && t10.xAxis[0] && e1(t10.xAxis[0], "setExtremes", function(i11) {
              it(this.max) && it(this.min) && this.max - this.min !== t10.fixedRange && "rangeSelectorButton" !== i11.trigger && "updatedData" !== i11.trigger && e10.forcedDataGrouping && !e10.frozenStates && this.setDataGrouping(false, false);
            });
          })), this.createElements();
        }
        updateButtonStates() {
          let t10 = this, e10 = this.chart, i10 = this.dropdown, s10 = this.dropdownLabel, o2 = e10.xAxis[0], n2 = Math.round(o2.max - o2.min), r2 = !o2.hasVisibleSeries, a2 = 24 * 36e5, l2 = e10.scroller && e10.scroller.getUnionExtremes() || o2, h2 = l2.dataMin, d2 = l2.dataMax, p2 = t10.getYTDExtremes(d2, h2), c2 = p2.min, u2 = p2.max, g2 = t10.selected, m2 = t10.options.allButtonsEnabled, f2 = Array(t10.buttonOptions.length).fill(0), x2 = it(g2), b2 = t10.buttons, v2 = false, y2 = null;
          t10.buttonOptions.forEach((e11, i11) => {
            var _a;
            let s11 = e11._range, l3 = e11.type, p3 = e11.count || 1, b3 = e11._offsetMax - e11._offsetMin, M2 = i11 === g2, A2 = s11 > d2 - h2, k2 = s11 < o2.minRange, w2 = false, S2 = s11 === n2;
            if (M2 && A2 && (v2 = true), o2.isOrdinal && ((_a = o2.ordinal) == null ? void 0 : _a.positions) && s11 && n2 < s11) {
              let t11 = o2.ordinal.positions, e12 = eD.Additions.findIndexOf(t11, o2.min, true), i12 = Math.min(eD.Additions.findIndexOf(t11, o2.max, true) + 1, t11.length - 1);
              t11[i12] - t11[e12] > s11 && (S2 = true);
            } else ("month" === l3 || "year" === l3) && n2 + 36e5 >= { month: 28, year: 365 }[l3] * a2 * p3 - b3 && n2 - 36e5 <= { month: 31, year: 366 }[l3] * a2 * p3 + b3 ? S2 = true : "ytd" === l3 ? (S2 = u2 - c2 + b3 === n2, w2 = !M2) : "all" === l3 && (S2 = o2.max - o2.min >= d2 - h2);
            let E2 = !m2 && !(v2 && "all" === l3) && (A2 || k2 || r2), C2 = v2 && "all" === l3 || !w2 && S2 || M2 && t10.frozenStates;
            E2 ? f2[i11] = 3 : C2 && (!x2 || i11 === g2) && (y2 = i11);
          }), null !== y2 ? (f2[y2] = 2, t10.setSelected(y2), this.dropdown && (this.dropdown.selectedIndex = y2 + 1)) : (t10.setSelected(), this.dropdown && (this.dropdown.selectedIndex = -1), s10 && (s10.setState(0), s10.attr({ text: (e0.lang.rangeSelectorZoom || "") + " " })));
          for (let e11 = 0; e11 < f2.length; e11++) {
            let o3 = f2[e11], n3 = b2[e11];
            if (n3.state !== o3 && (n3.setState(o3), i10)) {
              i10.options[e11 + 1].disabled = 3 === o3, 2 === o3 && (s10 && (s10.setState(2), s10.attr({ text: t10.buttonOptions[e11].text + " " })), i10.selectedIndex = e11 + 1);
              let n4 = s10.getBBox();
              e5(i10, { width: `${n4.width}px`, height: `${n4.height}px` });
            }
          }
        }
        computeButtonRange(t10) {
          let e10 = t10.type, i10 = t10.count || 1, s10 = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5 };
          s10[e10] ? t10._range = s10[e10] * i10 : ("month" === e10 || "year" === e10) && (t10._range = 24 * { month: 30, year: 365 }[e10] * 36e5 * i10), t10._offsetMin = io(t10.offsetMin, 0), t10._offsetMax = io(t10.offsetMax, 0), t10._range += t10._offsetMax - t10._offsetMin;
        }
        getInputValue(t10) {
          let e10 = "min" === t10 ? this.minInput : this.maxInput, i10 = this.chart.options.rangeSelector, s10 = this.chart.time;
          return e10 ? ("text" === e10.type && i10.inputDateParser || this.defaultInputDateParser)(e10.value, "UTC" === s10.timezone, s10) : 0;
        }
        setInputValue(t10, e10) {
          let i10 = this.options, s10 = this.chart.time, o2 = "min" === t10 ? this.minInput : this.maxInput, n2 = "min" === t10 ? this.minDateBox : this.maxDateBox;
          if (o2) {
            o2.setAttribute("type", ia(i10.inputDateFormat || "%e %b %Y"));
            let t11 = o2.getAttribute("data-hc-time"), r2 = e3(t11) ? Number(t11) : void 0;
            if (e3(e10)) {
              let t12 = r2;
              e3(t12) && o2.setAttribute("data-hc-time-previous", t12), o2.setAttribute("data-hc-time", e10), r2 = e10;
            }
            o2.value = s10.dateFormat(this.inputTypeFormats[o2.type] || i10.inputEditDateFormat, r2), n2 && n2.attr({ text: s10.dateFormat(i10.inputDateFormat, r2) });
          }
        }
        setInputExtremes(t10, e10, i10) {
          let s10 = "min" === t10 ? this.minInput : this.maxInput;
          if (s10) {
            let t11 = this.inputTypeFormats[s10.type], o2 = this.chart.time;
            if (t11) {
              let n2 = o2.dateFormat(t11, e10);
              s10.min !== n2 && (s10.min = n2);
              let r2 = o2.dateFormat(t11, i10);
              s10.max !== r2 && (s10.max = r2);
            }
          }
        }
        showInput(t10) {
          let e10 = "min" === t10 ? this.minDateBox : this.maxDateBox, i10 = "min" === t10 ? this.minInput : this.maxInput;
          if (i10 && e10 && this.inputGroup) {
            let t11 = "text" === i10.type, { translateX: s10 = 0, translateY: o2 = 0 } = this.inputGroup, { x: n2 = 0, width: r2 = 0, height: a2 = 0 } = e10, { inputBoxWidth: l2 } = this.options;
            e5(i10, { width: t11 ? r2 + (l2 ? -2 : 20) + "px" : "auto", height: a2 - 2 + "px", border: "2px solid silver" }), t11 && l2 ? e5(i10, { left: s10 + n2 + "px", top: o2 + "px" }) : e5(i10, { left: Math.min(Math.round(n2 + s10 - (i10.offsetWidth - r2) / 2), this.chart.chartWidth - i10.offsetWidth) + "px", top: o2 - (i10.offsetHeight - a2) / 2 + "px" });
          }
        }
        hideInput(t10) {
          let e10 = "min" === t10 ? this.minInput : this.maxInput;
          e10 && e5(e10, { top: "-9999em", border: 0, width: "1px", height: "1px" });
        }
        defaultInputDateParser(t10, e10, i10) {
          return (i10 == null ? void 0 : i10.parse(t10)) || 0;
        }
        drawInput(t10) {
          let { chart: e10, div: i10, inputGroup: s10 } = this, o2 = this, n2 = e10.renderer.style || {}, r2 = e10.renderer, a2 = e10.options.rangeSelector, l2 = e0.lang, h2 = "min" === t10;
          function d2(t11) {
            var _a;
            let { maxInput: i11, minInput: s11 } = o2, n3 = e10.xAxis[0], r3 = ((_a = e10.scroller) == null ? void 0 : _a.getUnionExtremes()) || n3, a3 = r3.dataMin, l3 = r3.dataMax, d3 = e10.xAxis[0].getExtremes()[t11], p3 = o2.getInputValue(t11);
            it(p3) && p3 !== d3 && (h2 && i11 && it(a3) ? p3 > Number(i11.getAttribute("data-hc-time")) ? p3 = void 0 : p3 < a3 && (p3 = a3) : s11 && it(l3) && (p3 < Number(s11.getAttribute("data-hc-time")) ? p3 = void 0 : p3 > l3 && (p3 = l3)), void 0 !== p3 && n3.setExtremes(h2 ? p3 : n3.min, h2 ? n3.max : p3, void 0, void 0, { trigger: "rangeSelectorInput" }));
          }
          let p2 = l2[h2 ? "rangeSelectorFrom" : "rangeSelectorTo"] || "", c2 = r2.label(p2, 0).addClass("highcharts-range-label").attr({ padding: p2 ? 2 : 0, height: p2 ? a2.inputBoxHeight : 0 }).add(s10), u2 = r2.label("", 0).addClass("highcharts-range-input").attr({ padding: 2, width: a2.inputBoxWidth, height: a2.inputBoxHeight, "text-align": "center" }).on("click", function() {
            o2.showInput(t10), o2[t10 + "Input"].focus();
          });
          e10.styledMode || u2.attr({ stroke: a2.inputBoxBorderColor, "stroke-width": 1 }), u2.add(s10);
          let g2 = e2("input", { name: t10, className: "highcharts-range-selector" }, void 0, i10);
          g2.setAttribute("type", ia(a2.inputDateFormat || "%e %b %Y")), e10.styledMode || (c2.css(ii(n2, a2.labelStyle)), u2.css(ii({ color: "#333333" }, n2, a2.inputStyle)), e5(g2, e9({ position: "absolute", border: 0, boxShadow: "0 0 15px rgba(0,0,0,0.3)", width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: n2.fontSize, fontFamily: n2.fontFamily, top: "-9999em" }, a2.inputStyle))), g2.onfocus = () => {
            o2.showInput(t10);
          }, g2.onblur = () => {
            g2 === B().doc.activeElement && d2(t10), o2.hideInput(t10), o2.setInputValue(t10), g2.blur();
          };
          let m2 = false;
          return g2.onchange = () => {
            m2 || (d2(t10), o2.hideInput(t10), g2.blur());
          }, g2.onkeypress = (e11) => {
            13 === e11.keyCode && d2(t10);
          }, g2.onkeydown = (e11) => {
            m2 = true, ("ArrowUp" === e11.key || "ArrowDown" === e11.key || "Tab" === e11.key) && d2(t10);
          }, g2.onkeyup = () => {
            m2 = false;
          }, { dateBox: u2, input: g2, label: c2 };
        }
        getPosition() {
          let t10 = this.chart, e10 = t10.options.rangeSelector, i10 = "top" === e10.verticalAlign ? t10.plotTop - t10.axisOffset[0] : 0;
          return { buttonTop: i10 + e10.buttonPosition.y, inputTop: i10 + e10.inputPosition.y - 10 };
        }
        getYTDExtremes(t10, e10) {
          let i10 = this.chart.time, s10 = i10.toParts(t10)[0];
          return { max: t10, min: Math.max(e10, i10.makeTime(s10, 0)) };
        }
        createElements() {
          var _a;
          let t10 = this.chart, e10 = t10.renderer, i10 = t10.container, s10 = t10.options, o2 = s10.rangeSelector, n2 = o2.inputEnabled, r2 = io((_a = s10.chart.style) == null ? void 0 : _a.zIndex, 0) + 1;
          false !== o2.enabled && (this.group = e10.g("range-selector-group").attr({ zIndex: 7 }).add(), this.div = e2("div", void 0, { position: "relative", height: 0, zIndex: r2 }), this.buttonOptions.length && this.renderButtons(), i10.parentNode && i10.parentNode.insertBefore(this.div, i10), n2 && this.createInputs());
        }
        createInputs() {
          this.inputGroup = this.chart.renderer.g("input-group").add(this.group);
          let t10 = this.drawInput("min");
          this.minDateBox = t10.dateBox, this.minLabel = t10.label, this.minInput = t10.input;
          let e10 = this.drawInput("max");
          this.maxDateBox = e10.dateBox, this.maxLabel = e10.label, this.maxInput = e10.input;
        }
        render(t10, e10) {
          var _a, _b;
          if (false === this.options.enabled) return;
          let i10 = this.chart, s10 = i10.options.rangeSelector;
          if (s10.inputEnabled) {
            this.inputGroup || this.createInputs(), this.setInputValue("min", t10), this.setInputValue("max", e10), this.chart.styledMode || ((_a = this.maxLabel) == null ? void 0 : _a.css(s10.labelStyle), (_b = this.minLabel) == null ? void 0 : _b.css(s10.labelStyle));
            let o2 = i10.scroller && i10.scroller.getUnionExtremes() || i10.xAxis[0] || {};
            if (e3(o2.dataMin) && e3(o2.dataMax)) {
              let t11 = i10.xAxis[0].minRange || 0;
              this.setInputExtremes("min", o2.dataMin, Math.min(o2.dataMax, this.getInputValue("max")) - t11), this.setInputExtremes("max", Math.max(o2.dataMin, this.getInputValue("min")) + t11, o2.dataMax);
            }
            if (this.inputGroup) {
              let t11 = 0;
              [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach((e11) => {
                if (e11) {
                  let { width: i11 } = e11.getBBox();
                  i11 && (e11.attr({ x: t11 }), t11 += i11 + s10.inputSpacing);
                }
              });
            }
          } else this.inputGroup && (this.inputGroup.destroy(), delete this.inputGroup);
          !this.chart.styledMode && this.zoomText && this.zoomText.css(s10.labelStyle), this.alignElements(), this.updateButtonStates();
        }
        renderButtons() {
          var _a;
          var t10;
          let { chart: e10, options: i10 } = this, s10 = e0.lang, o2 = e10.renderer, n2 = ii(i10.buttonTheme), r2 = n2 && n2.states;
          delete n2.width, delete n2.states, this.buttonGroup = o2.g("range-selector-buttons").add(this.group);
          let a2 = this.dropdown = e2("select", void 0, { position: "absolute", padding: 0, border: 0, cursor: "pointer", opacity: 1e-4 }, this.div), l2 = (_a = e10.userOptions.rangeSelector) == null ? void 0 : _a.buttonTheme;
          this.dropdownLabel = o2.button("", 0, 0, () => {
          }, ii(n2, { "stroke-width": io(n2["stroke-width"], 0), width: "auto", paddingLeft: io(i10.buttonTheme.paddingLeft, l2 == null ? void 0 : l2.padding, 8), paddingRight: io(i10.buttonTheme.paddingRight, l2 == null ? void 0 : l2.padding, 8) }), r2 && r2.hover, r2 && r2.select, r2 && r2.disabled).hide().add(this.group), e1(a2, "touchstart", () => {
            a2.style.fontSize = "16px";
          });
          let h2 = B().isMS ? "mouseover" : "mouseenter", d2 = B().isMS ? "mouseout" : "mouseleave";
          e1(a2, h2, () => {
            e7(this.dropdownLabel.element, h2);
          }), e1(a2, d2, () => {
            e7(this.dropdownLabel.element, d2);
          }), e1(a2, "change", () => {
            e7(this.buttons[a2.selectedIndex - 1].element, "click");
          }), this.zoomText = o2.label(s10.rangeSelectorZoom || "", 0).attr({ padding: i10.buttonTheme.padding, height: i10.buttonTheme.height, paddingLeft: 0, paddingRight: 0 }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(i10.labelStyle), (t10 = i10.buttonTheme)["stroke-width"] ?? (t10["stroke-width"] = 0)), e2("option", { textContent: this.zoomText.textStr, disabled: true }, void 0, a2), this.createButtons();
        }
        createButtons() {
          let { options: t10 } = this, e10 = ii(t10.buttonTheme), i10 = e10 && e10.states, s10 = e10.width || 28;
          delete e10.width, delete e10.states, this.buttonOptions.forEach((t11, e11) => {
            this.createButton(t11, e11, s10, i10);
          });
        }
        createButton(t10, e10, i10, s10) {
          let { dropdown: o2, buttons: n2, chart: r2, options: a2 } = this, l2 = r2.renderer, h2 = ii(a2.buttonTheme);
          o2 == null ? void 0 : o2.add(e2("option", { textContent: t10.title || t10.text }), e10 + 2), n2[e10] = l2.button(t10.text, 0, 0, (i11) => {
            let s11;
            let o3 = t10.events && t10.events.click;
            o3 && (s11 = o3.call(t10, i11)), false !== s11 && this.clickButton(e10), this.isActive = true;
          }, h2, s10 && s10.hover, s10 && s10.select, s10 && s10.disabled).attr({ "text-align": "center", width: i10 }).add(this.buttonGroup), t10.title && n2[e10].attr("title", t10.title);
        }
        alignElements() {
          var _a;
          let { buttonGroup: t10, buttons: e10, chart: i10, group: s10, inputGroup: o2, options: n2, zoomText: r2 } = this, a2 = i10.options, l2 = a2.exporting && false !== a2.exporting.enabled && a2.navigation && a2.navigation.buttonOptions, { buttonPosition: h2, inputPosition: d2, verticalAlign: p2 } = n2, c2 = (t11, e11, s11) => l2 && this.titleCollision(i10) && "top" === p2 && s11 && e11.y - t11.getBBox().height - 12 < (l2.y || 0) + (l2.height || 0) + i10.spacing[0] ? -40 : 0, u2 = i10.plotLeft;
          if (s10 && h2 && d2) {
            let a3 = h2.x - i10.spacing[3];
            if (t10) {
              if (this.positionButtons(), !this.initialButtonGroupWidth) {
                let t11 = 0;
                r2 && (t11 += r2.getBBox().width + 5), e10.forEach((i11, s11) => {
                  t11 += i11.width || 0, s11 !== e10.length - 1 && (t11 += n2.buttonSpacing);
                }), this.initialButtonGroupWidth = t11;
              }
              u2 -= i10.spacing[3];
              let o3 = c2(t10, h2, "right" === h2.align || "right" === d2.align);
              this.alignButtonGroup(o3), ((_a = this.buttonGroup) == null ? void 0 : _a.translateY) && this.dropdownLabel.attr({ y: this.buttonGroup.translateY }), s10.placed = t10.placed = i10.hasLoaded;
            }
            let l3 = 0;
            n2.inputEnabled && o2 && (l3 = c2(o2, d2, "right" === h2.align || "right" === d2.align), "left" === d2.align ? a3 = u2 : "right" === d2.align && (a3 = -Math.max(i10.axisOffset[1], -l3)), o2.align({ y: d2.y, width: o2.getBBox().width, align: d2.align, x: d2.x + a3 - 2 }, true, i10.spacingBox), o2.placed = i10.hasLoaded), this.handleCollision(l3), s10.align({ verticalAlign: p2 }, true, i10.spacingBox);
            let g2 = s10.alignAttr.translateY, m2 = s10.getBBox().height + 20, f2 = 0;
            if ("bottom" === p2) {
              let t11 = i10.legend && i10.legend.options;
              f2 = g2 - (m2 = m2 + (t11 && "bottom" === t11.verticalAlign && t11.enabled && !t11.floating ? i10.legend.legendHeight + io(t11.margin, 10) : 0) - 20) - (n2.floating ? 0 : n2.y) - (i10.titleOffset ? i10.titleOffset[2] : 0) - 10;
            }
            "top" === p2 ? (n2.floating && (f2 = 0), i10.titleOffset && i10.titleOffset[0] && (f2 = i10.titleOffset[0]), f2 += i10.margin[0] - i10.spacing[0] || 0) : "middle" === p2 && (d2.y === h2.y ? f2 = g2 : (d2.y || h2.y) && (d2.y < 0 || h2.y < 0 ? f2 -= Math.min(d2.y, h2.y) : f2 = g2 - m2)), s10.translate(n2.x, n2.y + Math.floor(f2));
            let { minInput: x2, maxInput: b2, dropdown: v2 } = this;
            n2.inputEnabled && x2 && b2 && (x2.style.marginTop = s10.translateY + "px", b2.style.marginTop = s10.translateY + "px"), v2 && (v2.style.marginTop = s10.translateY + "px");
          }
        }
        redrawElements() {
          var _a, _b, _c, _d, _e;
          let t10 = this.chart, { inputBoxHeight: e10, inputBoxBorderColor: i10 } = this.options;
          if ((_a = this.maxDateBox) == null ? void 0 : _a.attr({ height: e10 }), (_b = this.minDateBox) == null ? void 0 : _b.attr({ height: e10 }), t10.styledMode || ((_c = this.maxDateBox) == null ? void 0 : _c.attr({ stroke: i10 }), (_d = this.minDateBox) == null ? void 0 : _d.attr({ stroke: i10 })), this.isDirty) {
            this.isDirty = false, this.isCollapsed = void 0;
            let t11 = this.options.buttons ?? [], e11 = Math.min(t11.length, this.buttonOptions.length), { dropdown: i11, options: s10 } = this, o2 = ii(s10.buttonTheme), n2 = o2 && o2.states, r2 = o2.width || 28;
            if (t11.length < this.buttonOptions.length) for (let e12 = this.buttonOptions.length - 1; e12 >= t11.length; e12--) {
              let t12 = this.buttons.pop();
              t12 == null ? void 0 : t12.destroy(), (_e = this.dropdown) == null ? void 0 : _e.options.remove(e12 + 1);
            }
            for (let s11 = e11 - 1; s11 >= 0; s11--) if (0 !== Object.keys(e4(t11[s11], this.buttonOptions[s11])).length) {
              let e12 = t11[s11];
              this.buttons[s11].destroy(), i11 == null ? void 0 : i11.options.remove(s11 + 1), this.createButton(e12, s11, r2, n2), this.computeButtonRange(e12);
            }
            if (t11.length > this.buttonOptions.length) for (let e12 = this.buttonOptions.length; e12 < t11.length; e12++) this.createButton(t11[e12], e12, r2, n2), this.computeButtonRange(t11[e12]);
            this.buttonOptions = this.options.buttons ?? [], e3(this.options.selected) && this.buttons.length && this.clickButton(this.options.selected, false);
          }
        }
        alignButtonGroup(t10, e10) {
          let { chart: i10, options: s10, buttonGroup: o2, dropdown: n2, dropdownLabel: r2 } = this, { buttonPosition: a2 } = s10, l2 = i10.plotLeft - i10.spacing[3], h2 = a2.x - i10.spacing[3], d2 = i10.plotLeft;
          "right" === a2.align ? (h2 += t10 - l2, this.hasVisibleDropdown && (d2 = i10.chartWidth + t10 - this.maxButtonWidth() - 20)) : "center" === a2.align && (h2 -= l2 / 2, this.hasVisibleDropdown && (d2 = i10.chartWidth / 2 - this.maxButtonWidth())), n2 && e5(n2, { left: d2 + "px", top: (o2 == null ? void 0 : o2.translateY) + "px" }), r2 == null ? void 0 : r2.attr({ x: d2 }), o2 && o2.align({ y: a2.y, width: io(e10, this.initialButtonGroupWidth), align: a2.align, x: h2 }, true, i10.spacingBox);
        }
        positionButtons() {
          let { buttons: t10, chart: e10, options: i10, zoomText: s10 } = this, o2 = e10.hasLoaded ? "animate" : "attr", { buttonPosition: n2 } = i10, r2 = e10.plotLeft, a2 = r2;
          s10 && "hidden" !== s10.visibility && (s10[o2]({ x: io(r2 + n2.x, r2) }), a2 += n2.x + s10.getBBox().width + 5);
          for (let e11 = 0, s11 = this.buttonOptions.length; e11 < s11; ++e11) "hidden" !== t10[e11].visibility ? (t10[e11][o2]({ x: a2 }), a2 += (t10[e11].width || 0) + i10.buttonSpacing) : t10[e11][o2]({ x: r2 });
        }
        handleCollision(t10) {
          let { chart: e10, buttonGroup: i10, inputGroup: s10, initialButtonGroupWidth: o2 } = this, { buttonPosition: n2, dropdown: r2, inputPosition: a2 } = this.options, l2 = () => {
            s10 && i10 && s10.attr({ translateX: s10.alignAttr.translateX + (e10.axisOffset[1] >= -t10 ? 0 : -t10), translateY: s10.alignAttr.translateY + i10.getBBox().height + 10 });
          };
          s10 && i10 ? a2.align === n2.align ? (l2(), o2 > e10.plotWidth + t10 - 20 ? this.collapseButtons() : this.expandButtons()) : o2 - t10 + s10.getBBox().width > e10.plotWidth ? "responsive" === r2 ? this.collapseButtons() : l2() : this.expandButtons() : i10 && "responsive" === r2 && (o2 > e10.plotWidth ? this.collapseButtons() : this.expandButtons()), i10 && ("always" === r2 && this.collapseButtons(), "never" === r2 && this.expandButtons()), this.alignButtonGroup(t10);
        }
        collapseButtons() {
          let { buttons: t10, zoomText: e10 } = this;
          true !== this.isCollapsed && (this.isCollapsed = true, e10.hide(), t10.forEach((t11) => void t11.hide()), this.showDropdown());
        }
        expandButtons() {
          let { buttons: t10, zoomText: e10 } = this;
          false !== this.isCollapsed && (this.isCollapsed = false, this.hideDropdown(), e10.show(), t10.forEach((t11) => void t11.show()), this.positionButtons());
        }
        showDropdown() {
          let { buttonGroup: t10, dropdownLabel: e10, dropdown: i10 } = this;
          t10 && i10 && (e10.show(), e5(i10, { visibility: "inherit" }), this.hasVisibleDropdown = true);
        }
        hideDropdown() {
          let { dropdown: t10 } = this;
          t10 && (this.dropdownLabel.hide(), e5(t10, { visibility: "hidden", width: "1px", height: "1px" }), this.hasVisibleDropdown = false);
        }
        getHeight() {
          let t10 = this.options, e10 = this.group, i10 = t10.inputPosition, s10 = t10.buttonPosition, o2 = t10.y, n2 = s10.y, r2 = i10.y, a2 = 0;
          if (t10.height) return t10.height;
          this.alignElements(), a2 = e10 ? e10.getBBox(true).height + 13 + o2 : 0;
          let l2 = Math.min(r2, n2);
          return (r2 < 0 && n2 < 0 || r2 > 0 && n2 > 0) && (a2 += Math.abs(l2)), a2;
        }
        titleCollision(t10) {
          return !(t10.options.title.text || t10.options.subtitle.text);
        }
        update(t10, e10 = true) {
          let i10 = this.chart;
          if (ii(true, this.options, t10), this.options.selected && this.options.selected >= this.options.buttons.length && (this.options.selected = void 0, i10.options.rangeSelector.selected = void 0), e3(t10.enabled)) return this.destroy(), this.init(i10);
          this.isDirty = !!t10.buttons, e10 && this.render();
        }
        destroy() {
          let t10 = this, e10 = t10.minInput, i10 = t10.maxInput;
          t10.eventsToUnbind && (t10.eventsToUnbind.forEach((t11) => t11()), t10.eventsToUnbind = void 0), e6(t10.buttons), e10 && (e10.onfocus = e10.onblur = e10.onchange = null), i10 && (i10.onfocus = i10.onblur = i10.onchange = null), is(t10, function(e11, i11) {
            e11 && "chart" !== i11 && (e11 instanceof eQ() ? e11.destroy() : e11 instanceof window.HTMLElement && e8(e11), delete t10[i11]), e11 !== il.prototype[i11] && (t10[i11] = null);
          }, this), this.buttons = [];
        }
      }
      e9(il.prototype, { inputTypeFormats: { "datetime-local": "%Y-%m-%dT%H:%M:%S", date: "%Y-%m-%d", time: "%H:%M:%S" } });
      var ih = E(960), id = E.n(ih), ip = E(984), ic = E.n(ip);
      let { format: iu } = ic(), { getOptions: ig } = B(), { setFixedRange: im } = tD, { addEvent: ix, clamp: ib, crisp: iv, defined: iy, extend: iM, find: iA, isNumber: ik, isString: iw, merge: iS, pick: iE, splat: iC } = B();
      function iT(t10, e10, i10) {
        var _a, _b;
        return "xAxis" === t10 ? { minPadding: 0, maxPadding: 0, overscroll: 0, ordinal: true } : "yAxis" === t10 ? { labels: { y: -2 }, opposite: i10.opposite ?? e10.opposite ?? true, showLastLabel: !!(e10.categories || "category" === e10.type), title: { text: ((_a = i10.title) == null ? void 0 : _a.text) !== "Values" ? (_b = i10.title) == null ? void 0 : _b.text : null } } : {};
      }
      function iB(t10, e10) {
        if ("xAxis" === t10) {
          let t11 = iE(e10.navigator && e10.navigator.enabled, tM.enabled, true), i10 = { type: "datetime", categories: void 0 };
          return t11 && (i10.startOnTick = false, i10.endOnTick = false), i10;
        }
        return {};
      }
      class iO extends id() {
        init(t10, e10) {
          let i10 = ig(), s10 = t10.xAxis, o2 = t10.yAxis, n2 = iE(t10.navigator && t10.navigator.enabled, tM.enabled, true);
          t10.xAxis = t10.yAxis = void 0;
          let r2 = iS({ chart: { panning: { enabled: true, type: "x" }, zooming: { pinchType: "x", mouseWheel: { type: "x" } } }, navigator: { enabled: n2 }, scrollbar: { enabled: iE(tZ.enabled, true) }, rangeSelector: { enabled: iE(eP.rangeSelector.enabled, true) }, title: { text: null }, tooltip: { split: iE(i10.tooltip && i10.tooltip.split, true), crosshairs: true }, legend: { enabled: false } }, t10, { isStock: true });
          t10.xAxis = s10, t10.yAxis = o2, r2.xAxis = iC(t10.xAxis || {}).map((e11) => iS(iT("xAxis", e11, i10.xAxis), e11, iB("xAxis", t10))), r2.yAxis = iC(t10.yAxis || {}).map((t11) => iS(iT("yAxis", t11, i10.yAxis), t11)), super.init(r2, e10);
        }
        createAxis(t10, e10) {
          return e10.axis = iS(iT(t10, e10.axis, ig()[t10]), e10.axis, iB(t10, this.userOptions)), super.createAxis(t10, e10);
        }
      }
      ix(id(), "update", function(t10) {
        let e10 = t10.options;
        "scrollbar" in e10 && this.navigator && (iS(true, this.options.scrollbar, e10.scrollbar), this.navigator.update({ enabled: !!this.navigator.navigatorEnabled }), delete e10.scrollbar);
      }), function(t10) {
        function e10(t11) {
          var _a, _b, _c;
          if (!(((_b = (_a = this.crosshair) == null ? void 0 : _a.label) == null ? void 0 : _b.enabled) && this.cross && ik(this.min) && ik(this.max))) return;
          let e11 = this.chart, i11 = this.logarithmic, s11 = this.crosshair.label, o3 = this.horiz, n3 = this.opposite, r3 = this.left, a3 = this.top, l3 = this.width, h2 = "inside" === this.options.tickPosition, d2 = false !== this.crosshair.snap, p2 = t11.e || ((_c = this.cross) == null ? void 0 : _c.e), c2 = t11.point, u2 = this.crossLabel, g2, m2, f2 = s11.format, x2 = "", b2, v2 = 0, y2 = this.min, M2 = this.max;
          i11 && (y2 = i11.lin2log(this.min), M2 = i11.lin2log(this.max));
          let A2 = o3 ? "center" : n3 ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
          u2 || (u2 = this.crossLabel = e11.renderer.label("", 0, void 0, s11.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (c2 && c2.series ? c2.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({ align: s11.align || A2, padding: iE(s11.padding, 8), r: iE(s11.borderRadius, 3), zIndex: 2 }).add(this.labelGroup), e11.styledMode || u2.attr({ fill: s11.backgroundColor || c2 && c2.series && c2.series.color || "#666666", stroke: s11.borderColor || "", "stroke-width": s11.borderWidth || 0 }).css(iM({ color: "#ffffff", fontWeight: "normal", fontSize: "0.7em", textAlign: "center" }, s11.style || {}))), o3 ? (g2 = d2 ? (c2.plotX || 0) + r3 : p2.chartX, m2 = a3 + (n3 ? 0 : this.height)) : (g2 = r3 + this.offset + (n3 ? l3 : 0), m2 = d2 ? (c2.plotY || 0) + a3 : p2.chartY), f2 || s11.formatter || (this.dateTime && (x2 = "%b %d, %Y"), f2 = "{value" + (x2 ? ":" + x2 : "") + "}");
          let k2 = d2 ? this.isXAxis ? c2.x : c2.y : this.toValue(o3 ? p2.chartX : p2.chartY), w2 = c2 && c2.series ? c2.series.isPointInside(c2) : ik(k2) && k2 > y2 && k2 < M2, S2 = "";
          f2 ? S2 = iu(f2, { value: k2 }, e11) : s11.formatter && ik(k2) && (S2 = s11.formatter.call(this, k2)), u2.attr({ text: S2, x: g2, y: m2, visibility: w2 ? "inherit" : "hidden" });
          let E2 = u2.getBBox();
          !ik(u2.x) || o3 || n3 || (g2 = u2.x - E2.width / 2), ik(u2.y) && (o3 ? (h2 && !n3 || !h2 && n3) && (m2 = u2.y - E2.height) : m2 = u2.y - E2.height / 2), b2 = o3 ? { left: r3, right: r3 + this.width } : { left: "left" === this.labelAlign ? r3 : 0, right: "right" === this.labelAlign ? r3 + this.width : e11.chartWidth };
          let C2 = u2.translateX || 0;
          C2 < b2.left && (v2 = b2.left - C2), C2 + E2.width >= b2.right && (v2 = -(C2 + E2.width - b2.right)), u2.attr({ x: Math.max(0, g2 + v2), y: Math.max(0, m2), anchorX: o3 ? g2 : this.opposite ? 0 : e11.chartWidth, anchorY: o3 ? this.opposite ? e11.chartHeight : 0 : m2 + E2.height / 2 });
        }
        function i10() {
          this.crossLabel && (this.crossLabel = this.crossLabel.hide());
        }
        function s10(t11) {
          let e11 = this.chart, i11 = this.options, s11 = e11._labelPanes = e11._labelPanes || {}, o3 = i11.labels;
          if (e11.options.isStock && "yAxis" === this.coll) {
            let e12 = i11.top + "," + i11.height;
            !s11[e12] && o3.enabled && (15 === o3.distance && 1 === this.side && (o3.distance = 0), void 0 === o3.align && (o3.align = "right"), s11[e12] = this, t11.align = "right", t11.preventDefault());
          }
        }
        function o2() {
          let t11 = this.chart, e11 = this.options && this.options.top + "," + this.options.height;
          e11 && t11._labelPanes && t11._labelPanes[e11] === this && delete t11._labelPanes[e11];
        }
        function n2(t11) {
          let e11 = this, i11 = e11.isLinked && !e11.series && e11.linkedParent ? e11.linkedParent.series : e11.series, s11 = e11.chart, o3 = s11.renderer, n3 = e11.left, r3 = e11.top, a3 = [], l3 = t11.translatedValue, h2 = t11.value, d2 = t11.force, p2, c2, u2, g2, m2 = [], f2, x2;
          if (s11.options.isStock && false !== t11.acrossPanes && "xAxis" === e11.coll || "yAxis" === e11.coll) {
            for (let o4 of (t11.preventDefault(), m2 = ((t12) => {
              let o5 = "xAxis" === t12 ? "yAxis" : "xAxis", n4 = e11.options[o5];
              return ik(n4) ? [s11[o5][n4]] : iw(n4) ? [s11.get(n4)] : i11.map((t13) => t13[o5]);
            })(e11.coll), e11.isXAxis ? s11.yAxis : s11.xAxis)) if (!o4.options.isInternal) {
              let t12 = o4.isXAxis ? "yAxis" : "xAxis";
              e11 === (iy(o4.options[t12]) ? s11[t12][o4.options[t12]] : s11[t12][0]) && m2.push(o4);
            }
            for (let t12 of (f2 = m2.length ? [] : [e11.isXAxis ? s11.yAxis[0] : s11.xAxis[0]], m2)) -1 !== f2.indexOf(t12) || iA(f2, (e12) => e12.pos === t12.pos && e12.len === t12.len) || f2.push(t12);
            if (ik(x2 = iE(l3, e11.translate(h2 || 0, void 0, void 0, t11.old)))) {
              if (e11.horiz) for (let t12 of f2) {
                let i12;
                g2 = (c2 = t12.pos) + t12.len, p2 = u2 = Math.round(x2 + e11.transB), "pass" !== d2 && (p2 < n3 || p2 > n3 + e11.width) && (d2 ? p2 = u2 = ib(p2, n3, n3 + e11.width) : i12 = true), i12 || a3.push(["M", p2, c2], ["L", u2, g2]);
              }
              else for (let t12 of f2) {
                let i12;
                u2 = (p2 = t12.pos) + t12.len, c2 = g2 = Math.round(r3 + e11.height - x2), "pass" !== d2 && (c2 < r3 || c2 > r3 + e11.height) && (d2 ? c2 = g2 = ib(c2, r3, r3 + e11.height) : i12 = true), i12 || a3.push(["M", p2, c2], ["L", u2, g2]);
              }
            }
            t11.path = a3.length > 0 ? o3.crispPolyLine(a3, t11.lineWidth || 1) : void 0;
          }
        }
        function r2(t11) {
          if (this.chart.options.isStock) {
            let e11;
            this.is("column") || this.is("columnrange") ? e11 = { borderWidth: 0, shadow: false } : this.is("scatter") || this.is("sma") || (e11 = { marker: { enabled: false, radius: 2 } }), e11 && (t11.plotOptions[this.type] = iS(t11.plotOptions[this.type], e11));
          }
        }
        function a2() {
          let t11 = this.chart, e11 = this.options.dataGrouping;
          return false !== this.allowDG && e11 && iE(e11.enabled, t11.options.isStock);
        }
        function l2(t11, e11) {
          for (let i11 = 0; i11 < t11.length; i11 += 2) {
            let s11 = t11[i11], o3 = t11[i11 + 1];
            iy(s11[1]) && s11[1] === o3[1] && (s11[1] = o3[1] = iv(s11[1], e11)), iy(s11[2]) && s11[2] === o3[2] && (s11[2] = o3[2] = iv(s11[2], e11));
          }
          return t11;
        }
        t10.compose = function(t11, h2, d2, p2) {
          let c2 = d2.prototype;
          c2.forceCropping || (ix(h2, "afterDrawCrosshair", e10), ix(h2, "afterHideCrosshair", i10), ix(h2, "autoLabelAlign", s10), ix(h2, "destroy", o2), ix(h2, "getPlotLinePath", n2), t11.prototype.setFixedRange = im, c2.forceCropping = a2, ix(d2, "setOptions", r2), p2.prototype.crispPolyLine = l2);
        }, t10.stockChart = function(e11, i11, s11) {
          return new t10(e11, i11, s11);
        };
      }(iO || (iO = {}));
      let iD = iO, { column: { prototype: { pointClass: iP } } } = tb().seriesTypes, { column: iR } = tb().seriesTypes, { crisp: iG, extend: iI, merge: iz } = B();
      class iL extends iR {
        extendStem(t10, e10, i10) {
          let s10 = t10[0], o2 = t10[1];
          "number" == typeof s10[2] && (s10[2] = Math.max(i10 + e10, s10[2])), "number" == typeof o2[2] && (o2[2] = Math.min(i10 - e10, o2[2]));
        }
        getPointPath(t10, e10) {
          let i10 = e10.strokeWidth(), s10 = t10.series, o2 = iG(t10.plotX || 0, i10), n2 = Math.round(t10.shapeArgs.width / 2), r2 = [["M", o2, Math.round(t10.yBottom)], ["L", o2, Math.round(t10.plotHigh)]];
          if (null !== t10.close) {
            let e11 = iG(t10.plotClose, i10);
            r2.push(["M", o2, e11], ["L", o2 + n2, e11]), s10.extendStem(r2, i10 / 2, e11);
          }
          return r2;
        }
        drawSinglePoint(t10) {
          let e10 = t10.series, i10 = e10.chart, s10, o2 = t10.graphic;
          void 0 !== t10.plotY && (o2 || (t10.graphic = o2 = i10.renderer.path().add(e10.group)), i10.styledMode || o2.attr(e10.pointAttribs(t10, t10.selected && "select")), s10 = e10.getPointPath(t10, o2), o2[o2 ? "animate" : "attr"]({ d: s10 }).addClass(t10.getClassName(), true));
        }
        drawPoints() {
          this.points.forEach(this.drawSinglePoint);
        }
        init() {
          super.init.apply(this, arguments), this.options.stacking = void 0;
        }
        pointAttribs(t10, e10) {
          let i10 = super.pointAttribs.call(this, t10, e10);
          return delete i10.fill, i10;
        }
        toYData(t10) {
          return [t10.high, t10.low, t10.close];
        }
        translate() {
          let t10 = this, e10 = t10.yAxis, i10 = this.pointArrayMap && this.pointArrayMap.slice() || [], s10 = i10.map((t11) => `plot${t11.charAt(0).toUpperCase() + t11.slice(1)}`);
          s10.push("yBottom"), i10.push("low"), super.translate.apply(t10), t10.points.forEach(function(o2) {
            i10.forEach(function(i11, n2) {
              let r2 = o2[i11];
              null !== r2 && (t10.dataModify && (r2 = t10.dataModify.modifyValue(r2)), o2[s10[n2]] = e10.toPixels(r2, true));
            }), o2.tooltipPos[1] = o2.plotHigh + e10.pos - t10.chart.plotTop;
          });
        }
      }
      iL.defaultOptions = iz(iR.defaultOptions, { lineWidth: 1, tooltip: { pointFormat: '<span style="color:{point.color}"></span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>' }, threshold: null, states: { hover: { lineWidth: 3 } }, stickyTracking: true }), iI(iL.prototype, { pointClass: class extends iP {
      }, animate: null, directTouch: false, keysAffectYAxis: ["low", "high"], pointArrayMap: ["high", "low", "close"], pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, pointValKey: "close" }), tb().registerSeriesType("hlc", iL);
      let { seriesTypes: { hlc: iW } } = tb();
      class iH extends iW.prototype.pointClass {
        getClassName() {
          return super.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
        }
        resolveUpColor() {
          this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);
        }
        resolveColor() {
          super.resolveColor(), this.series.is("heikinashi") || this.resolveUpColor();
        }
        getZone() {
          let t10 = super.getZone();
          return this.resolveUpColor(), t10;
        }
        applyOptions() {
          return super.applyOptions.apply(this, arguments), this.resolveColor && this.resolveColor(), this;
        }
      }
      let { composed: iX } = B(), { hlc: iY } = tb().seriesTypes, { addEvent: iN, crisp: iF, extend: iU, merge: i_, pushUnique: iV } = B();
      function iZ(t10) {
        let e10 = t10.options, i10 = e10.dataGrouping;
        i10 && e10.useOhlcData && "highcharts-navigator-series" !== e10.id && (i10.approximation = "ohlc");
      }
      function ij(t10) {
        let e10 = t10.options;
        e10.useOhlcData && "highcharts-navigator-series" !== e10.id && iU(this, { pointValKey: iK.prototype.pointValKey, pointArrayMap: iK.prototype.pointArrayMap, toYData: iK.prototype.toYData });
      }
      class iK extends iY {
        static compose(t10, ...e10) {
          iV(iX, "OHLCSeries") && (iN(t10, "afterSetOptions", iZ), iN(t10, "init", ij));
        }
        getPointPath(t10, e10) {
          let i10 = super.getPointPath(t10, e10), s10 = e10.strokeWidth(), o2 = iF(t10.plotX || 0, s10), n2 = Math.round(t10.shapeArgs.width / 2);
          if (null !== t10.open) {
            let e11 = iF(t10.plotOpen, s10);
            i10.push(["M", o2, e11], ["L", o2 - n2, e11]), super.extendStem(i10, s10 / 2, e11);
          }
          return i10;
        }
        pointAttribs(t10, e10) {
          let i10 = super.pointAttribs.call(this, t10, e10), s10 = this.options;
          return delete i10.fill, !t10.options.color && s10.upColor && t10.open < t10.close && (i10.stroke = s10.upColor), i10;
        }
        toYData(t10) {
          return [t10.open, t10.high, t10.low, t10.close];
        }
      }
      iK.defaultOptions = i_(iY.defaultOptions, { tooltip: { pointFormat: '<span style="color:{point.color}"></span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>' } }), iU(iK.prototype, { pointClass: iH, pointArrayMap: ["open", "high", "low", "close"] }), tb().registerSeriesType("ohlc", iK);
      let { column: iq, ohlc: i$ } = tb().seriesTypes, { crisp: iJ, merge: iQ } = B();
      class i0 extends i$ {
        pointAttribs(t10, e10) {
          let i10 = iq.prototype.pointAttribs.call(this, t10, e10), s10 = this.options, o2 = t10.open < t10.close, n2 = s10.lineColor || this.color, r2 = t10.color || this.color;
          if (i10["stroke-width"] = s10.lineWidth, i10.fill = t10.options.color || o2 && s10.upColor || r2, i10.stroke = t10.options.lineColor || o2 && s10.upLineColor || n2, e10) {
            let t11 = s10.states[e10];
            i10.fill = t11.color || i10.fill, i10.stroke = t11.lineColor || i10.stroke, i10["stroke-width"] = t11.lineWidth || i10["stroke-width"];
          }
          return i10;
        }
        drawPoints() {
          let t10 = this.points, e10 = this.chart, i10 = this.yAxis.reversed;
          for (let s10 of t10) {
            let t11 = s10.graphic, o2, n2, r2, a2, l2, h2, d2, p2, c2, u2 = !t11;
            if (void 0 !== s10.plotY) {
              t11 || (s10.graphic = t11 = e10.renderer.path().add(this.group)), this.chart.styledMode || t11.attr(this.pointAttribs(s10, s10.selected && "select")).shadow(this.options.shadow);
              let g2 = t11.strokeWidth();
              d2 = iJ(s10.plotX || 0, g2), r2 = Math.min(o2 = s10.plotOpen, n2 = s10.plotClose), a2 = Math.max(o2, n2), c2 = Math.round(s10.shapeArgs.width / 2), l2 = i10 ? a2 !== s10.yBottom : Math.round(r2) !== Math.round(s10.plotHigh || 0), h2 = i10 ? Math.round(r2) !== Math.round(s10.plotHigh || 0) : a2 !== s10.yBottom, r2 = iJ(r2, g2), a2 = iJ(a2, g2), (p2 = []).push(["M", d2 - c2, a2], ["L", d2 - c2, r2], ["L", d2 + c2, r2], ["L", d2 + c2, a2], ["Z"], ["M", d2, r2], ["L", d2, l2 ? Math.round(i10 ? s10.yBottom : s10.plotHigh) : r2], ["M", d2, a2], ["L", d2, h2 ? Math.round(i10 ? s10.plotHigh : s10.yBottom) : a2]), t11[u2 ? "attr" : "animate"]({ d: p2 }).addClass(s10.getClassName(), true);
            }
          }
        }
      }
      i0.defaultOptions = iQ(i$.defaultOptions, { tooltip: i$.defaultOptions.tooltip }, { states: { hover: { lineWidth: 2 } }, threshold: null, lineColor: "#000000", lineWidth: 1, upColor: "#ffffff", stickyTracking: true }), tb().registerSeriesType("candlestick", i0);
      let { column: { prototype: { pointClass: i1 } } } = tb().seriesTypes, { isNumber: i2 } = B(), i5 = class extends i1 {
        constructor() {
          super(...arguments), this.ttBelow = false;
        }
        isValid() {
          return i2(this.y) || void 0 === this.y;
        }
        hasNewShapeType() {
          let t10 = this.options.shape || this.series.options.shape;
          return this.graphic && t10 && t10 !== this.graphic.symbolKey;
        }
      };
      !function(t10) {
        let e10 = [];
        function i10(t11, e11, i11, s11, o2) {
          let n2 = o2 && o2.anchorX || t11, r2 = o2 && o2.anchorY || e11, a2 = this.circle(n2 - 1, r2 - 1, 2, 2);
          return a2.push(["M", n2, r2], ["L", t11, e11 + s11], ["L", t11, e11], ["L", t11 + i11, e11], ["L", t11 + i11, e11 + s11], ["L", t11, e11 + s11], ["Z"]), a2;
        }
        function s10(t11, e11) {
          t11[e11 + "pin"] = function(i11, s11, o2, n2, r2) {
            let a2;
            let l2 = r2 && r2.anchorX, h2 = r2 && r2.anchorY;
            if ("circle" === e11 && n2 > o2 && (i11 -= Math.round((n2 - o2) / 2), o2 = n2), a2 = t11[e11](i11, s11, o2, n2, r2), l2 && h2) {
              let r3 = l2;
              if ("circle" === e11) r3 = i11 + o2 / 2;
              else {
                let t12 = a2[0], e12 = a2[1];
                "M" === t12[0] && "L" === e12[0] && (r3 = (t12[1] + e12[1]) / 2);
              }
              let d2 = s11 > h2 ? s11 : s11 + n2;
              a2.push(["M", r3, d2], ["L", l2, h2]), a2 = a2.concat(t11.circle(l2 - 1, h2 - 1, 2, 2));
            }
            return a2;
          };
        }
        t10.compose = function(t11) {
          if (-1 === e10.indexOf(t11)) {
            e10.push(t11);
            let o3 = t11.prototype.symbols;
            o3.flag = i10, s10(o3, "circle"), s10(o3, "square");
          }
          let o2 = tB().getRendererType();
          e10.indexOf(o2) && e10.push(o2);
        };
      }(y || (y = {}));
      let i3 = y;
      var i6 = E(448), i4 = E.n(i6);
      let { composed: i8 } = B(), { prototype: i9 } = i4(), { prototype: i7 } = I(), { defined: st, pushUnique: se, stableSort: si } = B();
      !function(t10) {
        function e10(t11) {
          return i7.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this, t11);
        }
        function i10() {
          var _a, _b;
          i9.translate.apply(this);
          let t11 = this, e11 = t11.options, i11 = t11.chart, s10 = t11.points, o2 = e11.onSeries, n2 = o2 && i11.get(o2), r2 = n2 && n2.options.step, a2 = n2 && n2.points, l2 = i11.inverted, h2 = t11.xAxis, d2 = t11.yAxis, p2 = s10.length - 1, c2, u2, g2 = e11.onKey || "y", m2 = a2 && a2.length, f2 = 0, x2, b2, v2, y2, M2;
          if (n2 && n2.visible && m2) {
            for (f2 = (n2.pointXOffset || 0) + (n2.barW || 0) / 2, y2 = n2.currentDataGrouping, b2 = a2[m2 - 1].x + (y2 ? y2.totalRange : 0), si(s10, (t12, e12) => t12.x - e12.x), g2 = "plot" + g2[0].toUpperCase() + g2.substr(1); m2-- && s10[p2]; ) if (x2 = a2[m2], (c2 = s10[p2]).y = x2.y, x2.x <= c2.x && void 0 !== x2[g2]) {
              if (c2.x <= b2 && (c2.plotY = x2[g2], x2.x < c2.x && !r2 && (v2 = a2[m2 + 1]) && void 0 !== v2[g2])) {
                if (st(c2.plotX) && n2.is("spline")) {
                  let t12 = [x2.plotX || 0, x2.plotY || 0], e12 = [v2.plotX || 0, v2.plotY || 0], i12 = ((_a = x2.controlPoints) == null ? void 0 : _a.high) || t12, s11 = ((_b = v2.controlPoints) == null ? void 0 : _b.low) || e12, o3 = (o4, n4) => Math.pow(1 - o4, 3) * t12[n4] + 3 * (1 - o4) * (1 - o4) * o4 * i12[n4] + 3 * (1 - o4) * o4 * o4 * s11[n4] + o4 * o4 * o4 * e12[n4], n3 = 0, r3 = 1, a3;
                  for (let t13 = 0; t13 < 100; t13++) {
                    let t14 = (n3 + r3) / 2, e13 = o3(t14, 0);
                    if (null === e13) break;
                    if (0.25 > Math.abs(e13 - c2.plotX)) {
                      a3 = t14;
                      break;
                    }
                    e13 < c2.plotX ? n3 = t14 : r3 = t14;
                  }
                  st(a3) && (c2.plotY = o3(a3, 1), c2.y = d2.toValue(c2.plotY, true));
                } else M2 = (c2.x - x2.x) / (v2.x - x2.x), c2.plotY += M2 * (v2[g2] - x2[g2]), c2.y += M2 * (v2.y - x2.y);
              }
              if (p2--, m2++, p2 < 0) break;
            }
          }
          s10.forEach((e12, i12) => {
            let o3;
            e12.plotX += f2, (void 0 === e12.plotY || l2) && (e12.plotX >= 0 && e12.plotX <= h2.len ? l2 ? (e12.plotY = h2.translate(e12.x, 0, 1, 0, 1), e12.plotX = st(e12.y) ? d2.translate(e12.y, 0, 0, 0, 1) : 0) : e12.plotY = (h2.opposite ? 0 : t11.yAxis.len) + h2.offset : e12.shapeArgs = {}), (u2 = s10[i12 - 1]) && u2.plotX === e12.plotX && (void 0 === u2.stackIndex && (u2.stackIndex = 0), o3 = u2.stackIndex + 1), e12.stackIndex = o3;
          }), this.onSeries = n2;
        }
        t10.compose = function(t11) {
          if (se(i8, "OnSeries")) {
            let s10 = t11.prototype;
            s10.getPlotBox = e10, s10.translate = i10;
          }
          return t11;
        }, t10.getPlotBox = e10, t10.translate = i10;
      }(M || (M = {}));
      let ss = M, { noop: so } = B(), { distribute: sn } = B(), { series: sr, seriesTypes: { column: sa } } = tb(), { addEvent: sl, defined: sh, extend: sd, isNumber: sp, merge: sc, objectEach: su, wrap: sg } = B();
      class sm extends sa {
        animate(t10) {
          t10 && this.setClip();
        }
        drawPoints() {
          let t10, e10, i10, s10, o2, n2, r2, a2, l2, h2, d2;
          let p2 = this.points, c2 = this.chart, u2 = c2.renderer, g2 = c2.inverted, m2 = this.options, f2 = m2.y, x2 = this.yAxis, b2 = {}, v2 = [], y2 = sp(m2.borderRadius) ? m2.borderRadius : 0;
          for (s10 = p2.length; s10--; ) o2 = p2[s10], h2 = (g2 ? o2.plotY : o2.plotX) > this.xAxis.len, t10 = o2.plotX, r2 = o2.stackIndex, i10 = o2.options.shape || m2.shape, void 0 !== (e10 = o2.plotY) && (e10 = o2.plotY + f2 - (void 0 !== r2 && r2 * m2.stackDistance)), o2.anchorX = r2 ? void 0 : o2.plotX, a2 = r2 ? void 0 : o2.plotY, d2 = "flag" !== i10, n2 = o2.graphic, void 0 !== e10 && t10 >= 0 && !h2 ? (n2 && o2.hasNewShapeType() && (n2 = n2.destroy()), n2 || (n2 = o2.graphic = u2.label("", 0, void 0, i10, void 0, void 0, m2.useHTML).addClass("highcharts-point").add(this.markerGroup), o2.graphic.div && (o2.graphic.div.point = o2), n2.isNew = true), n2.attr({ align: d2 ? "center" : "left", width: m2.width, height: m2.height, "text-align": m2.textAlign, r: y2 }), c2.styledMode || n2.attr(this.pointAttribs(o2)).css(sc(m2.style, o2.style)).shadow(m2.shadow), t10 > 0 && (t10 -= n2.strokeWidth() % 2), l2 = { y: e10, anchorY: a2 }, m2.allowOverlapX && (l2.x = t10, l2.anchorX = o2.anchorX), n2.attr({ text: o2.options.title ?? m2.title ?? "A" })[n2.isNew ? "attr" : "animate"](l2), m2.allowOverlapX || (b2[o2.plotX] ? b2[o2.plotX].size = Math.max(b2[o2.plotX].size, n2.width || 0) : b2[o2.plotX] = { align: d2 ? 0.5 : 0, size: n2.width || 0, target: t10, anchorX: t10 }), o2.tooltipPos = [t10, e10 + x2.pos - c2.plotTop]) : n2 && (o2.graphic = n2.destroy());
          if (!m2.allowOverlapX) {
            let t11 = 100;
            for (let e11 of (su(b2, function(e12) {
              e12.plotX = e12.anchorX, v2.push(e12), t11 = Math.max(e12.size, t11);
            }), sn(v2, g2 ? x2.len : this.xAxis.len, t11), p2)) {
              let t12 = e11.plotX, i11 = e11.graphic, s11 = i11 && b2[t12];
              s11 && i11 && (sh(s11.pos) ? i11[i11.isNew ? "attr" : "animate"]({ x: s11.pos + (s11.align || 0) * s11.size, anchorX: e11.anchorX }).show().isNew = false : i11.hide().isNew = true);
            }
          }
          m2.useHTML && this.markerGroup && sg(this.markerGroup, "on", function(t11) {
            return eQ().prototype.on.apply(t11.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
          });
        }
        drawTracker() {
          let t10 = this.points;
          for (let e10 of (super.drawTracker(), t10)) {
            let i10 = e10.graphic;
            i10 && (e10.unbindMouseOver && e10.unbindMouseOver(), e10.unbindMouseOver = sl(i10.element, "mouseover", function() {
              for (let s10 of (e10.stackIndex > 0 && !e10.raised && (e10._y = i10.y, i10.attr({ y: e10._y - 8 }), e10.raised = true), t10)) s10 !== e10 && s10.raised && s10.graphic && (s10.graphic.attr({ y: s10._y }), s10.raised = false);
            }));
          }
        }
        pointAttribs(t10, e10) {
          let i10 = this.options, s10 = t10 && t10.color || this.color, o2 = i10.lineColor, n2 = t10 && t10.lineWidth, r2 = t10 && t10.fillColor || i10.fillColor;
          return e10 && (r2 = i10.states[e10].fillColor, o2 = i10.states[e10].lineColor, n2 = i10.states[e10].lineWidth), { fill: r2 || s10, stroke: o2 || s10, "stroke-width": n2 || i10.lineWidth || 0 };
        }
        setClip() {
          sr.prototype.setClip.apply(this, arguments), false !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
        }
      }
      sm.compose = i3.compose, sm.defaultOptions = sc(sa.defaultOptions, { borderRadius: 0, pointRange: 0, allowOverlapX: false, shape: "flag", stackDistance: 12, textAlign: "center", tooltip: { pointFormat: "{point.text}" }, threshold: null, y: -30, fillColor: "#ffffff", lineWidth: 1, states: { hover: { lineColor: "#000000", fillColor: "#ccd3ff" } }, style: { fontSize: "0.7em", fontWeight: "bold" } }), ss.compose(sm), sd(sm.prototype, { allowDG: false, forceCrop: true, invertible: false, noSharedTooltip: true, pointClass: i5, sorted: false, takeOrdinalPosition: false, trackerGroups: ["markerGroup"], buildKDTree: so, init: sr.prototype.init }), tb().registerSeriesType("flags", sm);
      var sf = E(184), sx = E.n(sf);
      let { addEvent: sb, find: sv, fireEvent: sy, isArray: sM, isNumber: sA, pick: sk } = B();
      !function(t10) {
        function e10() {
          void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, false);
        }
        function i10() {
          var _a;
          ((_a = this.brokenAxis) == null ? void 0 : _a.hasBreaks) && (this.options.ordinal = false);
        }
        function s10() {
          let t11 = this.brokenAxis;
          if (t11 == null ? void 0 : t11.hasBreaks) {
            let e11 = this.tickPositions, i11 = this.tickPositions.info, s11 = [];
            for (let i12 = 0; i12 < e11.length; i12++) t11.isInAnyBreak(e11[i12]) || s11.push(e11[i12]);
            this.tickPositions = s11, this.tickPositions.info = i11;
          }
        }
        function o2() {
          this.brokenAxis || (this.brokenAxis = new h2(this));
        }
        function n2() {
          var _a, _b;
          let { isDirty: t11, options: { connectNulls: e11 }, points: i11, xAxis: s11, yAxis: o3 } = this;
          if (t11) {
            let t12 = i11.length;
            for (; t12--; ) {
              let n3 = i11[t12], r3 = !(null === n3.y && false === e11) && (((_a = s11 == null ? void 0 : s11.brokenAxis) == null ? void 0 : _a.isInAnyBreak(n3.x, true)) || ((_b = o3 == null ? void 0 : o3.brokenAxis) == null ? void 0 : _b.isInAnyBreak(n3.y, true)));
              n3.visible = !r3 && false !== n3.options.visible;
            }
          }
        }
        function r2() {
          this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, sk(this.pointArrayMap, ["y"]));
        }
        function a2(t11, e11) {
          var _a;
          let i11, s11, o3;
          let n3 = this, r3 = n3.points;
          if ((_a = t11 == null ? void 0 : t11.brokenAxis) == null ? void 0 : _a.hasBreaks) {
            let a3 = t11.brokenAxis;
            e11.forEach(function(e12) {
              var _a2, _b;
              i11 = (a3 == null ? void 0 : a3.breakArray) || [], s11 = t11.isXAxis ? t11.min : sk(n3.options.threshold, t11.min);
              let l3 = (_b = (_a2 = t11 == null ? void 0 : t11.options) == null ? void 0 : _a2.breaks) == null ? void 0 : _b.filter(function(t12) {
                let e13 = true;
                for (let s12 = 0; s12 < i11.length; s12++) {
                  let o4 = i11[s12];
                  if (o4.from === t12.from && o4.to === t12.to) {
                    e13 = false;
                    break;
                  }
                }
                return e13;
              });
              r3.forEach(function(n4) {
                o3 = sk(n4["stack" + e12.toUpperCase()], n4[e12]), i11.forEach(function(e13) {
                  if (sA(s11) && sA(o3)) {
                    let i12 = "";
                    s11 < e13.from && o3 > e13.to || s11 > e13.from && o3 < e13.from ? i12 = "pointBreak" : (s11 < e13.from && o3 > e13.from && o3 < e13.to || s11 > e13.from && o3 > e13.to && o3 < e13.from) && (i12 = "pointInBreak"), i12 && sy(t11, i12, { point: n4, brk: e13 });
                  }
                }), l3 == null ? void 0 : l3.forEach(function(e13) {
                  sy(t11, "pointOutsideOfBreak", { point: n4, brk: e13 });
                });
              });
            });
          }
        }
        function l2() {
          let t11 = this.currentDataGrouping, e11 = t11 == null ? void 0 : t11.gapSize, i11 = this.points.slice(), s11 = this.yAxis, o3 = this.options.gapSize, n3 = i11.length - 1;
          if (o3 && n3 > 0) {
            let t12, r3;
            for ("value" !== this.options.gapUnit && (o3 *= this.basePointRange), e11 && e11 > o3 && e11 >= this.basePointRange && (o3 = e11); n3--; ) if (r3 && false !== r3.visible || (r3 = i11[n3 + 1]), t12 = i11[n3], false !== r3.visible && false !== t12.visible) {
              if (r3.x - t12.x > o3) {
                let e12 = (t12.x + r3.x) / 2;
                i11.splice(n3 + 1, 0, { isNull: true, x: e12 }), s11.stacking && this.options.stacking && ((s11.stacking.stacks[this.stackKey][e12] = new (sx())(s11, s11.options.stackLabels, false, e12, this.stack)).total = 0);
              }
              r3 = t12;
            }
          }
          return this.getGraphPath(i11);
        }
        t10.compose = function(t11, h3) {
          if (!t11.keepProps.includes("brokenAxis")) {
            t11.keepProps.push("brokenAxis"), sb(t11, "init", o2), sb(t11, "afterInit", e10), sb(t11, "afterSetTickPositions", s10), sb(t11, "afterSetOptions", i10);
            let d2 = h3.prototype;
            d2.drawBreaks = a2, d2.gappedPath = l2, sb(h3, "afterGeneratePoints", n2), sb(h3, "afterRender", r2);
          }
          return t11;
        };
        class h2 {
          static isInBreak(t11, e11) {
            let i11 = t11.repeat || 1 / 0, s11 = t11.from, o3 = t11.to - t11.from, n3 = e11 >= s11 ? (e11 - s11) % i11 : i11 - (s11 - e11) % i11;
            return t11.inclusive ? n3 <= o3 : n3 < o3 && 0 !== n3;
          }
          static lin2Val(t11) {
            let e11 = this.brokenAxis, i11 = e11 && e11.breakArray;
            if (!i11 || !sA(t11)) return t11;
            let s11 = t11, o3, n3;
            for (n3 = 0; n3 < i11.length && !((o3 = i11[n3]).from >= s11); n3++) o3.to < s11 ? s11 += o3.len : h2.isInBreak(o3, s11) && (s11 += o3.len);
            return s11;
          }
          static val2Lin(t11) {
            let e11 = this.brokenAxis, i11 = e11 && e11.breakArray;
            if (!i11 || !sA(t11)) return t11;
            let s11 = t11, o3, n3;
            for (n3 = 0; n3 < i11.length; n3++) if ((o3 = i11[n3]).to <= t11) s11 -= o3.len;
            else if (o3.from >= t11) break;
            else if (h2.isInBreak(o3, t11)) {
              s11 -= t11 - o3.from;
              break;
            }
            return s11;
          }
          constructor(t11) {
            this.hasBreaks = false, this.axis = t11;
          }
          findBreakAt(t11, e11) {
            return sv(e11, function(e12) {
              return e12.from < t11 && t11 < e12.to;
            });
          }
          isInAnyBreak(t11, e11) {
            let i11 = this.axis, s11 = i11.options.breaks || [], o3 = s11.length, n3, r3, a3;
            if (o3 && sA(t11)) {
              for (; o3--; ) h2.isInBreak(s11[o3], t11) && (n3 = true, r3 || (r3 = sk(s11[o3].showPoints, !i11.isXAxis)));
              a3 = n3 && e11 ? n3 && !r3 : n3;
            }
            return a3;
          }
          setBreaks(t11, e11) {
            let i11 = this, s11 = i11.axis, o3 = s11.chart.time, n3 = sM(t11) && !!t11.length && !!Object.keys(t11[0]).length;
            s11.isDirty = i11.hasBreaks !== n3, i11.hasBreaks = n3, t11 == null ? void 0 : t11.forEach((t12) => {
              t12.from = o3.parse(t12.from) || 0, t12.to = o3.parse(t12.to) || 0;
            }), t11 !== s11.options.breaks && (s11.options.breaks = s11.userOptions.breaks = t11), s11.forceRedraw = true, s11.series.forEach(function(t12) {
              t12.isDirty = true;
            }), n3 || s11.val2lin !== h2.val2Lin || (delete s11.val2lin, delete s11.lin2val), n3 && (s11.userOptions.ordinal = false, s11.lin2val = h2.lin2Val, s11.val2lin = h2.val2Lin, s11.setExtremes = function(t12, e12, o4, n4, r3) {
              if (i11.hasBreaks) {
                let s12;
                let o5 = this.options.breaks || [];
                for (; s12 = i11.findBreakAt(t12, o5); ) t12 = s12.to;
                for (; s12 = i11.findBreakAt(e12, o5); ) e12 = s12.from;
                e12 < t12 && (e12 = t12);
              }
              s11.constructor.prototype.setExtremes.call(this, t12, e12, o4, n4, r3);
            }, s11.setAxisTranslation = function() {
              if (s11.constructor.prototype.setAxisTranslation.call(this), i11.unitLength = void 0, i11.hasBreaks) {
                let t12 = s11.options.breaks || [], e12 = [], o4 = [], n4 = sk(s11.pointRangePadding, 0), r3 = 0, a3, l3, d2 = s11.userMin || s11.min, p2 = s11.userMax || s11.max, c2, u2;
                t12.forEach(function(t13) {
                  l3 = t13.repeat || 1 / 0, sA(d2) && sA(p2) && (h2.isInBreak(t13, d2) && (d2 += t13.to % l3 - d2 % l3), h2.isInBreak(t13, p2) && (p2 -= p2 % l3 - t13.from % l3));
                }), t12.forEach(function(t13) {
                  if (c2 = t13.from, l3 = t13.repeat || 1 / 0, sA(d2) && sA(p2)) {
                    for (; c2 - l3 > d2; ) c2 -= l3;
                    for (; c2 < d2; ) c2 += l3;
                    for (u2 = c2; u2 < p2; u2 += l3) e12.push({ value: u2, move: "in" }), e12.push({ value: u2 + t13.to - t13.from, move: "out", size: t13.breakSize });
                  }
                }), e12.sort(function(t13, e13) {
                  return t13.value === e13.value ? ("in" === t13.move ? 0 : 1) - ("in" === e13.move ? 0 : 1) : t13.value - e13.value;
                }), a3 = 0, c2 = d2, e12.forEach(function(t13) {
                  1 === (a3 += "in" === t13.move ? 1 : -1) && "in" === t13.move && (c2 = t13.value), 0 === a3 && sA(c2) && (o4.push({ from: c2, to: t13.value, len: t13.value - c2 - (t13.size || 0) }), r3 += t13.value - c2 - (t13.size || 0));
                }), i11.breakArray = o4, sA(d2) && sA(p2) && sA(s11.min) && (i11.unitLength = p2 - d2 - r3 + n4, sy(s11, "afterBreaks"), s11.staticScale ? s11.transA = s11.staticScale : i11.unitLength && (s11.transA *= (p2 - s11.min + n4) / i11.unitLength), n4 && (s11.minPixelPadding = s11.transA * (s11.minPointOffset || 0)), s11.min = d2, s11.max = p2);
              }
            }), sk(e11, true) && s11.chart.redraw();
          }
        }
        t10.Additions = h2;
      }(A || (A = {}));
      let sw = A, sS = B();
      sS.BrokenAxis = sS.BrokenAxis || sw, sS.BrokenAxis.compose(sS.Axis, sS.Series);
      let sE = {}, { arrayMax: sC, arrayMin: sT, correctFloat: sB, extend: sO, isNumber: sD } = B();
      function sP(t10) {
        let e10 = t10.length, i10 = sR(t10);
        return sD(i10) && e10 && (i10 = sB(i10 / e10)), i10;
      }
      function sR(t10) {
        let e10 = t10.length, i10;
        if (!e10 && t10.hasNulls) i10 = null;
        else if (e10) for (i10 = 0; e10--; ) i10 += t10[e10];
        return i10;
      }
      let sG = { average: sP, averages: function() {
        let t10 = [];
        return [].forEach.call(arguments, function(e10) {
          t10.push(sP(e10));
        }), void 0 === t10[0] ? void 0 : t10;
      }, close: function(t10) {
        return t10.length ? t10[t10.length - 1] : t10.hasNulls ? null : void 0;
      }, high: function(t10) {
        return t10.length ? sC(t10) : t10.hasNulls ? null : void 0;
      }, hlc: function(t10, e10, i10) {
        if (t10 = sE.high(t10), e10 = sE.low(e10), i10 = sE.close(i10), sD(t10) || sD(e10) || sD(i10)) return [t10, e10, i10];
      }, low: function(t10) {
        return t10.length ? sT(t10) : t10.hasNulls ? null : void 0;
      }, ohlc: function(t10, e10, i10, s10) {
        if (t10 = sE.open(t10), e10 = sE.high(e10), i10 = sE.low(i10), s10 = sE.close(s10), sD(t10) || sD(e10) || sD(i10) || sD(s10)) return [t10, e10, i10, s10];
      }, open: function(t10) {
        return t10.length ? t10[0] : t10.hasNulls ? null : void 0;
      }, range: function(t10, e10) {
        return (t10 = sE.low(t10), e10 = sE.high(e10), sD(t10) || sD(e10)) ? [t10, e10] : null === t10 && null === e10 ? null : void 0;
      }, sum: sR };
      sO(sE, sG);
      let sI = { common: { groupPixelWidth: 2, dateTimeLabelFormats: { millisecond: ["%[AebHMSL]", "%[AebHMSL]", "-%[HMSL]"], second: ["%[AebHMS]", "%[AebHMS]", "-%[HMS]"], minute: ["%[AebHM]", "%[AebHM]", "-%[HM]"], hour: ["%[AebHM]", "%[AebHM]", "-%[HM]"], day: ["%[AebY]", "%[Aeb]", "-%[AebY]"], week: ["week from %[AebY]", "%[Aeb]", "-%[AebY]"], month: ["%[BY]", "%[B]", "-%[BY]"], year: ["%Y", "%Y", "-%Y"] } }, seriesSpecific: { line: {}, spline: {}, area: {}, areaspline: {}, arearange: {}, column: { groupPixelWidth: 10 }, columnrange: { groupPixelWidth: 10 }, candlestick: { groupPixelWidth: 10 }, ohlc: { groupPixelWidth: 5 }, hlc: { groupPixelWidth: 5 }, heikinashi: { groupPixelWidth: 10 } }, units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]] }, { addEvent: sz, extend: sL, merge: sW, pick: sH } = B();
      function sX(t10) {
        let e10 = this, i10 = e10.series;
        i10.forEach(function(t11) {
          t11.groupPixelWidth = void 0;
        }), i10.forEach(function(i11) {
          i11.groupPixelWidth = e10.getGroupPixelWidth && e10.getGroupPixelWidth(), i11.groupPixelWidth && (i11.hasProcessed = true), i11.applyGrouping(!!t10.hasExtremesChanged);
        });
      }
      function sY() {
        let t10 = this.series, e10 = t10.length, i10 = 0, s10 = false, o2, n2;
        for (; e10--; ) (n2 = t10[e10].options.dataGrouping) && (i10 = Math.max(i10, sH(n2.groupPixelWidth, sI.common.groupPixelWidth)), o2 = (t10[e10].dataTable.modified || t10[e10].dataTable).rowCount, (t10[e10].groupPixelWidth || o2 > this.chart.plotSizeX / i10 || o2 && n2.forced) && (s10 = true));
        return s10 ? i10 : 0;
      }
      function sN() {
        this.series.forEach(function(t10) {
          t10.hasProcessed = false;
        });
      }
      function sF(t10, e10) {
        let i10;
        if (e10 = sH(e10, true), t10 || (t10 = { forced: false, units: null }), this instanceof m) for (i10 = this.series.length; i10--; ) this.series[i10].update({ dataGrouping: t10 }, false);
        else this.chart.options.series.forEach(function(e11) {
          e11.dataGrouping = "boolean" == typeof t10 ? t10 : sW(t10, e11.dataGrouping);
        });
        this.ordinal && (this.ordinal.slope = void 0), e10 && this.chart.redraw();
      }
      let sU = { compose: function(t10) {
        m = t10;
        let e10 = t10.prototype;
        e10.applyGrouping || (sz(t10, "afterSetScale", sN), sz(t10, "postProcessData", sX), sL(e10, { applyGrouping: sX, getGroupPixelWidth: sY, setDataGrouping: sF }));
      } }, { addEvent: s_, getMagnitude: sV, normalizeTickInterval: sZ, timeUnits: sj } = B();
      !function(t10) {
        function e10() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        }
        function i10() {
          if ("datetime" !== this.type) {
            this.dateTime = void 0;
            return;
          }
          this.dateTime || (this.dateTime = new s10(this));
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("dateTime") || (t11.keepProps.push("dateTime"), t11.prototype.getTimeTicks = e10, s_(t11, "afterSetType", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          normalizeTimeTickInterval(t11, e11) {
            let i11 = e11 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], s11 = i11[i11.length - 1], o2 = sj[s11[0]], n2 = s11[1], r2;
            for (r2 = 0; r2 < i11.length && (o2 = sj[(s11 = i11[r2])[0]], n2 = s11[1], !i11[r2 + 1] || !(t11 <= (o2 * n2[n2.length - 1] + sj[i11[r2 + 1][0]]) / 2)); r2++) ;
            o2 === sj.year && t11 < 5 * o2 && (n2 = [1, 2, 5]);
            let a2 = sZ(t11 / o2, n2, "year" === s11[0] ? Math.max(sV(t11 / o2), 1) : 1);
            return { unitRange: o2, count: a2, unitName: s11[0] };
          }
          getXDateFormat(t11, e11) {
            let { axis: i11 } = this, s11 = i11.chart.time;
            return i11.closestPointRange ? s11.getDateFormat(i11.closestPointRange, t11, i11.options.startOfWeek, e11) || s11.resolveDTLFormat(e11.year).main : s11.resolveDTLFormat(e11.day).main;
          }
        }
        t10.Additions = s10;
      }(k || (k = {}));
      let sK = k, { series: { prototype: sq } } = tb(), { addEvent: s$, defined: sJ, error: sQ, extend: s0, isNumber: s1, merge: s2, pick: s5, splat: s3 } = B(), s6 = sq.generatePoints;
      function s4(t10) {
        var e10;
        let i10, s10;
        let o2 = this.chart, n2 = this.options.dataGrouping, r2 = false !== this.allowDG && n2 && s5(n2.enabled, o2.options.isStock), a2 = this.reserveSpace(), l2 = this.currentDataGrouping, h2, d2, p2 = false;
        r2 && !this.requireSorting && (this.requireSorting = p2 = true);
        let c2 = false == !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !t10) || !r2;
        if (p2 && (this.requireSorting = false), c2) return;
        this.destroyGroupedData();
        let u2 = n2.groupAll ? this.dataTable : this.dataTable.modified || this.dataTable, g2 = this.getColumn("x", !n2.groupAll), m2 = o2.plotSizeX, f2 = this.xAxis, x2 = f2.getExtremes(), b2 = f2.options.ordinal, v2 = this.groupPixelWidth;
        if (v2 && g2 && u2.rowCount && m2 && s1(x2.min)) {
          s10 = true, this.isDirty = true, this.points = null;
          let t11 = x2.min, r3 = x2.max, l3 = b2 && f2.ordinal && f2.ordinal.getGroupIntervalFactor(t11, r3, this) || 1, p3 = v2 * (r3 - t11) / m2 * l3, c3 = f2.getTimeTicks(sK.Additions.prototype.normalizeTimeTickInterval(p3, n2.units || sI.units), Math.min(t11, g2[0]), Math.max(r3, g2[g2.length - 1]), f2.options.startOfWeek, g2, this.closestPointRange), y2 = sq.groupData.apply(this, [u2, c3, n2.approximation]), M2 = y2.modified, A2 = M2.getColumn("x", true), k2 = 0;
          for ((n2 == null ? void 0 : n2.smoothed) && M2.rowCount && (n2.firstAnchor = "firstPoint", n2.anchor = "middle", n2.lastAnchor = "lastPoint", sQ(32, false, o2, { "dataGrouping.smoothed": "use dataGrouping.anchor" })), i10 = 1; i10 < c3.length; i10++) c3.info.segmentStarts && -1 !== c3.info.segmentStarts.indexOf(i10) || (k2 = Math.max(c3[i10] - c3[i10 - 1], k2));
          (h2 = c3.info).gapSize = k2, this.closestPointRange = c3.info.totalRange, this.groupMap = y2.groupMap, this.currentDataGrouping = h2, !function(t12, e11, i11) {
            let s11 = t12.options.dataGrouping, o3 = t12.currentDataGrouping && t12.currentDataGrouping.gapSize, n3 = t12.getColumn("x");
            if (!(s11 && n3.length && o3 && t12.groupMap)) return;
            let r4 = e11.length - 1, a3 = s11.anchor, l4 = s11.firstAnchor, h3 = s11.lastAnchor, d3 = e11.length - 1, p4 = 0;
            if (l4 && n3[0] >= e11[0]) {
              let i12;
              p4++;
              let s12 = t12.groupMap[0].start, r5 = t12.groupMap[0].length;
              s1(s12) && s1(r5) && (i12 = s12 + (r5 - 1)), e11[0] = { start: e11[0], middle: e11[0] + 0.5 * o3, end: e11[0] + o3, firstPoint: n3[0], lastPoint: i12 && n3[i12] }[l4];
            }
            if (r4 > 0 && h3 && o3 && e11[r4] >= i11 - o3) {
              d3--;
              let i12 = t12.groupMap[t12.groupMap.length - 1].start;
              e11[r4] = { start: e11[r4], middle: e11[r4] + 0.5 * o3, end: e11[r4] + o3, firstPoint: i12 && n3[i12], lastPoint: n3[n3.length - 1] }[h3];
            }
            if (a3 && "start" !== a3) {
              let t13 = o3 * { middle: 0.5, end: 1 }[a3];
              for (; d3 >= p4; ) e11[d3] += t13, d3--;
            }
          }(this, A2 || [], r3), a2 && A2 && (sJ((e10 = A2)[0]) && s1(f2.min) && s1(f2.dataMin) && e10[0] < f2.min && ((!sJ(f2.options.min) && f2.min <= f2.dataMin || f2.min === f2.dataMin) && (f2.min = Math.min(e10[0], f2.min)), f2.dataMin = Math.min(e10[0], f2.dataMin)), sJ(e10[e10.length - 1]) && s1(f2.max) && s1(f2.dataMax) && e10[e10.length - 1] > f2.max && ((!sJ(f2.options.max) && s1(f2.dataMax) && f2.max >= f2.dataMax || f2.max === f2.dataMax) && (f2.max = Math.max(e10[e10.length - 1], f2.max)), f2.dataMax = Math.max(e10[e10.length - 1], f2.dataMax))), n2.groupAll && (this.allGroupedTable = M2, A2 = (M2 = (d2 = this.cropData(M2, f2.min || 0, f2.max || 0)).modified).getColumn("x"), this.cropStart = d2.start), this.dataTable.modified = M2;
        } else this.groupMap = void 0, this.currentDataGrouping = void 0;
        this.hasGroupedData = s10, this.preventGraphAnimation = (l2 && l2.totalRange) !== (h2 && h2.totalRange);
      }
      function s8() {
        this.groupedData && (this.groupedData.forEach(function(t10, e10) {
          t10 && (this.groupedData[e10] = t10.destroy ? t10.destroy() : null);
        }, this), this.groupedData.length = 0, delete this.allGroupedTable);
      }
      function s9() {
        s6.apply(this), this.destroyGroupedData(), this.groupedData = this.hasGroupedData ? this.points : null;
      }
      function s7() {
        return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") || this.options.cumulative ? "sum" : "average";
      }
      function ot(t10, e10, i10) {
        let s10 = t10.getColumn("x", true) || [], o2 = t10.getColumn("y", true), n2 = this, r2 = n2.data, a2 = n2.options && n2.options.data, l2 = [], h2 = new eM(), d2 = [], p2 = t10.rowCount, c2 = !!o2, u2 = [], g2 = n2.pointArrayMap, m2 = g2 && g2.length, f2 = ["x"].concat(g2 || ["y"]), x2 = (g2 || ["y"]).map(() => []), b2 = this.options.dataGrouping && this.options.dataGrouping.groupAll, v2, y2, M2, A2 = 0, k2 = 0, w2 = "function" == typeof i10 ? i10 : i10 && sE[i10] ? sE[i10] : sE[n2.getDGApproximation && n2.getDGApproximation() || "average"];
        if (m2) {
          let t11 = g2.length;
          for (; t11--; ) u2.push([]);
        } else u2.push([]);
        let S2 = m2 || 1;
        for (let t11 = 0; t11 <= p2; t11++) if (!(s10[t11] < e10[0])) {
          for (; void 0 !== e10[A2 + 1] && s10[t11] >= e10[A2 + 1] || t11 === p2; ) {
            if (v2 = e10[A2], n2.dataGroupInfo = { start: b2 ? k2 : n2.cropStart + k2, length: u2[0].length, groupStart: v2 }, M2 = w2.apply(n2, u2), n2.pointClass && !sJ(n2.dataGroupInfo.options) && (n2.dataGroupInfo.options = s2(n2.pointClass.prototype.optionsToObject.call({ series: n2 }, n2.options.data[n2.cropStart + k2])), f2.forEach(function(t12) {
              delete n2.dataGroupInfo.options[t12];
            })), void 0 !== M2) {
              l2.push(v2);
              let t12 = s3(M2);
              for (let e11 = 0; e11 < t12.length; e11++) x2[e11].push(t12[e11]);
              d2.push(n2.dataGroupInfo);
            }
            k2 = t11;
            for (let t12 = 0; t12 < S2; t12++) u2[t12].length = 0, u2[t12].hasNulls = false;
            if (A2 += 1, t11 === p2) break;
          }
          if (t11 === p2) break;
          if (g2) {
            let e11;
            let i11 = b2 ? t11 : n2.cropStart + t11, s11 = r2 && r2[i11] || n2.pointClass.prototype.applyOptions.apply({ series: n2 }, [a2[i11]]);
            for (let t12 = 0; t12 < m2; t12++) s1(e11 = s11[g2[t12]]) ? u2[t12].push(e11) : null === e11 && (u2[t12].hasNulls = true);
          } else s1(y2 = c2 ? o2[t11] : null) ? u2[0].push(y2) : null === y2 && (u2[0].hasNulls = true);
        }
        let E2 = { x: l2 };
        return (g2 || ["y"]).forEach((t11, e11) => {
          E2[t11] = x2[e11];
        }), h2.setColumns(E2), { groupMap: d2, modified: h2 };
      }
      function oe(t10) {
        let e10 = t10.options, i10 = this.type, s10 = this.chart.options.plotOptions, o2 = this.useCommonDataGrouping && sI.common, n2 = sI.seriesSpecific, r2 = B().defaultOptions.plotOptions[i10].dataGrouping;
        if (s10 && (n2[i10] || o2)) {
          let t11 = this.chart.rangeSelector;
          r2 || (r2 = s2(sI.common, n2[i10])), e10.dataGrouping = s2(o2, r2, s10.series && s10.series.dataGrouping, s10[i10].dataGrouping, this.userOptions.dataGrouping, !e10.isInternal && t11 && s1(t11.selected) && t11.buttonOptions[t11.selected].dataGrouping);
        }
      }
      let oi = { compose: function(t10) {
        let e10 = t10.prototype;
        e10.applyGrouping || (s$(t10.prototype.pointClass, "update", function() {
          if (this.dataGroup) return sQ(24, false, this.series.chart), false;
        }), s$(t10, "afterSetOptions", oe), s$(t10, "destroy", s8), s0(e10, { applyGrouping: s4, destroyGroupedData: s8, generatePoints: s9, getDGApproximation: s7, groupData: ot }));
      }, groupData: ot }, { format: os } = ic(), { composed: oo } = B(), { addEvent: on, extend: or, isNumber: oa, pick: ol, pushUnique: oh } = B();
      function od(t10) {
        var _a;
        let e10 = this.chart, i10 = e10.time, s10 = t10.point, o2 = s10.series, n2 = o2.options, r2 = o2.tooltipOptions, a2 = n2.dataGrouping, l2 = o2.xAxis, h2 = r2.xDateFormat || "", d2, p2, c2, u2, g2, m2 = r2[t10.isFooter ? "footerFormat" : "headerFormat"];
        if (l2 && "datetime" === l2.options.type && a2 && oa(s10.key)) {
          p2 = o2.currentDataGrouping, c2 = a2.dateTimeLabelFormats || sI.common.dateTimeLabelFormats, p2 ? (u2 = c2[p2.unitName], 1 === p2.count ? h2 = u2[0] : (h2 = u2[1], d2 = u2[2])) : !h2 && c2 && l2.dateTime && (h2 = l2.dateTime.getXDateFormat(s10.x, r2.dateTimeLabelFormats));
          let n3 = ol((_a = o2.groupMap) == null ? void 0 : _a[s10.index].groupStart, s10.key), f2 = n3 + ((p2 == null ? void 0 : p2.totalRange) || 0) - 1;
          g2 = i10.dateFormat(h2, n3), d2 && (g2 += i10.dateFormat(d2, f2)), o2.chart.styledMode && (m2 = this.styledModeFormat(m2)), t10.text = os(m2, { point: or(s10, { key: g2 }), series: o2 }, e10), t10.preventDefault();
        }
      }
      let op = { compose: function(t10, e10, i10) {
        sU.compose(t10), oi.compose(e10), i10 && oh(oo, "DataGrouping") && on(i10, "headerFormatter", od);
      }, groupData: oi.groupData }, oc = B();
      oc.dataGrouping = oc.dataGrouping || {}, oc.dataGrouping.approximationDefaults = oc.dataGrouping.approximationDefaults || sG, oc.dataGrouping.approximations = oc.dataGrouping.approximations || sE, op.compose(oc.Axis, oc.Series, oc.Tooltip);
      let { defined: ou, isNumber: og, pick: om } = B(), of = { backgroundColor: "string", borderColor: "string", borderRadius: "string", color: "string", fill: "string", fontSize: "string", labels: "string", name: "string", stroke: "string", title: "string" }, { addEvent: ox, isObject: ob, pick: ov, defined: oy, merge: oM } = B(), { getAssignedAxis: oA } = { annotationsFieldsTypes: of, getAssignedAxis: function(t10) {
        return t10.filter((t11) => {
          let e10 = t11.axis.getExtremes(), i10 = e10.min, s10 = e10.max, o2 = om(t11.axis.minPointOffset, 0);
          return og(i10) && og(s10) && t11.value >= i10 - o2 && t11.value <= s10 + o2 && !t11.axis.options.isInternal;
        })[0];
      }, getFieldType: function(t10, e10) {
        let i10 = of[t10], s10 = typeof e10;
        return ou(i10) && (s10 = i10), { string: "text", number: "number", boolean: "checkbox" }[s10];
      } }, ok = [], ow = { enabled: true, sensitivity: 1.1 }, oS = (t10) => (ob(t10) || (t10 = { enabled: t10 ?? true }), oM(ow, t10)), oE = function(t10, e10, i10, s10, o2, n2, r2) {
        let a2 = ov(r2.type, t10.zooming.type, ""), l2 = [];
        "x" === a2 ? l2 = i10 : "y" === a2 ? l2 = s10 : "xy" === a2 && (l2 = t10.axes);
        let h2 = t10.transform({ axes: l2, to: { x: o2 - 5, y: n2 - 5, width: 10, height: 10 }, from: { x: o2 - 5 * e10, y: n2 - 5 * e10, width: 10 * e10, height: 10 * e10 }, trigger: "mousewheel" });
        return h2 && (oy(f) && clearTimeout(f), f = setTimeout(() => {
          var _a;
          (_a = t10.pointer) == null ? void 0 : _a.drop();
        }, 400)), h2;
      };
      function oC() {
        let t10 = oS(this.zooming.mouseWheel);
        t10.enabled && ox(this.container, "wheel", (e10) => {
          var _a, _b;
          e10 = ((_a = this.pointer) == null ? void 0 : _a.normalize(e10)) || e10;
          let { pointer: i10 } = this, s10 = i10 && !i10.inClass(e10.target, "highcharts-no-mousewheel");
          if (this.isInsidePlot(e10.chartX - this.plotLeft, e10.chartY - this.plotTop) && s10) {
            let s11 = t10.sensitivity || 1.1, o2 = e10.detail || (e10.deltaY || 0) / 120, n2 = oA(i10.getCoordinates(e10).xAxis), r2 = oA(i10.getCoordinates(e10).yAxis);
            oE(this, Math.pow(s11, o2), n2 ? [n2.axis] : this.xAxis, r2 ? [r2.axis] : this.yAxis, e10.chartX, e10.chartY, t10) && ((_b = e10.preventDefault) == null ? void 0 : _b.call(e10));
          }
        });
      }
      let oT = B();
      oT.MouseWheelZoom = oT.MouseWheelZoom || { compose: function(t10) {
        -1 === ok.indexOf(t10) && (ok.push(t10), ox(t10, "afterGetContainer", oC));
      } }, oT.MouseWheelZoom.compose(oT.Chart);
      let oB = B();
      oB.Navigator = oB.Navigator || ef, oB.OrdinalAxis = oB.OrdinalAxis || eD, oB.RangeSelector = oB.RangeSelector || il, oB.Scrollbar = oB.Scrollbar || t3, oB.stockChart = oB.stockChart || iD.stockChart, oB.StockChart = oB.StockChart || oB.stockChart, oB.extend(oB.StockChart, iD), V.compose(oB.Series, oB.Axis, oB.Point), sm.compose(oB.Renderer), iK.compose(oB.Series), oB.Navigator.compose(oB.Chart, oB.Axis, oB.Series), oB.OrdinalAxis.compose(oB.Axis, oB.Series, oB.Chart), oB.RangeSelector.compose(oB.Axis, oB.Chart), oB.Scrollbar.compose(oB.Axis), oB.StockChart.compose(oB.Chart, oB.Axis, oB.Series, oB.SVGRenderer);
      let oO = B();
      return C.default;
    })());
  }
});
export default require_stock();
/*! Bundled license information:

highcharts/modules/stock.js:
  (**
  * @license Highcharts JS v12.1.2 (2024-12-21)
  * @module highcharts/modules/mouse-wheel-zoom
  * @requires highcharts
  *
  * Mousewheel zoom module
  *
  * (c) 2023 Askel Eirik Johansson
  *
  * License: www.highcharts.com/license
  *)
  (**
  * @license Highstock JS v12.1.2 (2024-12-21)
  * @module highcharts/modules/stock
  * @requires highcharts
  *
  * Highcharts Stock as a plugin for Highcharts
  *
  * (c) 2010-2024 Torstein Honsi
  *
  * License: www.highcharts.com/license
  *)
*/
//# sourceMappingURL=highcharts_modules_stock.js.map
